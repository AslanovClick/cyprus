{"ast":null,"code":"/* eslint-disable */\n\n/*!\n * @pixi-spine/runtime-4.0 - v3.0.5\n * Compiled Wed, 14 Jul 2021 08:35:22 UTC\n *\n * @pixi-spine/runtime-4.0 is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n * \n * Copyright 2019-2020, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved\n */\nimport { Utils, AttachmentType, Color, MathUtils, PowOut, StringSet, Pool, settings, Vector2, BinaryInput, SpineBase } from '@pixi-spine/base';\nimport { Matrix } from '@pixi/math';\nimport { BLEND_MODES } from '@pixi/constants';\n/**\r\n * The base class for all attachments.\r\n * @public\r\n */\n\nclass Attachment {\n  constructor(name) {\n    if (!name) throw new Error(\"name cannot be null.\");\n    this.name = name;\n  }\n\n}\n/**\r\n * Base class for an attachment with vertices that are transformed by one or more bones and can be deformed by a slot's\r\n * {@link Slot#deform}.\r\n * @public\r\n */\n\n\nclass VertexAttachment extends Attachment {\n  static __initStatic() {\n    this.nextID = 0;\n  }\n  /** The unique ID for this attachment. */\n\n\n  __init() {\n    this.id = VertexAttachment.nextID++;\n  }\n  /** The bones which affect the {@link #getVertices()}. The array entries are, for each vertex, the number of bones affecting\r\n   * the vertex followed by that many bone indices, which is the index of the bone in {@link Skeleton#bones}. Will be null\r\n   * if this attachment has no weights. */\n\n  /** The vertex positions in the bone's coordinate system. For a non-weighted attachment, the values are `x,y`\r\n   * entries for each vertex. For a weighted attachment, the values are `x,y,weight` entries for each bone affecting\r\n   * each vertex. */\n\n  /** The maximum number of world vertex values that can be output by\r\n   * {@link #computeWorldVertices()} using the `count` parameter. */\n\n\n  __init2() {\n    this.worldVerticesLength = 0;\n  }\n  /** Deform keys for the deform attachment are also applied to this attachment. May be null if no deform keys should be applied. */\n\n\n  __init3() {\n    this.deformAttachment = this;\n  }\n\n  constructor(name) {\n    super(name);\n\n    VertexAttachment.prototype.__init.call(this);\n\n    VertexAttachment.prototype.__init2.call(this);\n\n    VertexAttachment.prototype.__init3.call(this);\n  }\n\n  computeWorldVerticesOld(slot, worldVertices) {\n    this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\n  }\n  /** Transforms the attachment's local {@link #vertices} to world coordinates. If the slot's {@link Slot#deform} is\r\n   * not empty, it is used to deform the vertices.\r\n   *\r\n   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\r\n   * Runtimes Guide.\r\n   * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.\r\n   * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.\r\n   * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *\r\n   *           `stride` / 2.\r\n   * @param offset The `worldVertices` index to begin writing values.\r\n   * @param stride The number of `worldVertices` entries between the value pairs written. */\n\n\n  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {\n    count = offset + (count >> 1) * stride;\n    let skeleton = slot.bone.skeleton;\n    let deformArray = slot.deform;\n    let vertices = this.vertices;\n    let bones = this.bones;\n\n    if (!bones) {\n      if (deformArray.length > 0) vertices = deformArray;\n      let mat = slot.bone.matrix;\n      let x = mat.tx;\n      let y = mat.ty;\n      let a = mat.a,\n          b = mat.c,\n          c = mat.b,\n          d = mat.d;\n\n      for (let v = start, w = offset; w < count; v += 2, w += stride) {\n        let vx = vertices[v],\n            vy = vertices[v + 1];\n        worldVertices[w] = vx * a + vy * b + x;\n        worldVertices[w + 1] = vx * c + vy * d + y;\n      }\n\n      return;\n    }\n\n    let v = 0,\n        skip = 0;\n\n    for (let i = 0; i < start; i += 2) {\n      let n = bones[v];\n      v += n + 1;\n      skip += n;\n    }\n\n    let skeletonBones = skeleton.bones;\n\n    if (deformArray.length == 0) {\n      for (let w = offset, b = skip * 3; w < count; w += stride) {\n        let wx = 0,\n            wy = 0;\n        let n = bones[v++];\n        n += v;\n\n        for (; v < n; v++, b += 3) {\n          let mat = skeletonBones[bones[v]].matrix;\n          let vx = vertices[b],\n              vy = vertices[b + 1],\n              weight = vertices[b + 2];\n          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n        }\n\n        worldVertices[w] = wx;\n        worldVertices[w + 1] = wy;\n      }\n    } else {\n      let deform = deformArray;\n\n      for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n        let wx = 0,\n            wy = 0;\n        let n = bones[v++];\n        n += v;\n\n        for (; v < n; v++, b += 3, f += 2) {\n          let mat = skeletonBones[bones[v]].matrix;\n          let vx = vertices[b] + deform[f],\n              vy = vertices[b + 1] + deform[f + 1],\n              weight = vertices[b + 2];\n          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n        }\n\n        worldVertices[w] = wx;\n        worldVertices[w + 1] = wy;\n      }\n    }\n  }\n  /** Does not copy id (generated) or name (set on construction). **/\n\n\n  copyTo(attachment) {\n    if (this.bones) {\n      attachment.bones = new Array(this.bones.length);\n      Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\n    } else attachment.bones = null;\n\n    if (this.vertices) {\n      attachment.vertices = Utils.newFloatArray(this.vertices.length);\n      Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\n    } else attachment.vertices = null;\n\n    attachment.worldVerticesLength = this.worldVerticesLength;\n    attachment.deformAttachment = this.deformAttachment;\n  }\n\n}\n\nVertexAttachment.__initStatic();\n/**\r\n * @public\r\n */\n\n\nclass BoundingBoxAttachment extends VertexAttachment {\n  __init() {\n    this.type = AttachmentType.BoundingBox;\n  }\n\n  __init2() {\n    this.color = new Color(1, 1, 1, 1);\n  }\n\n  constructor(name) {\n    super(name);\n\n    BoundingBoxAttachment.prototype.__init.call(this);\n\n    BoundingBoxAttachment.prototype.__init2.call(this);\n  }\n\n  copy() {\n    let copy = new BoundingBoxAttachment(this.name);\n    this.copyTo(copy);\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass ClippingAttachment extends VertexAttachment {\n  __init() {\n    this.type = AttachmentType.Clipping;\n  } // Nonessential.\n\n  /** The color of the clipping polygon as it was in Spine. Available only when nonessential data was exported. Clipping polygons\r\n   * are not usually rendered at runtime. */\n\n\n  __init2() {\n    this.color = new Color(0.2275, 0.2275, 0.8078, 1);\n  } // ce3a3aff\n\n\n  constructor(name) {\n    super(name);\n\n    ClippingAttachment.prototype.__init.call(this);\n\n    ClippingAttachment.prototype.__init2.call(this);\n  }\n\n  copy() {\n    let copy = new ClippingAttachment(this.name);\n    this.copyTo(copy);\n    copy.endSlot = this.endSlot;\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass MeshAttachment extends VertexAttachment {\n  __init() {\n    this.type = AttachmentType.Mesh;\n  }\n  /** The name of the texture region for this attachment. */\n\n  /** The UV pair for each vertex, normalized within the texture region. */\n\n  /** Triplets of vertex indices which describe the mesh's triangulation. */\n\n  /** The color to tint the mesh. */\n\n\n  __init2() {\n    this.color = new Color(1, 1, 1, 1);\n  }\n  /** The width of the mesh's image. Available only when nonessential data was exported. */\n\n  /** The height of the mesh's image. Available only when nonessential data was exported. */\n\n  /** The number of entries at the beginning of {@link #vertices} that make up the mesh hull. */\n\n  /** Vertex index pairs describing edges for controling triangulation. Mesh triangles will never cross edges. Only available if\r\n   * nonessential data was exported. Triangulation is not performed at runtime. */\n\n\n  __init3() {\n    this.tempColor = new Color(0, 0, 0, 0);\n  }\n\n  constructor(name) {\n    super(name);\n\n    MeshAttachment.prototype.__init.call(this);\n\n    MeshAttachment.prototype.__init2.call(this);\n\n    MeshAttachment.prototype.__init3.call(this);\n  }\n  /** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},\r\n   * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the\r\n   * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */\n\n\n  getParentMesh() {\n    return this.parentMesh;\n  }\n  /** @param parentMesh May be null. */\n\n\n  setParentMesh(parentMesh) {\n    this.parentMesh = parentMesh;\n\n    if (parentMesh) {\n      this.bones = parentMesh.bones;\n      this.vertices = parentMesh.vertices;\n      this.worldVerticesLength = parentMesh.worldVerticesLength;\n      this.regionUVs = parentMesh.regionUVs;\n      this.triangles = parentMesh.triangles;\n      this.hullLength = parentMesh.hullLength;\n      this.worldVerticesLength = parentMesh.worldVerticesLength;\n    }\n  }\n\n  copy() {\n    if (this.parentMesh) return this.newLinkedMesh();\n    let copy = new MeshAttachment(this.name);\n    copy.region = this.region;\n    copy.path = this.path;\n    copy.color.setFromColor(this.color);\n    this.copyTo(copy);\n    copy.regionUVs = new Float32Array(this.regionUVs.length);\n    Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\n    copy.triangles = new Array(this.triangles.length);\n    Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\n    copy.hullLength = this.hullLength; // Nonessential.\n\n    if (this.edges) {\n      copy.edges = new Array(this.edges.length);\n      Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\n    }\n\n    copy.width = this.width;\n    copy.height = this.height;\n    return copy;\n  }\n  /** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/\n\n\n  newLinkedMesh() {\n    let copy = new MeshAttachment(this.name);\n    copy.region = this.region;\n    copy.path = this.path;\n    copy.color.setFromColor(this.color);\n    copy.deformAttachment = this.deformAttachment;\n    copy.setParentMesh(this.parentMesh ? this.parentMesh : this); // copy.updateUVs();\n\n    return copy;\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass PathAttachment extends VertexAttachment {\n  __init() {\n    this.type = AttachmentType.Path;\n  }\n  /** The lengths along the path in the setup pose from the start of the path to the end of each Bezier curve. */\n\n  /** If true, the start and end knots are connected. */\n\n\n  __init2() {\n    this.closed = false;\n  }\n  /** If true, additional calculations are performed to make calculating positions along the path more accurate. If false, fewer\r\n   * calculations are performed but calculating positions along the path is less accurate. */\n\n\n  __init3() {\n    this.constantSpeed = false;\n  }\n  /** The color of the path as it was in Spine. Available only when nonessential data was exported. Paths are not usually\r\n   * rendered at runtime. */\n\n\n  __init4() {\n    this.color = new Color(1, 1, 1, 1);\n  }\n\n  constructor(name) {\n    super(name);\n\n    PathAttachment.prototype.__init.call(this);\n\n    PathAttachment.prototype.__init2.call(this);\n\n    PathAttachment.prototype.__init3.call(this);\n\n    PathAttachment.prototype.__init4.call(this);\n  }\n\n  copy() {\n    let copy = new PathAttachment(this.name);\n    this.copyTo(copy);\n    copy.lengths = new Array(this.lengths.length);\n    Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\n    copy.closed = closed;\n    copy.constantSpeed = this.constantSpeed;\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass PointAttachment extends VertexAttachment {\n  __init() {\n    this.type = AttachmentType.Point;\n  }\n  /** The color of the point attachment as it was in Spine. Available only when nonessential data was exported. Point attachments\r\n   * are not usually rendered at runtime. */\n\n\n  __init2() {\n    this.color = new Color(0.38, 0.94, 0, 1);\n  }\n\n  constructor(name) {\n    super(name);\n\n    PointAttachment.prototype.__init.call(this);\n\n    PointAttachment.prototype.__init2.call(this);\n  }\n\n  computeWorldPosition(bone, point) {\n    const mat = bone.matrix;\n    point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\n    point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\n    return point;\n  }\n\n  computeWorldRotation(bone) {\n    const mat = bone.matrix;\n    let cos = MathUtils.cosDeg(this.rotation),\n        sin = MathUtils.sinDeg(this.rotation);\n    let x = cos * mat.a + sin * mat.c;\n    let y = cos * mat.b + sin * mat.d;\n    return Math.atan2(y, x) * MathUtils.radDeg;\n  }\n\n  copy() {\n    let copy = new PointAttachment(this.name);\n    copy.x = this.x;\n    copy.y = this.y;\n    copy.rotation = this.rotation;\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass RegionAttachment extends Attachment {\n  __init() {\n    this.type = AttachmentType.Region;\n  }\n\n  static __initStatic() {\n    this.OX1 = 0;\n  }\n\n  static __initStatic2() {\n    this.OY1 = 1;\n  }\n\n  static __initStatic3() {\n    this.OX2 = 2;\n  }\n\n  static __initStatic4() {\n    this.OY2 = 3;\n  }\n\n  static __initStatic5() {\n    this.OX3 = 4;\n  }\n\n  static __initStatic6() {\n    this.OY3 = 5;\n  }\n\n  static __initStatic7() {\n    this.OX4 = 6;\n  }\n\n  static __initStatic8() {\n    this.OY4 = 7;\n  }\n\n  static __initStatic9() {\n    this.X1 = 0;\n  }\n\n  static __initStatic10() {\n    this.Y1 = 1;\n  }\n\n  static __initStatic11() {\n    this.C1R = 2;\n  }\n\n  static __initStatic12() {\n    this.C1G = 3;\n  }\n\n  static __initStatic13() {\n    this.C1B = 4;\n  }\n\n  static __initStatic14() {\n    this.C1A = 5;\n  }\n\n  static __initStatic15() {\n    this.U1 = 6;\n  }\n\n  static __initStatic16() {\n    this.V1 = 7;\n  }\n\n  static __initStatic17() {\n    this.X2 = 8;\n  }\n\n  static __initStatic18() {\n    this.Y2 = 9;\n  }\n\n  static __initStatic19() {\n    this.C2R = 10;\n  }\n\n  static __initStatic20() {\n    this.C2G = 11;\n  }\n\n  static __initStatic21() {\n    this.C2B = 12;\n  }\n\n  static __initStatic22() {\n    this.C2A = 13;\n  }\n\n  static __initStatic23() {\n    this.U2 = 14;\n  }\n\n  static __initStatic24() {\n    this.V2 = 15;\n  }\n\n  static __initStatic25() {\n    this.X3 = 16;\n  }\n\n  static __initStatic26() {\n    this.Y3 = 17;\n  }\n\n  static __initStatic27() {\n    this.C3R = 18;\n  }\n\n  static __initStatic28() {\n    this.C3G = 19;\n  }\n\n  static __initStatic29() {\n    this.C3B = 20;\n  }\n\n  static __initStatic30() {\n    this.C3A = 21;\n  }\n\n  static __initStatic31() {\n    this.U3 = 22;\n  }\n\n  static __initStatic32() {\n    this.V3 = 23;\n  }\n\n  static __initStatic33() {\n    this.X4 = 24;\n  }\n\n  static __initStatic34() {\n    this.Y4 = 25;\n  }\n\n  static __initStatic35() {\n    this.C4R = 26;\n  }\n\n  static __initStatic36() {\n    this.C4G = 27;\n  }\n\n  static __initStatic37() {\n    this.C4B = 28;\n  }\n\n  static __initStatic38() {\n    this.C4A = 29;\n  }\n\n  static __initStatic39() {\n    this.U4 = 30;\n  }\n\n  static __initStatic40() {\n    this.V4 = 31;\n  }\n  /** The local x translation. */\n\n\n  __init2() {\n    this.x = 0;\n  }\n  /** The local y translation. */\n\n\n  __init3() {\n    this.y = 0;\n  }\n  /** The local scaleX. */\n\n\n  __init4() {\n    this.scaleX = 1;\n  }\n  /** The local scaleY. */\n\n\n  __init5() {\n    this.scaleY = 1;\n  }\n  /** The local rotation. */\n\n\n  __init6() {\n    this.rotation = 0;\n  }\n  /** The width of the region attachment in Spine. */\n\n\n  __init7() {\n    this.width = 0;\n  }\n  /** The height of the region attachment in Spine. */\n\n\n  __init8() {\n    this.height = 0;\n  }\n  /** The color to tint the region attachment. */\n\n\n  __init9() {\n    this.color = new Color(1, 1, 1, 1);\n  }\n  /** The name of the texture region for this attachment. */\n\n  /** For each of the 4 vertices, a pair of <code>x,y</code> values that is the local position of the vertex.\r\n   *\r\n   * See {@link #updateOffset()}. */\n\n\n  __init10() {\n    this.offset = Utils.newFloatArray(8);\n  }\n\n  __init11() {\n    this.uvs = Utils.newFloatArray(8);\n  }\n\n  __init12() {\n    this.tempColor = new Color(1, 1, 1, 1);\n  }\n\n  constructor(name) {\n    super(name);\n\n    RegionAttachment.prototype.__init.call(this);\n\n    RegionAttachment.prototype.__init2.call(this);\n\n    RegionAttachment.prototype.__init3.call(this);\n\n    RegionAttachment.prototype.__init4.call(this);\n\n    RegionAttachment.prototype.__init5.call(this);\n\n    RegionAttachment.prototype.__init6.call(this);\n\n    RegionAttachment.prototype.__init7.call(this);\n\n    RegionAttachment.prototype.__init8.call(this);\n\n    RegionAttachment.prototype.__init9.call(this);\n\n    RegionAttachment.prototype.__init10.call(this);\n\n    RegionAttachment.prototype.__init11.call(this);\n\n    RegionAttachment.prototype.__init12.call(this);\n  }\n  /** Calculates the {@link #offset} using the region settings. Must be called after changing region settings. */\n\n\n  updateOffset() {\n    let regionScaleX = this.width / this.region.originalWidth * this.scaleX;\n    let regionScaleY = this.height / this.region.originalHeight * this.scaleY;\n    let localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\n    let localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\n    let localX2 = localX + this.region.width * regionScaleX;\n    let localY2 = localY + this.region.height * regionScaleY;\n    let radians = this.rotation * Math.PI / 180;\n    let cos = Math.cos(radians);\n    let sin = Math.sin(radians);\n    let localXCos = localX * cos + this.x;\n    let localXSin = localX * sin;\n    let localYCos = localY * cos + this.y;\n    let localYSin = localY * sin;\n    let localX2Cos = localX2 * cos + this.x;\n    let localX2Sin = localX2 * sin;\n    let localY2Cos = localY2 * cos + this.y;\n    let localY2Sin = localY2 * sin;\n    let offset = this.offset;\n    offset[RegionAttachment.OX1] = localXCos - localYSin;\n    offset[RegionAttachment.OY1] = localYCos + localXSin;\n    offset[RegionAttachment.OX2] = localXCos - localY2Sin;\n    offset[RegionAttachment.OY2] = localY2Cos + localXSin;\n    offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\n    offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\n    offset[RegionAttachment.OX4] = localX2Cos - localYSin;\n    offset[RegionAttachment.OY4] = localYCos + localX2Sin;\n  }\n\n  setRegion(region) {\n    this.region = region;\n    let uvs = this.uvs;\n\n    if (region.degrees == 90) {\n      uvs[2] = region.u;\n      uvs[3] = region.v2;\n      uvs[4] = region.u;\n      uvs[5] = region.v;\n      uvs[6] = region.u2;\n      uvs[7] = region.v;\n      uvs[0] = region.u2;\n      uvs[1] = region.v2;\n    } else {\n      uvs[0] = region.u;\n      uvs[1] = region.v2;\n      uvs[2] = region.u;\n      uvs[3] = region.v;\n      uvs[4] = region.u2;\n      uvs[5] = region.v;\n      uvs[6] = region.u2;\n      uvs[7] = region.v2;\n    }\n  }\n  /** Transforms the attachment's four vertices to world coordinates.\r\n   *\r\n   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\r\n   * Runtimes Guide.\r\n   * @param worldVertices The output world vertices. Must have a length >= `offset` + 8.\r\n   * @param offset The `worldVertices` index to begin writing values.\r\n   * @param stride The number of `worldVertices` entries between the value pairs written. */\n\n\n  computeWorldVertices(bone, worldVertices, offset, stride) {\n    let vertexOffset = this.offset;\n    let mat = bone.matrix;\n    let x = mat.tx,\n        y = mat.ty;\n    let a = mat.a,\n        b = mat.c,\n        c = mat.b,\n        d = mat.d;\n    let offsetX = 0,\n        offsetY = 0;\n    offsetX = vertexOffset[RegionAttachment.OX1];\n    offsetY = vertexOffset[RegionAttachment.OY1];\n    worldVertices[offset] = offsetX * a + offsetY * b + x; // br\n\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    offset += stride;\n    offsetX = vertexOffset[RegionAttachment.OX2];\n    offsetY = vertexOffset[RegionAttachment.OY2];\n    worldVertices[offset] = offsetX * a + offsetY * b + x; // bl\n\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    offset += stride;\n    offsetX = vertexOffset[RegionAttachment.OX3];\n    offsetY = vertexOffset[RegionAttachment.OY3];\n    worldVertices[offset] = offsetX * a + offsetY * b + x; // ul\n\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    offset += stride;\n    offsetX = vertexOffset[RegionAttachment.OX4];\n    offsetY = vertexOffset[RegionAttachment.OY4];\n    worldVertices[offset] = offsetX * a + offsetY * b + x; // ur\n\n    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n  }\n\n  copy() {\n    let copy = new RegionAttachment(this.name);\n    copy.region = this.region;\n    copy.rendererObject = this.rendererObject;\n    copy.path = this.path;\n    copy.x = this.x;\n    copy.y = this.y;\n    copy.scaleX = this.scaleX;\n    copy.scaleY = this.scaleY;\n    copy.rotation = this.rotation;\n    copy.width = this.width;\n    copy.height = this.height;\n    Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\n    Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\n    copy.color.setFromColor(this.color);\n    return copy;\n  }\n\n}\n\nRegionAttachment.__initStatic();\n\nRegionAttachment.__initStatic2();\n\nRegionAttachment.__initStatic3();\n\nRegionAttachment.__initStatic4();\n\nRegionAttachment.__initStatic5();\n\nRegionAttachment.__initStatic6();\n\nRegionAttachment.__initStatic7();\n\nRegionAttachment.__initStatic8();\n\nRegionAttachment.__initStatic9();\n\nRegionAttachment.__initStatic10();\n\nRegionAttachment.__initStatic11();\n\nRegionAttachment.__initStatic12();\n\nRegionAttachment.__initStatic13();\n\nRegionAttachment.__initStatic14();\n\nRegionAttachment.__initStatic15();\n\nRegionAttachment.__initStatic16();\n\nRegionAttachment.__initStatic17();\n\nRegionAttachment.__initStatic18();\n\nRegionAttachment.__initStatic19();\n\nRegionAttachment.__initStatic20();\n\nRegionAttachment.__initStatic21();\n\nRegionAttachment.__initStatic22();\n\nRegionAttachment.__initStatic23();\n\nRegionAttachment.__initStatic24();\n\nRegionAttachment.__initStatic25();\n\nRegionAttachment.__initStatic26();\n\nRegionAttachment.__initStatic27();\n\nRegionAttachment.__initStatic28();\n\nRegionAttachment.__initStatic29();\n\nRegionAttachment.__initStatic30();\n\nRegionAttachment.__initStatic31();\n\nRegionAttachment.__initStatic32();\n\nRegionAttachment.__initStatic33();\n\nRegionAttachment.__initStatic34();\n\nRegionAttachment.__initStatic35();\n\nRegionAttachment.__initStatic36();\n\nRegionAttachment.__initStatic37();\n\nRegionAttachment.__initStatic38();\n\nRegionAttachment.__initStatic39();\n\nRegionAttachment.__initStatic40();\n/**\r\n * @public\r\n */\n\n\nclass JitterEffect {\n  __init() {\n    this.jitterX = 0;\n  }\n\n  __init2() {\n    this.jitterY = 0;\n  }\n\n  constructor(jitterX, jitterY) {\n    JitterEffect.prototype.__init.call(this);\n\n    JitterEffect.prototype.__init2.call(this);\n\n    this.jitterX = jitterX;\n    this.jitterY = jitterY;\n  } //@ts-ignore\n\n\n  begin(skeleton) {} //@ts-ignore\n\n\n  transform(position, uv, light, dark) {\n    position.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n    position.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n  }\n\n  end() {}\n\n}\n/**\r\n * @public\r\n */\n\n\nclass SwirlEffect {\n  static __initStatic() {\n    this.interpolation = new PowOut(2);\n  }\n\n  __init() {\n    this.centerX = 0;\n  }\n\n  __init2() {\n    this.centerY = 0;\n  }\n\n  __init3() {\n    this.radius = 0;\n  }\n\n  __init4() {\n    this.angle = 0;\n  }\n\n  __init5() {\n    this.worldX = 0;\n  }\n\n  __init6() {\n    this.worldY = 0;\n  }\n\n  constructor(radius) {\n    SwirlEffect.prototype.__init.call(this);\n\n    SwirlEffect.prototype.__init2.call(this);\n\n    SwirlEffect.prototype.__init3.call(this);\n\n    SwirlEffect.prototype.__init4.call(this);\n\n    SwirlEffect.prototype.__init5.call(this);\n\n    SwirlEffect.prototype.__init6.call(this);\n\n    this.radius = radius;\n  }\n\n  begin(skeleton) {\n    this.worldX = skeleton.x + this.centerX;\n    this.worldY = skeleton.y + this.centerY;\n  } //@ts-ignore\n\n\n  transform(position, uv, light, dark) {\n    let radAngle = this.angle * MathUtils.degreesToRadians;\n    let x = position.x - this.worldX;\n    let y = position.y - this.worldY;\n    let dist = Math.sqrt(x * x + y * y);\n\n    if (dist < this.radius) {\n      let theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\n      let cos = Math.cos(theta);\n      let sin = Math.sin(theta);\n      position.x = cos * x - sin * y + this.worldX;\n      position.y = sin * x + cos * y + this.worldY;\n    }\n  }\n\n  end() {}\n\n}\n\nSwirlEffect.__initStatic();\n/**\r\n * A simple container for a list of timelines and a name.\r\n * @public\r\n * */\n\n\nclass Animation {\n  /** The animation's name, which is unique across all animations in the skeleton. */\n\n  /** The duration of the animation in seconds, which is the highest time of all keys in the timeline. */\n  constructor(name, timelines, duration) {\n    if (!name) throw new Error(\"name cannot be null.\");\n    this.name = name;\n    this.setTimelines(timelines);\n    this.duration = duration;\n  }\n\n  setTimelines(timelines) {\n    if (!timelines) throw new Error(\"timelines cannot be null.\");\n    this.timelines = timelines;\n    this.timelineIds = new StringSet();\n\n    for (var i = 0; i < timelines.length; i++) this.timelineIds.addAll(timelines[i].getPropertyIds());\n  }\n\n  hasTimeline(ids) {\n    for (let i = 0; i < ids.length; i++) if (this.timelineIds.contains(ids[i])) return true;\n\n    return false;\n  }\n  /** Applies all the animation's timelines to the specified skeleton.\r\n   *\r\n   * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\r\n   * @param loop If true, the animation repeats after {@link #getDuration()}.\r\n   * @param events May be null to ignore fired events. */\n\n\n  apply(skeleton, lastTime, time, loop, events, alpha, blend, direction) {\n    if (!skeleton) throw new Error(\"skeleton cannot be null.\");\n\n    if (loop && this.duration != 0) {\n      time %= this.duration;\n      if (lastTime > 0) lastTime %= this.duration;\n    }\n\n    let timelines = this.timelines;\n\n    for (let i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\n  }\n\n}\n/** Controls how a timeline value is mixed with the setup pose value or current pose value when a timeline's `alpha`\r\n * < 1.\r\n *\r\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\r\n * @public\r\n * */\n\n\nvar MixBlend;\n\n(function (MixBlend) {\n  /** Transitions from the setup value to the timeline value (the current value is not used). Before the first key, the setup\r\n   * value is set. */\n  const setup = 0;\n  MixBlend[MixBlend[\"setup\"] = setup] = \"setup\";\n  /** Transitions from the current value to the timeline value. Before the first key, transitions from the current value to\r\n   * the setup value. Timelines which perform instant transitions, such as {@link DrawOrderTimeline} or\r\n   * {@link AttachmentTimeline}, use the setup value before the first key.\r\n   *\r\n   * `first` is intended for the first animations applied, not for animations layered on top of those. */\n\n  const first = setup + 1;\n  MixBlend[MixBlend[\"first\"] = first] = \"first\";\n  /** Transitions from the current value to the timeline value. No change is made before the first key (the current value is\r\n   * kept until the first key).\r\n   *\r\n   * `replace` is intended for animations layered on top of others, not for the first animations applied. */\n\n  const replace = first + 1;\n  MixBlend[MixBlend[\"replace\"] = replace] = \"replace\";\n  /** Transitions from the current value to the current value plus the timeline value. No change is made before the first key\r\n   * (the current value is kept until the first key).\r\n   *\r\n   * `add` is intended for animations layered on top of others, not for the first animations applied. Properties\r\n   * keyed by additive animations must be set manually or by another animation before applying the additive animations, else\r\n   * the property values will increase continually. */\n\n  const add = replace + 1;\n  MixBlend[MixBlend[\"add\"] = add] = \"add\";\n})(MixBlend || (MixBlend = {}));\n/** Indicates whether a timeline's `alpha` is mixing out over time toward 0 (the setup or current pose value) or\r\n * mixing in toward 1 (the timeline's value).\r\n *\r\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\r\n * @public\r\n * */\n\n\nvar MixDirection;\n\n(function (MixDirection) {\n  const mixIn = 0;\n  MixDirection[MixDirection[\"mixIn\"] = mixIn] = \"mixIn\";\n  const mixOut = mixIn + 1;\n  MixDirection[MixDirection[\"mixOut\"] = mixOut] = \"mixOut\";\n})(MixDirection || (MixDirection = {}));\n\nconst Property = {\n  rotate: 0,\n  x: 1,\n  y: 2,\n  scaleX: 3,\n  scaleY: 4,\n  shearX: 5,\n  shearY: 6,\n  rgb: 7,\n  alpha: 8,\n  rgb2: 9,\n  attachment: 10,\n  deform: 11,\n  event: 12,\n  drawOrder: 13,\n  ikConstraint: 14,\n  transformConstraint: 15,\n  pathConstraintPosition: 16,\n  pathConstraintSpacing: 17,\n  pathConstraintMix: 18\n};\n/** The interface for all timelines.\r\n * @public\r\n * */\n\nclass Timeline {\n  constructor(frameCount, propertyIds) {\n    this.propertyIds = propertyIds;\n    this.frames = Utils.newFloatArray(frameCount * this.getFrameEntries());\n  }\n\n  getPropertyIds() {\n    return this.propertyIds;\n  }\n\n  getFrameEntries() {\n    return 1;\n  }\n\n  getFrameCount() {\n    return this.frames.length / this.getFrameEntries();\n  }\n\n  getDuration() {\n    return this.frames[this.frames.length - this.getFrameEntries()];\n  }\n\n  static search1(frames, time) {\n    let n = frames.length;\n\n    for (let i = 1; i < n; i++) if (frames[i] > time) return i - 1;\n\n    return n - 1;\n  }\n\n  static search(frames, time, step) {\n    let n = frames.length;\n\n    for (let i = step; i < n; i += step) if (frames[i] > time) return i - step;\n\n    return n - step;\n  }\n\n}\n/**\r\n * @public\r\n */\n\n/** The base class for timelines that use interpolation between key frame values.\r\n * @public\r\n * */\n\n\nclass CurveTimeline extends Timeline {\n  // type, x, y, ...\n  constructor(frameCount, bezierCount, propertyIds) {\n    super(frameCount, propertyIds);\n    this.curves = Utils.newFloatArray(frameCount + bezierCount * 18\n    /*BEZIER_SIZE*/\n    );\n    this.curves[frameCount - 1] = 1\n    /*STEPPED*/\n    ;\n  }\n  /** Sets the specified key frame to linear interpolation. */\n\n\n  setLinear(frame) {\n    this.curves[frame] = 0\n    /*LINEAR*/\n    ;\n  }\n  /** Sets the specified key frame to stepped interpolation. */\n\n\n  setStepped(frame) {\n    this.curves[frame] = 1\n    /*STEPPED*/\n    ;\n  }\n  /** Shrinks the storage for Bezier curves, for use when <code>bezierCount</code> (specified in the constructor) was larger\r\n   * than the actual number of Bezier curves. */\n\n\n  shrink(bezierCount) {\n    let size = this.getFrameCount() + bezierCount * 18\n    /*BEZIER_SIZE*/\n    ;\n\n    if (this.curves.length > size) {\n      let newCurves = Utils.newFloatArray(size);\n      Utils.arrayCopy(this.curves, 0, newCurves, 0, size);\n      this.curves = newCurves;\n    }\n  }\n  /** Stores the segments for the specified Bezier curve. For timelines that modify multiple values, there may be more than\r\n   * one curve per frame.\r\n   * @param bezier The ordinal of this Bezier curve for this timeline, between 0 and <code>bezierCount - 1</code> (specified\r\n   *           in the constructor), inclusive.\r\n   * @param frame Between 0 and <code>frameCount - 1</code>, inclusive.\r\n   * @param value The index of the value for this frame that this curve is used for.\r\n   * @param time1 The time for the first key.\r\n   * @param value1 The value for the first key.\r\n   * @param cx1 The time for the first Bezier handle.\r\n   * @param cy1 The value for the first Bezier handle.\r\n   * @param cx2 The time of the second Bezier handle.\r\n   * @param cy2 The value for the second Bezier handle.\r\n   * @param time2 The time for the second key.\r\n   * @param value2 The value for the second key. */\n\n\n  setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {\n    let curves = this.curves;\n    let i = this.getFrameCount() + bezier * 18\n    /*BEZIER_SIZE*/\n    ;\n    if (value == 0) curves[frame] = 2\n    /*BEZIER*/\n    + i;\n    let tmpx = (time1 - cx1 * 2 + cx2) * 0.03,\n        tmpy = (value1 - cy1 * 2 + cy2) * 0.03;\n    let dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006,\n        dddy = ((cy1 - cy2) * 3 - value1 + value2) * 0.006;\n    let ddx = tmpx * 2 + dddx,\n        ddy = tmpy * 2 + dddy;\n    let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667,\n        dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.16666667;\n    let x = time1 + dx,\n        y = value1 + dy;\n\n    for (let n = i + 18\n    /*BEZIER_SIZE*/\n    ; i < n; i += 2) {\n      curves[i] = x;\n      curves[i + 1] = y;\n      dx += ddx;\n      dy += ddy;\n      ddx += dddx;\n      ddy += dddy;\n      x += dx;\n      y += dy;\n    }\n  }\n  /** Returns the Bezier interpolated value for the specified time.\r\n   * @param frameIndex The index into {@link #getFrames()} for the values of the frame before <code>time</code>.\r\n   * @param valueOffset The offset from <code>frameIndex</code> to the value this curve is used for.\r\n   * @param i The index of the Bezier segments. See {@link #getCurveType(int)}. */\n\n\n  getBezierValue(time, frameIndex, valueOffset, i) {\n    let curves = this.curves;\n\n    if (curves[i] > time) {\n      let x = this.frames[frameIndex],\n          y = this.frames[frameIndex + valueOffset];\n      return y + (time - x) / (curves[i] - x) * (curves[i + 1] - y);\n    }\n\n    let n = i + 18\n    /*BEZIER_SIZE*/\n    ;\n\n    for (i += 2; i < n; i += 2) {\n      if (curves[i] >= time) {\n        let x = curves[i - 2],\n            y = curves[i - 1];\n        return y + (time - x) / (curves[i] - x) * (curves[i + 1] - y);\n      }\n    }\n\n    frameIndex += this.getFrameEntries();\n    let x = curves[n - 2],\n        y = curves[n - 1];\n    return y + (time - x) / (this.frames[frameIndex] - x) * (this.frames[frameIndex + valueOffset] - y);\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass CurveTimeline1 extends CurveTimeline {\n  constructor(frameCount, bezierCount, propertyId) {\n    super(frameCount, bezierCount, [propertyId]);\n  }\n\n  getFrameEntries() {\n    return 2\n    /*ENTRIES*/\n    ;\n  }\n  /** Sets the time and value for the specified frame.\r\n   * @param frame Between 0 and <code>frameCount</code>, inclusive.\r\n   * @param time The frame time in seconds. */\n\n\n  setFrame(frame, time, value) {\n    frame <<= 1;\n    this.frames[frame] = time;\n    this.frames[frame + 1\n    /*VALUE*/\n    ] = value;\n  }\n  /** Returns the interpolated value for the specified time. */\n\n\n  getCurveValue(time) {\n    let frames = this.frames;\n    let i = frames.length - 2;\n\n    for (let ii = 2; ii <= i; ii += 2) {\n      if (frames[ii] > time) {\n        i = ii - 2;\n        break;\n      }\n    }\n\n    let curveType = this.curves[i >> 1];\n\n    switch (curveType) {\n      case 0\n      /*LINEAR*/\n      :\n        let before = frames[i],\n            value = frames[i + 1\n        /*VALUE*/\n        ];\n        return value + (time - before) / (frames[i + 2\n        /*ENTRIES*/\n        ] - before) * (frames[i + 2\n        /*ENTRIES*/\n        + 1\n        /*VALUE*/\n        ] - value);\n\n      case 1\n      /*STEPPED*/\n      :\n        return frames[i + 1\n        /*VALUE*/\n        ];\n    }\n\n    return this.getBezierValue(time, i, 1\n    /*VALUE*/\n    , curveType - 2\n    /*BEZIER*/\n    );\n  }\n\n}\n/** The base class for a {@link CurveTimeline} which sets two properties.\r\n * @public\r\n * */\n\n\nclass CurveTimeline2 extends CurveTimeline {\n  /** @param bezierCount The maximum number of Bezier curves. See {@link #shrink(int)}.\r\n   * @param propertyIds Unique identifiers for the properties the timeline modifies. */\n  constructor(frameCount, bezierCount, propertyId1, propertyId2) {\n    super(frameCount, bezierCount, [propertyId1, propertyId2]);\n  }\n\n  getFrameEntries() {\n    return 3\n    /*ENTRIES*/\n    ;\n  }\n  /** Sets the time and values for the specified frame.\r\n   * @param frame Between 0 and <code>frameCount</code>, inclusive.\r\n   * @param time The frame time in seconds. */\n\n\n  setFrame(frame, time, value1, value2) {\n    frame *= 3\n    /*ENTRIES*/\n    ;\n    this.frames[frame] = time;\n    this.frames[frame + 1\n    /*VALUE1*/\n    ] = value1;\n    this.frames[frame + 2\n    /*VALUE2*/\n    ] = value2;\n  }\n\n}\n/** Changes a bone's local {@link Bone#rotation}.\r\n * @public\r\n * */\n\n\nclass RotateTimeline extends CurveTimeline1 {\n  __init() {\n    this.boneIndex = 0;\n  }\n\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, Property.rotate + \"|\" + boneIndex);\n\n    RotateTimeline.prototype.__init.call(this);\n\n    this.boneIndex = boneIndex;\n  }\n\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    let bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    let frames = this.frames;\n\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.rotation = bone.data.rotation;\n          return;\n\n        case MixBlend.first:\n          bone.rotation += (bone.data.rotation - bone.rotation) * alpha;\n      }\n\n      return;\n    }\n\n    let r = this.getCurveValue(time);\n\n    switch (blend) {\n      case MixBlend.setup:\n        bone.rotation = bone.data.rotation + r * alpha;\n        break;\n\n      case MixBlend.first:\n      case MixBlend.replace:\n        r += bone.data.rotation - bone.rotation;\n\n      case MixBlend.add:\n        bone.rotation += r * alpha;\n    }\n  }\n\n}\n/** Changes a bone's local {@link Bone#x} and {@link Bone#y}.\r\n * @public\r\n * */\n\n\nclass TranslateTimeline extends CurveTimeline2 {\n  __init2() {\n    this.boneIndex = 0;\n  }\n\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, Property.x + \"|\" + boneIndex, Property.y + \"|\" + boneIndex);\n\n    TranslateTimeline.prototype.__init2.call(this);\n\n    this.boneIndex = boneIndex;\n  }\n\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    let bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    let frames = this.frames;\n\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.x = bone.data.x;\n          bone.y = bone.data.y;\n          return;\n\n        case MixBlend.first:\n          bone.x += (bone.data.x - bone.x) * alpha;\n          bone.y += (bone.data.y - bone.y) * alpha;\n      }\n\n      return;\n    }\n\n    let x = 0,\n        y = 0;\n    let i = Timeline.search(frames, time, 3\n    /*ENTRIES*/\n    );\n    let curveType = this.curves[i / 3\n    /*ENTRIES*/\n    ];\n\n    switch (curveType) {\n      case 0\n      /*LINEAR*/\n      :\n        let before = frames[i];\n        x = frames[i + 1\n        /*VALUE1*/\n        ];\n        y = frames[i + 2\n        /*VALUE2*/\n        ];\n        let t = (time - before) / (frames[i + 3\n        /*ENTRIES*/\n        ] - before);\n        x += (frames[i + 3\n        /*ENTRIES*/\n        + 1\n        /*VALUE1*/\n        ] - x) * t;\n        y += (frames[i + 3\n        /*ENTRIES*/\n        + 2\n        /*VALUE2*/\n        ] - y) * t;\n        break;\n\n      case 1\n      /*STEPPED*/\n      :\n        x = frames[i + 1\n        /*VALUE1*/\n        ];\n        y = frames[i + 2\n        /*VALUE2*/\n        ];\n        break;\n\n      default:\n        x = this.getBezierValue(time, i, 1\n        /*VALUE1*/\n        , curveType - 2\n        /*BEZIER*/\n        );\n        y = this.getBezierValue(time, i, 2\n        /*VALUE2*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        - 2\n        /*BEZIER*/\n        );\n    }\n\n    switch (blend) {\n      case MixBlend.setup:\n        bone.x = bone.data.x + x * alpha;\n        bone.y = bone.data.y + y * alpha;\n        break;\n\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.x += (bone.data.x + x - bone.x) * alpha;\n        bone.y += (bone.data.y + y - bone.y) * alpha;\n        break;\n\n      case MixBlend.add:\n        bone.x += x * alpha;\n        bone.y += y * alpha;\n    }\n  }\n\n}\n/** Changes a bone's local {@link Bone#x}.\r\n * @public\r\n * */\n\n\nclass TranslateXTimeline extends CurveTimeline1 {\n  __init3() {\n    this.boneIndex = 0;\n  }\n\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, Property.x + \"|\" + boneIndex);\n\n    TranslateXTimeline.prototype.__init3.call(this);\n\n    this.boneIndex = boneIndex;\n  }\n\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    let bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    let frames = this.frames;\n\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.x = bone.data.x;\n          return;\n\n        case MixBlend.first:\n          bone.x += (bone.data.x - bone.x) * alpha;\n      }\n\n      return;\n    }\n\n    let x = this.getCurveValue(time);\n\n    switch (blend) {\n      case MixBlend.setup:\n        bone.x = bone.data.x + x * alpha;\n        break;\n\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.x += (bone.data.x + x - bone.x) * alpha;\n        break;\n\n      case MixBlend.add:\n        bone.x += x * alpha;\n    }\n  }\n\n}\n/** Changes a bone's local {@link Bone#x}.\r\n * @public\r\n * */\n\n\nclass TranslateYTimeline extends CurveTimeline1 {\n  __init4() {\n    this.boneIndex = 0;\n  }\n\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, Property.y + \"|\" + boneIndex);\n\n    TranslateYTimeline.prototype.__init4.call(this);\n\n    this.boneIndex = boneIndex;\n  }\n\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    let bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    let frames = this.frames;\n\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.y = bone.data.y;\n          return;\n\n        case MixBlend.first:\n          bone.y += (bone.data.y - bone.y) * alpha;\n      }\n\n      return;\n    }\n\n    let y = this.getCurveValue(time);\n\n    switch (blend) {\n      case MixBlend.setup:\n        bone.y = bone.data.y + y * alpha;\n        break;\n\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.y += (bone.data.y + y - bone.y) * alpha;\n        break;\n\n      case MixBlend.add:\n        bone.y += y * alpha;\n    }\n  }\n\n}\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\r\n * @public\r\n * */\n\n\nclass ScaleTimeline extends CurveTimeline2 {\n  __init5() {\n    this.boneIndex = 0;\n  }\n\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, Property.scaleX + \"|\" + boneIndex, Property.scaleY + \"|\" + boneIndex);\n\n    ScaleTimeline.prototype.__init5.call(this);\n\n    this.boneIndex = boneIndex;\n  }\n\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    let bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    let frames = this.frames;\n\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.scaleX = bone.data.scaleX;\n          bone.scaleY = bone.data.scaleY;\n          return;\n\n        case MixBlend.first:\n          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n      }\n\n      return;\n    }\n\n    let x, y;\n    let i = Timeline.search(frames, time, 3\n    /*ENTRIES*/\n    );\n    let curveType = this.curves[i / 3\n    /*ENTRIES*/\n    ];\n\n    switch (curveType) {\n      case 0\n      /*LINEAR*/\n      :\n        let before = frames[i];\n        x = frames[i + 1\n        /*VALUE1*/\n        ];\n        y = frames[i + 2\n        /*VALUE2*/\n        ];\n        let t = (time - before) / (frames[i + 3\n        /*ENTRIES*/\n        ] - before);\n        x += (frames[i + 3\n        /*ENTRIES*/\n        + 1\n        /*VALUE1*/\n        ] - x) * t;\n        y += (frames[i + 3\n        /*ENTRIES*/\n        + 2\n        /*VALUE2*/\n        ] - y) * t;\n        break;\n\n      case 1\n      /*STEPPED*/\n      :\n        x = frames[i + 1\n        /*VALUE1*/\n        ];\n        y = frames[i + 2\n        /*VALUE2*/\n        ];\n        break;\n\n      default:\n        x = this.getBezierValue(time, i, 1\n        /*VALUE1*/\n        , curveType - 2\n        /*BEZIER*/\n        );\n        y = this.getBezierValue(time, i, 2\n        /*VALUE2*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        - 2\n        /*BEZIER*/\n        );\n    }\n\n    x *= bone.data.scaleX;\n    y *= bone.data.scaleY;\n\n    if (alpha == 1) {\n      if (blend == MixBlend.add) {\n        bone.scaleX += x - bone.data.scaleX;\n        bone.scaleY += y - bone.data.scaleY;\n      } else {\n        bone.scaleX = x;\n        bone.scaleY = y;\n      }\n    } else {\n      let bx = 0,\n          by = 0;\n\n      if (direction == MixDirection.mixOut) {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = bone.data.scaleX;\n            by = bone.data.scaleY;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = bone.scaleX;\n            by = bone.scaleY;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n\n          case MixBlend.add:\n            bx = bone.scaleX;\n            by = bone.scaleY;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;\n        }\n      } else {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n            by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n            bone.scaleX = bx + (x - bx) * alpha;\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n            by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n            bone.scaleX = bx + (x - bx) * alpha;\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n\n          case MixBlend.add:\n            bx = MathUtils.signum(x);\n            by = MathUtils.signum(y);\n            bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\n            bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\n        }\n      }\n    }\n  }\n\n}\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\r\n * @public\r\n * */\n\n\nclass ScaleXTimeline extends CurveTimeline1 {\n  __init6() {\n    this.boneIndex = 0;\n  }\n\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, Property.scaleX + \"|\" + boneIndex);\n\n    ScaleXTimeline.prototype.__init6.call(this);\n\n    this.boneIndex = boneIndex;\n  }\n\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    let bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    let frames = this.frames;\n\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.scaleX = bone.data.scaleX;\n          return;\n\n        case MixBlend.first:\n          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n      }\n\n      return;\n    }\n\n    let x = this.getCurveValue(time) * bone.data.scaleX;\n\n    if (alpha == 1) {\n      if (blend == MixBlend.add) bone.scaleX += x - bone.data.scaleX;else bone.scaleX = x;\n    } else {\n      // Mixing out uses sign of setup or current pose, else use sign of key.\n      let bx = 0;\n\n      if (direction == MixDirection.mixOut) {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = bone.data.scaleX;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            break;\n\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = bone.scaleX;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            break;\n\n          case MixBlend.add:\n            bx = bone.scaleX;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;\n        }\n      } else {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n            bone.scaleX = bx + (x - bx) * alpha;\n            break;\n\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n            bone.scaleX = bx + (x - bx) * alpha;\n            break;\n\n          case MixBlend.add:\n            bx = MathUtils.signum(x);\n            bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\n        }\n      }\n    }\n  }\n\n}\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\r\n * @public\r\n * */\n\n\nclass ScaleYTimeline extends CurveTimeline1 {\n  __init7() {\n    this.boneIndex = 0;\n  }\n\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, Property.scaleY + \"|\" + boneIndex);\n\n    ScaleYTimeline.prototype.__init7.call(this);\n\n    this.boneIndex = boneIndex;\n  }\n\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    let bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    let frames = this.frames;\n\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.scaleY = bone.data.scaleY;\n          return;\n\n        case MixBlend.first:\n          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n      }\n\n      return;\n    }\n\n    let y = this.getCurveValue(time) * bone.data.scaleY;\n\n    if (alpha == 1) {\n      if (blend == MixBlend.add) bone.scaleY += y - bone.data.scaleY;else bone.scaleY = y;\n    } else {\n      // Mixing out uses sign of setup or current pose, else use sign of key.\n      let by = 0;\n\n      if (direction == MixDirection.mixOut) {\n        switch (blend) {\n          case MixBlend.setup:\n            by = bone.data.scaleY;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n\n          case MixBlend.first:\n          case MixBlend.replace:\n            by = bone.scaleY;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n\n          case MixBlend.add:\n            by = bone.scaleY;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;\n        }\n      } else {\n        switch (blend) {\n          case MixBlend.setup:\n            by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n\n          case MixBlend.first:\n          case MixBlend.replace:\n            by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n\n          case MixBlend.add:\n            by = MathUtils.signum(y);\n            bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\n        }\n      }\n    }\n  }\n\n}\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\r\n * @public\r\n * */\n\n\nclass ShearTimeline extends CurveTimeline2 {\n  __init8() {\n    this.boneIndex = 0;\n  }\n\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, Property.shearX + \"|\" + boneIndex, Property.shearY + \"|\" + boneIndex);\n\n    ShearTimeline.prototype.__init8.call(this);\n\n    this.boneIndex = boneIndex;\n  }\n\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    let bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    let frames = this.frames;\n\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.shearX = bone.data.shearX;\n          bone.shearY = bone.data.shearY;\n          return;\n\n        case MixBlend.first:\n          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n      }\n\n      return;\n    }\n\n    let x = 0,\n        y = 0;\n    let i = Timeline.search(frames, time, 3\n    /*ENTRIES*/\n    );\n    let curveType = this.curves[i / 3\n    /*ENTRIES*/\n    ];\n\n    switch (curveType) {\n      case 0\n      /*LINEAR*/\n      :\n        let before = frames[i];\n        x = frames[i + 1\n        /*VALUE1*/\n        ];\n        y = frames[i + 2\n        /*VALUE2*/\n        ];\n        let t = (time - before) / (frames[i + 3\n        /*ENTRIES*/\n        ] - before);\n        x += (frames[i + 3\n        /*ENTRIES*/\n        + 1\n        /*VALUE1*/\n        ] - x) * t;\n        y += (frames[i + 3\n        /*ENTRIES*/\n        + 2\n        /*VALUE2*/\n        ] - y) * t;\n        break;\n\n      case 1\n      /*STEPPED*/\n      :\n        x = frames[i + 1\n        /*VALUE1*/\n        ];\n        y = frames[i + 2\n        /*VALUE2*/\n        ];\n        break;\n\n      default:\n        x = this.getBezierValue(time, i, 1\n        /*VALUE1*/\n        , curveType - 2\n        /*BEZIER*/\n        );\n        y = this.getBezierValue(time, i, 2\n        /*VALUE2*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        - 2\n        /*BEZIER*/\n        );\n    }\n\n    switch (blend) {\n      case MixBlend.setup:\n        bone.shearX = bone.data.shearX + x * alpha;\n        bone.shearY = bone.data.shearY + y * alpha;\n        break;\n\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n        break;\n\n      case MixBlend.add:\n        bone.shearX += x * alpha;\n        bone.shearY += y * alpha;\n    }\n  }\n\n}\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\r\n * @public\r\n * */\n\n\nclass ShearXTimeline extends CurveTimeline1 {\n  __init9() {\n    this.boneIndex = 0;\n  }\n\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, Property.shearX + \"|\" + boneIndex);\n\n    ShearXTimeline.prototype.__init9.call(this);\n\n    this.boneIndex = boneIndex;\n  }\n\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    let bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    let frames = this.frames;\n\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.shearX = bone.data.shearX;\n          return;\n\n        case MixBlend.first:\n          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n      }\n\n      return;\n    }\n\n    let x = this.getCurveValue(time);\n\n    switch (blend) {\n      case MixBlend.setup:\n        bone.shearX = bone.data.shearX + x * alpha;\n        break;\n\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n        break;\n\n      case MixBlend.add:\n        bone.shearX += x * alpha;\n    }\n  }\n\n}\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\r\n * @public\r\n * */\n\n\nclass ShearYTimeline extends CurveTimeline1 {\n  __init10() {\n    this.boneIndex = 0;\n  }\n\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, Property.shearY + \"|\" + boneIndex);\n\n    ShearYTimeline.prototype.__init10.call(this);\n\n    this.boneIndex = boneIndex;\n  }\n\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    let bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    let frames = this.frames;\n\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.shearY = bone.data.shearY;\n          return;\n\n        case MixBlend.first:\n          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n      }\n\n      return;\n    }\n\n    let y = this.getCurveValue(time);\n\n    switch (blend) {\n      case MixBlend.setup:\n        bone.shearY = bone.data.shearY + y * alpha;\n        break;\n\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n        break;\n\n      case MixBlend.add:\n        bone.shearY += y * alpha;\n    }\n  }\n\n}\n/** Changes a slot's {@link Slot#color}.\r\n * @public\r\n * */\n\n\nclass RGBATimeline extends CurveTimeline {\n  __init11() {\n    this.slotIndex = 0;\n  }\n\n  constructor(frameCount, bezierCount, slotIndex) {\n    super(frameCount, bezierCount, [Property.rgb + \"|\" + slotIndex, Property.alpha + \"|\" + slotIndex]);\n\n    RGBATimeline.prototype.__init11.call(this);\n\n    this.slotIndex = slotIndex;\n  }\n\n  getFrameEntries() {\n    return 5\n    /*ENTRIES*/\n    ;\n  }\n  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n\n\n  setFrame(frame, time, r, g, b, a) {\n    frame *= 5\n    /*ENTRIES*/\n    ;\n    this.frames[frame] = time;\n    this.frames[frame + 1\n    /*R*/\n    ] = r;\n    this.frames[frame + 2\n    /*G*/\n    ] = g;\n    this.frames[frame + 3\n    /*B*/\n    ] = b;\n    this.frames[frame + 4\n    /*A*/\n    ] = a;\n  }\n\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    let slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n    let frames = this.frames;\n    let color = slot.color;\n\n    if (time < frames[0]) {\n      let setup = slot.data.color;\n\n      switch (blend) {\n        case MixBlend.setup:\n          color.setFromColor(setup);\n          return;\n\n        case MixBlend.first:\n          color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\n      }\n\n      return;\n    }\n\n    let r = 0,\n        g = 0,\n        b = 0,\n        a = 0;\n    let i = Timeline.search(frames, time, 5\n    /*ENTRIES*/\n    );\n    let curveType = this.curves[i / 5\n    /*ENTRIES*/\n    ];\n\n    switch (curveType) {\n      case 0\n      /*LINEAR*/\n      :\n        let before = frames[i];\n        r = frames[i + 1\n        /*R*/\n        ];\n        g = frames[i + 2\n        /*G*/\n        ];\n        b = frames[i + 3\n        /*B*/\n        ];\n        a = frames[i + 4\n        /*A*/\n        ];\n        let t = (time - before) / (frames[i + 5\n        /*ENTRIES*/\n        ] - before);\n        r += (frames[i + 5\n        /*ENTRIES*/\n        + 1\n        /*R*/\n        ] - r) * t;\n        g += (frames[i + 5\n        /*ENTRIES*/\n        + 2\n        /*G*/\n        ] - g) * t;\n        b += (frames[i + 5\n        /*ENTRIES*/\n        + 3\n        /*B*/\n        ] - b) * t;\n        a += (frames[i + 5\n        /*ENTRIES*/\n        + 4\n        /*A*/\n        ] - a) * t;\n        break;\n\n      case 1\n      /*STEPPED*/\n      :\n        r = frames[i + 1\n        /*R*/\n        ];\n        g = frames[i + 2\n        /*G*/\n        ];\n        b = frames[i + 3\n        /*B*/\n        ];\n        a = frames[i + 4\n        /*A*/\n        ];\n        break;\n\n      default:\n        r = this.getBezierValue(time, i, 1\n        /*R*/\n        , curveType - 2\n        /*BEZIER*/\n        );\n        g = this.getBezierValue(time, i, 2\n        /*G*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        - 2\n        /*BEZIER*/\n        );\n        b = this.getBezierValue(time, i, 3\n        /*B*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        * 2 - 2\n        /*BEZIER*/\n        );\n        a = this.getBezierValue(time, i, 4\n        /*A*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        * 3 - 2\n        /*BEZIER*/\n        );\n    }\n\n    if (alpha == 1) color.set(r, g, b, a);else {\n      if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\n      color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n    }\n  }\n\n}\n/** Changes a slot's {@link Slot#color}.\r\n * @public\r\n * */\n\n\nclass RGBTimeline extends CurveTimeline {\n  __init12() {\n    this.slotIndex = 0;\n  }\n\n  constructor(frameCount, bezierCount, slotIndex) {\n    super(frameCount, bezierCount, [Property.rgb + \"|\" + slotIndex]);\n\n    RGBTimeline.prototype.__init12.call(this);\n\n    this.slotIndex = slotIndex;\n  }\n\n  getFrameEntries() {\n    return 4\n    /*ENTRIES*/\n    ;\n  }\n  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n\n\n  setFrame(frame, time, r, g, b) {\n    frame <<= 2;\n    this.frames[frame] = time;\n    this.frames[frame + 1\n    /*R*/\n    ] = r;\n    this.frames[frame + 2\n    /*G*/\n    ] = g;\n    this.frames[frame + 3\n    /*B*/\n    ] = b;\n  }\n\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    let slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n    let frames = this.frames;\n    let color = slot.color;\n\n    if (time < frames[0]) {\n      let setup = slot.data.color;\n\n      switch (blend) {\n        case MixBlend.setup:\n          color.r = setup.r;\n          color.g = setup.g;\n          color.b = setup.b;\n          return;\n\n        case MixBlend.first:\n          color.r += (setup.r - color.r) * alpha;\n          color.g += (setup.g - color.g) * alpha;\n          color.b += (setup.b - color.b) * alpha;\n      }\n\n      return;\n    }\n\n    let r = 0,\n        g = 0,\n        b = 0;\n    let i = Timeline.search(frames, time, 4\n    /*ENTRIES*/\n    );\n    let curveType = this.curves[i >> 2];\n\n    switch (curveType) {\n      case 0\n      /*LINEAR*/\n      :\n        let before = frames[i];\n        r = frames[i + 1\n        /*R*/\n        ];\n        g = frames[i + 2\n        /*G*/\n        ];\n        b = frames[i + 3\n        /*B*/\n        ];\n        let t = (time - before) / (frames[i + 4\n        /*ENTRIES*/\n        ] - before);\n        r += (frames[i + 4\n        /*ENTRIES*/\n        + 1\n        /*R*/\n        ] - r) * t;\n        g += (frames[i + 4\n        /*ENTRIES*/\n        + 2\n        /*G*/\n        ] - g) * t;\n        b += (frames[i + 4\n        /*ENTRIES*/\n        + 3\n        /*B*/\n        ] - b) * t;\n        break;\n\n      case 1\n      /*STEPPED*/\n      :\n        r = frames[i + 1\n        /*R*/\n        ];\n        g = frames[i + 2\n        /*G*/\n        ];\n        b = frames[i + 3\n        /*B*/\n        ];\n        break;\n\n      default:\n        r = this.getBezierValue(time, i, 1\n        /*R*/\n        , curveType - 2\n        /*BEZIER*/\n        );\n        g = this.getBezierValue(time, i, 2\n        /*G*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        - 2\n        /*BEZIER*/\n        );\n        b = this.getBezierValue(time, i, 3\n        /*B*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        * 2 - 2\n        /*BEZIER*/\n        );\n    }\n\n    if (alpha == 1) {\n      color.r = r;\n      color.g = g;\n      color.b = b;\n    } else {\n      if (blend == MixBlend.setup) {\n        let setup = slot.data.color;\n        color.r = setup.r;\n        color.g = setup.g;\n        color.b = setup.b;\n      }\n\n      color.r += (r - color.r) * alpha;\n      color.g += (g - color.g) * alpha;\n      color.b += (b - color.b) * alpha;\n    }\n  }\n\n}\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\r\n * @public\r\n * */\n\n\nclass AlphaTimeline extends CurveTimeline1 {\n  __init13() {\n    this.slotIndex = 0;\n  }\n\n  constructor(frameCount, bezierCount, slotIndex) {\n    super(frameCount, bezierCount, Property.alpha + \"|\" + slotIndex);\n\n    AlphaTimeline.prototype.__init13.call(this);\n\n    this.slotIndex = slotIndex;\n  }\n\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    let slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n    let color = slot.color;\n\n    if (time < this.frames[0]) {\n      // Time is before first frame.\n      let setup = slot.data.color;\n\n      switch (blend) {\n        case MixBlend.setup:\n          color.a = setup.a;\n          return;\n\n        case MixBlend.first:\n          color.a += (setup.a - color.a) * alpha;\n      }\n\n      return;\n    }\n\n    let a = this.getCurveValue(time);\n    if (alpha == 1) color.a = a;else {\n      if (blend == MixBlend.setup) color.a = slot.data.color.a;\n      color.a += (a - color.a) * alpha;\n    }\n  }\n\n}\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting.\r\n * @public\r\n * */\n\n\nclass RGBA2Timeline extends CurveTimeline {\n  __init14() {\n    this.slotIndex = 0;\n  }\n\n  constructor(frameCount, bezierCount, slotIndex) {\n    super(frameCount, bezierCount, [Property.rgb + \"|\" + slotIndex, Property.alpha + \"|\" + slotIndex, Property.rgb2 + \"|\" + slotIndex]);\n\n    RGBA2Timeline.prototype.__init14.call(this);\n\n    this.slotIndex = slotIndex;\n  }\n\n  getFrameEntries() {\n    return 8\n    /*ENTRIES*/\n    ;\n  }\n  /** Sets the time in seconds, light, and dark colors for the specified key frame. */\n\n\n  setFrame(frame, time, r, g, b, a, r2, g2, b2) {\n    frame <<= 3;\n    this.frames[frame] = time;\n    this.frames[frame + 1\n    /*R*/\n    ] = r;\n    this.frames[frame + 2\n    /*G*/\n    ] = g;\n    this.frames[frame + 3\n    /*B*/\n    ] = b;\n    this.frames[frame + 4\n    /*A*/\n    ] = a;\n    this.frames[frame + 5\n    /*R2*/\n    ] = r2;\n    this.frames[frame + 6\n    /*G2*/\n    ] = g2;\n    this.frames[frame + 7\n    /*B2*/\n    ] = b2;\n  }\n\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    let slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n    let frames = this.frames;\n    let light = slot.color,\n        dark = slot.darkColor;\n\n    if (time < frames[0]) {\n      let setupLight = slot.data.color,\n          setupDark = slot.data.darkColor;\n\n      switch (blend) {\n        case MixBlend.setup:\n          light.setFromColor(setupLight);\n          dark.r = setupDark.r;\n          dark.g = setupDark.g;\n          dark.b = setupDark.b;\n          return;\n\n        case MixBlend.first:\n          light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\n          dark.r += (setupDark.r - dark.r) * alpha;\n          dark.g += (setupDark.g - dark.g) * alpha;\n          dark.b += (setupDark.b - dark.b) * alpha;\n      }\n\n      return;\n    }\n\n    let r = 0,\n        g = 0,\n        b = 0,\n        a = 0,\n        r2 = 0,\n        g2 = 0,\n        b2 = 0;\n    let i = Timeline.search(frames, time, 8\n    /*ENTRIES*/\n    );\n    let curveType = this.curves[i >> 3];\n\n    switch (curveType) {\n      case 0\n      /*LINEAR*/\n      :\n        let before = frames[i];\n        r = frames[i + 1\n        /*R*/\n        ];\n        g = frames[i + 2\n        /*G*/\n        ];\n        b = frames[i + 3\n        /*B*/\n        ];\n        a = frames[i + 4\n        /*A*/\n        ];\n        r2 = frames[i + 5\n        /*R2*/\n        ];\n        g2 = frames[i + 6\n        /*G2*/\n        ];\n        b2 = frames[i + 7\n        /*B2*/\n        ];\n        let t = (time - before) / (frames[i + 8\n        /*ENTRIES*/\n        ] - before);\n        r += (frames[i + 8\n        /*ENTRIES*/\n        + 1\n        /*R*/\n        ] - r) * t;\n        g += (frames[i + 8\n        /*ENTRIES*/\n        + 2\n        /*G*/\n        ] - g) * t;\n        b += (frames[i + 8\n        /*ENTRIES*/\n        + 3\n        /*B*/\n        ] - b) * t;\n        a += (frames[i + 8\n        /*ENTRIES*/\n        + 4\n        /*A*/\n        ] - a) * t;\n        r2 += (frames[i + 8\n        /*ENTRIES*/\n        + 5\n        /*R2*/\n        ] - r2) * t;\n        g2 += (frames[i + 8\n        /*ENTRIES*/\n        + 6\n        /*G2*/\n        ] - g2) * t;\n        b2 += (frames[i + 8\n        /*ENTRIES*/\n        + 7\n        /*B2*/\n        ] - b2) * t;\n        break;\n\n      case 1\n      /*STEPPED*/\n      :\n        r = frames[i + 1\n        /*R*/\n        ];\n        g = frames[i + 2\n        /*G*/\n        ];\n        b = frames[i + 3\n        /*B*/\n        ];\n        a = frames[i + 4\n        /*A*/\n        ];\n        r2 = frames[i + 5\n        /*R2*/\n        ];\n        g2 = frames[i + 6\n        /*G2*/\n        ];\n        b2 = frames[i + 7\n        /*B2*/\n        ];\n        break;\n\n      default:\n        r = this.getBezierValue(time, i, 1\n        /*R*/\n        , curveType - 2\n        /*BEZIER*/\n        );\n        g = this.getBezierValue(time, i, 2\n        /*G*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        - 2\n        /*BEZIER*/\n        );\n        b = this.getBezierValue(time, i, 3\n        /*B*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        * 2 - 2\n        /*BEZIER*/\n        );\n        a = this.getBezierValue(time, i, 4\n        /*A*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        * 3 - 2\n        /*BEZIER*/\n        );\n        r2 = this.getBezierValue(time, i, 5\n        /*R2*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        * 4 - 2\n        /*BEZIER*/\n        );\n        g2 = this.getBezierValue(time, i, 6\n        /*G2*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        * 5 - 2\n        /*BEZIER*/\n        );\n        b2 = this.getBezierValue(time, i, 7\n        /*B2*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        * 6 - 2\n        /*BEZIER*/\n        );\n    }\n\n    if (alpha == 1) {\n      light.set(r, g, b, a);\n      dark.r = r2;\n      dark.g = g2;\n      dark.b = b2;\n    } else {\n      if (blend == MixBlend.setup) {\n        light.setFromColor(slot.data.color);\n        let setupDark = slot.data.darkColor;\n        dark.r = setupDark.r;\n        dark.g = setupDark.g;\n        dark.b = setupDark.b;\n      }\n\n      light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n      dark.r += (r2 - dark.r) * alpha;\n      dark.g += (g2 - dark.g) * alpha;\n      dark.b += (b2 - dark.b) * alpha;\n    }\n  }\n\n}\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting.\r\n * @public\r\n * */\n\n\nclass RGB2Timeline extends CurveTimeline {\n  __init15() {\n    this.slotIndex = 0;\n  }\n\n  constructor(frameCount, bezierCount, slotIndex) {\n    super(frameCount, bezierCount, [Property.rgb + \"|\" + slotIndex, Property.rgb2 + \"|\" + slotIndex]);\n\n    RGB2Timeline.prototype.__init15.call(this);\n\n    this.slotIndex = slotIndex;\n  }\n\n  getFrameEntries() {\n    return 7\n    /*ENTRIES*/\n    ;\n  }\n  /** Sets the time in seconds, light, and dark colors for the specified key frame. */\n\n\n  setFrame(frame, time, r, g, b, r2, g2, b2) {\n    frame *= 7\n    /*ENTRIES*/\n    ;\n    this.frames[frame] = time;\n    this.frames[frame + 1\n    /*R*/\n    ] = r;\n    this.frames[frame + 2\n    /*G*/\n    ] = g;\n    this.frames[frame + 3\n    /*B*/\n    ] = b;\n    this.frames[frame + 4\n    /*R2*/\n    ] = r2;\n    this.frames[frame + 5\n    /*G2*/\n    ] = g2;\n    this.frames[frame + 6\n    /*B2*/\n    ] = b2;\n  }\n\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    let slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n    let frames = this.frames;\n    let light = slot.color,\n        dark = slot.darkColor;\n\n    if (time < frames[0]) {\n      let setupLight = slot.data.color,\n          setupDark = slot.data.darkColor;\n\n      switch (blend) {\n        case MixBlend.setup:\n          light.r = setupLight.r;\n          light.g = setupLight.g;\n          light.b = setupLight.b;\n          dark.r = setupDark.r;\n          dark.g = setupDark.g;\n          dark.b = setupDark.b;\n          return;\n\n        case MixBlend.first:\n          light.r += (setupLight.r - light.r) * alpha;\n          light.g += (setupLight.g - light.g) * alpha;\n          light.b += (setupLight.b - light.b) * alpha;\n          dark.r += (setupDark.r - dark.r) * alpha;\n          dark.g += (setupDark.g - dark.g) * alpha;\n          dark.b += (setupDark.b - dark.b) * alpha;\n      }\n\n      return;\n    }\n\n    let r = 0,\n        g = 0,\n        b = 0,\n        r2 = 0,\n        g2 = 0,\n        b2 = 0;\n    let i = Timeline.search(frames, time, 7\n    /*ENTRIES*/\n    );\n    let curveType = this.curves[i / 7\n    /*ENTRIES*/\n    ];\n\n    switch (curveType) {\n      case 0\n      /*LINEAR*/\n      :\n        let before = frames[i];\n        r = frames[i + 1\n        /*R*/\n        ];\n        g = frames[i + 2\n        /*G*/\n        ];\n        b = frames[i + 3\n        /*B*/\n        ];\n        r2 = frames[i + 4\n        /*R2*/\n        ];\n        g2 = frames[i + 5\n        /*G2*/\n        ];\n        b2 = frames[i + 6\n        /*B2*/\n        ];\n        let t = (time - before) / (frames[i + 7\n        /*ENTRIES*/\n        ] - before);\n        r += (frames[i + 7\n        /*ENTRIES*/\n        + 1\n        /*R*/\n        ] - r) * t;\n        g += (frames[i + 7\n        /*ENTRIES*/\n        + 2\n        /*G*/\n        ] - g) * t;\n        b += (frames[i + 7\n        /*ENTRIES*/\n        + 3\n        /*B*/\n        ] - b) * t;\n        r2 += (frames[i + 7\n        /*ENTRIES*/\n        + 4\n        /*R2*/\n        ] - r2) * t;\n        g2 += (frames[i + 7\n        /*ENTRIES*/\n        + 5\n        /*G2*/\n        ] - g2) * t;\n        b2 += (frames[i + 7\n        /*ENTRIES*/\n        + 6\n        /*B2*/\n        ] - b2) * t;\n        break;\n\n      case 1\n      /*STEPPED*/\n      :\n        r = frames[i + 1\n        /*R*/\n        ];\n        g = frames[i + 2\n        /*G*/\n        ];\n        b = frames[i + 3\n        /*B*/\n        ];\n        r2 = frames[i + 4\n        /*R2*/\n        ];\n        g2 = frames[i + 5\n        /*G2*/\n        ];\n        b2 = frames[i + 6\n        /*B2*/\n        ];\n        break;\n\n      default:\n        r = this.getBezierValue(time, i, 1\n        /*R*/\n        , curveType - 2\n        /*BEZIER*/\n        );\n        g = this.getBezierValue(time, i, 2\n        /*G*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        - 2\n        /*BEZIER*/\n        );\n        b = this.getBezierValue(time, i, 3\n        /*B*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        * 2 - 2\n        /*BEZIER*/\n        );\n        r2 = this.getBezierValue(time, i, 4\n        /*R2*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        * 3 - 2\n        /*BEZIER*/\n        );\n        g2 = this.getBezierValue(time, i, 5\n        /*G2*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        * 4 - 2\n        /*BEZIER*/\n        );\n        b2 = this.getBezierValue(time, i, 6\n        /*B2*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        * 5 - 2\n        /*BEZIER*/\n        );\n    }\n\n    if (alpha == 1) {\n      light.r = r;\n      light.g = g;\n      light.b = b;\n      dark.r = r2;\n      dark.g = g2;\n      dark.b = b2;\n    } else {\n      if (blend == MixBlend.setup) {\n        let setupLight = slot.data.color,\n            setupDark = slot.data.darkColor;\n        light.r = setupLight.r;\n        light.g = setupLight.g;\n        light.b = setupLight.b;\n        dark.r = setupDark.r;\n        dark.g = setupDark.g;\n        dark.b = setupDark.b;\n      }\n\n      light.r += (r - light.r) * alpha;\n      light.g += (g - light.g) * alpha;\n      light.b += (b - light.b) * alpha;\n      dark.r += (r2 - dark.r) * alpha;\n      dark.g += (g2 - dark.g) * alpha;\n      dark.b += (b2 - dark.b) * alpha;\n    }\n  }\n\n}\n/** Changes a slot's {@link Slot#attachment}.\r\n * @public\r\n * */\n\n\nclass AttachmentTimeline extends Timeline {\n  __init16() {\n    this.slotIndex = 0;\n  }\n  /** The attachment name for each key frame. May contain null values to clear the attachment. */\n\n\n  constructor(frameCount, slotIndex) {\n    super(frameCount, [Property.attachment + \"|\" + slotIndex]);\n\n    AttachmentTimeline.prototype.__init16.call(this);\n\n    this.slotIndex = slotIndex;\n    this.attachmentNames = new Array(frameCount);\n  }\n\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time in seconds and the attachment name for the specified key frame. */\n\n\n  setFrame(frame, time, attachmentName) {\n    this.frames[frame] = time;\n    this.attachmentNames[frame] = attachmentName;\n  }\n\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    let slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n\n    if (direction == MixDirection.mixOut) {\n      if (blend == MixBlend.setup) this.setAttachment(skeleton, slot, slot.data.attachmentName);\n      return;\n    }\n\n    if (time < this.frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName);\n      return;\n    }\n\n    this.setAttachment(skeleton, slot, this.attachmentNames[Timeline.search1(this.frames, time)]);\n  }\n\n  setAttachment(skeleton, slot, attachmentName) {\n    slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n  }\n\n}\n/** Changes a slot's {@link Slot#deform} to deform a {@link VertexAttachment}.\r\n * @public\r\n * */\n\n\nclass DeformTimeline extends CurveTimeline {\n  __init17() {\n    this.slotIndex = 0;\n  }\n  /** The attachment that will be deformed. */\n\n  /** The vertices for each key frame. */\n\n\n  constructor(frameCount, bezierCount, slotIndex, attachment) {\n    super(frameCount, bezierCount, [Property.deform + \"|\" + slotIndex + \"|\" + attachment.id]);\n\n    DeformTimeline.prototype.__init17.call(this);\n\n    this.slotIndex = slotIndex;\n    this.attachment = attachment;\n    this.vertices = new Array(frameCount);\n  }\n\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time in seconds and the vertices for the specified key frame.\r\n   * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\n\n\n  setFrame(frame, time, vertices) {\n    this.frames[frame] = time;\n    this.vertices[frame] = vertices;\n  }\n  /** @param value1 Ignored (0 is used for a deform timeline).\r\n   * @param value2 Ignored (1 is used for a deform timeline). */\n\n\n  setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {\n    let curves = this.curves;\n    let i = this.getFrameCount() + bezier * 18\n    /*BEZIER_SIZE*/\n    ;\n    if (value == 0) curves[frame] = 2\n    /*BEZIER*/\n    + i;\n    let tmpx = (time1 - cx1 * 2 + cx2) * 0.03,\n        tmpy = cy2 * 0.03 - cy1 * 0.06;\n    let dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006,\n        dddy = (cy1 - cy2 + 0.33333333) * 0.018;\n    let ddx = tmpx * 2 + dddx,\n        ddy = tmpy * 2 + dddy;\n    let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667,\n        dy = cy1 * 0.3 + tmpy + dddy * 0.16666667;\n    let x = time1 + dx,\n        y = dy;\n\n    for (let n = i + 18\n    /*BEZIER_SIZE*/\n    ; i < n; i += 2) {\n      curves[i] = x;\n      curves[i + 1] = y;\n      dx += ddx;\n      dy += ddy;\n      ddx += dddx;\n      ddy += dddy;\n      x += dx;\n      y += dy;\n    }\n  }\n\n  getCurvePercent(time, frame) {\n    let curves = this.curves;\n    let i = curves[frame];\n\n    switch (i) {\n      case 0\n      /*LINEAR*/\n      :\n        let x = this.frames[frame];\n        return (time - x) / (this.frames[frame + this.getFrameEntries()] - x);\n\n      case 1\n      /*STEPPED*/\n      :\n        return 0;\n    }\n\n    i -= 2\n    /*BEZIER*/\n    ;\n\n    if (curves[i] > time) {\n      let x = this.frames[frame];\n      return curves[i + 1] * (time - x) / (curves[i] - x);\n    }\n\n    let n = i + 18\n    /*BEZIER_SIZE*/\n    ;\n\n    for (i += 2; i < n; i += 2) {\n      if (curves[i] >= time) {\n        let x = curves[i - 2],\n            y = curves[i - 1];\n        return y + (time - x) / (curves[i] - x) * (curves[i + 1] - y);\n      }\n    }\n\n    let x = curves[n - 2],\n        y = curves[n - 1];\n    return y + (1 - y) * (time - x) / (this.frames[frame + this.getFrameEntries()] - x);\n  }\n\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    let slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n    let slotAttachment = slot.getAttachment();\n    if (!(slotAttachment instanceof VertexAttachment) || slotAttachment.deformAttachment != this.attachment) return;\n    let deform = slot.deform;\n    if (deform.length == 0) blend = MixBlend.setup;\n    let vertices = this.vertices;\n    let vertexCount = vertices[0].length;\n    let frames = this.frames;\n\n    if (time < frames[0]) {\n      let vertexAttachment = slotAttachment;\n\n      switch (blend) {\n        case MixBlend.setup:\n          deform.length = 0;\n          return;\n\n        case MixBlend.first:\n          if (alpha == 1) {\n            deform.length = 0;\n            return;\n          }\n\n          deform.length = vertexCount;\n\n          if (!vertexAttachment.bones) {\n            // Unweighted vertex positions.\n            let setupVertices = vertexAttachment.vertices;\n\n            for (var i = 0; i < vertexCount; i++) deform[i] += (setupVertices[i] - deform[i]) * alpha;\n          } else {\n            // Weighted deform offsets.\n            alpha = 1 - alpha;\n\n            for (var i = 0; i < vertexCount; i++) deform[i] *= alpha;\n          }\n\n      }\n\n      return;\n    }\n\n    deform.length = vertexCount;\n\n    if (time >= frames[frames.length - 1]) {\n      // Time is after last frame.\n      let lastVertices = vertices[frames.length - 1];\n\n      if (alpha == 1) {\n        if (blend == MixBlend.add) {\n          let vertexAttachment = slotAttachment;\n\n          if (!vertexAttachment.bones) {\n            // Unweighted vertex positions, with alpha.\n            let setupVertices = vertexAttachment.vertices;\n\n            for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i] - setupVertices[i];\n          } else {\n            // Weighted deform offsets, with alpha.\n            for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i];\n          }\n        } else Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\n      } else {\n        switch (blend) {\n          case MixBlend.setup:\n            {\n              let vertexAttachment = slotAttachment;\n\n              if (!vertexAttachment.bones) {\n                // Unweighted vertex positions, with alpha.\n                let setupVertices = vertexAttachment.vertices;\n\n                for (let i = 0; i < vertexCount; i++) {\n                  let setup = setupVertices[i];\n                  deform[i] = setup + (lastVertices[i] - setup) * alpha;\n                }\n              } else {\n                // Weighted deform offsets, with alpha.\n                for (let i = 0; i < vertexCount; i++) deform[i] = lastVertices[i] * alpha;\n              }\n\n              break;\n            }\n\n          case MixBlend.first:\n          case MixBlend.replace:\n            for (let i = 0; i < vertexCount; i++) deform[i] += (lastVertices[i] - deform[i]) * alpha;\n\n            break;\n\n          case MixBlend.add:\n            let vertexAttachment = slotAttachment;\n\n            if (!vertexAttachment.bones) {\n              // Unweighted vertex positions, with alpha.\n              let setupVertices = vertexAttachment.vertices;\n\n              for (let i = 0; i < vertexCount; i++) deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\n            } else {\n              // Weighted deform offsets, with alpha.\n              for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i] * alpha;\n            }\n\n        }\n      }\n\n      return;\n    } // Interpolate between the previous frame and the current frame.\n\n\n    let frame = Timeline.search1(frames, time);\n    let percent = this.getCurvePercent(time, frame);\n    let prevVertices = vertices[frame];\n    let nextVertices = vertices[frame + 1];\n\n    if (alpha == 1) {\n      if (blend == MixBlend.add) {\n        let vertexAttachment = slotAttachment;\n\n        if (!vertexAttachment.bones) {\n          // Unweighted vertex positions, with alpha.\n          let setupVertices = vertexAttachment.vertices;\n\n          for (let i = 0; i < vertexCount; i++) {\n            let prev = prevVertices[i];\n            deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\n          }\n        } else {\n          // Weighted deform offsets, with alpha.\n          for (let i = 0; i < vertexCount; i++) {\n            let prev = prevVertices[i];\n            deform[i] += prev + (nextVertices[i] - prev) * percent;\n          }\n        }\n      } else {\n        for (let i = 0; i < vertexCount; i++) {\n          let prev = prevVertices[i];\n          deform[i] = prev + (nextVertices[i] - prev) * percent;\n        }\n      }\n    } else {\n      switch (blend) {\n        case MixBlend.setup:\n          {\n            let vertexAttachment = slotAttachment;\n\n            if (!vertexAttachment.bones) {\n              // Unweighted vertex positions, with alpha.\n              let setupVertices = vertexAttachment.vertices;\n\n              for (let i = 0; i < vertexCount; i++) {\n                let prev = prevVertices[i],\n                    setup = setupVertices[i];\n                deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\n              }\n            } else {\n              // Weighted deform offsets, with alpha.\n              for (let i = 0; i < vertexCount; i++) {\n                let prev = prevVertices[i];\n                deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\n              }\n            }\n\n            break;\n          }\n\n        case MixBlend.first:\n        case MixBlend.replace:\n          for (let i = 0; i < vertexCount; i++) {\n            let prev = prevVertices[i];\n            deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\n          }\n\n          break;\n\n        case MixBlend.add:\n          let vertexAttachment = slotAttachment;\n\n          if (!vertexAttachment.bones) {\n            // Unweighted vertex positions, with alpha.\n            let setupVertices = vertexAttachment.vertices;\n\n            for (let i = 0; i < vertexCount; i++) {\n              let prev = prevVertices[i];\n              deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\n            }\n          } else {\n            // Weighted deform offsets, with alpha.\n            for (let i = 0; i < vertexCount; i++) {\n              let prev = prevVertices[i];\n              deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\n            }\n          }\n\n      }\n    }\n  }\n\n}\n/** Fires an {@link Event} when specific animation times are reached.\r\n * @public\r\n * */\n\n\nclass EventTimeline extends Timeline {\n  static __initStatic() {\n    this.propertyIds = [\"\" + Property.event];\n  }\n  /** The event for each key frame. */\n\n\n  constructor(frameCount) {\n    super(frameCount, EventTimeline.propertyIds);\n    this.events = new Array(frameCount);\n  }\n\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time in seconds and the event for the specified key frame. */\n\n\n  setFrame(frame, event) {\n    this.frames[frame] = event.time;\n    this.events[frame] = event;\n  }\n  /** Fires events for frames > `lastTime` and <= `time`. */\n\n\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    if (!firedEvents) return;\n    let frames = this.frames;\n    let frameCount = this.frames.length;\n\n    if (lastTime > time) {\n      // Fire events after last time for looped animations.\n      this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\n      lastTime = -1;\n    } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\n      return;\n\n    if (time < frames[0]) return; // Time is before first frame.\n\n    let i = 0;\n    if (lastTime < frames[0]) i = 0;else {\n      i = Timeline.search1(frames, lastTime) + 1;\n      let frameTime = frames[i];\n\n      while (i > 0) {\n        // Fire multiple events with the same frame.\n        if (frames[i - 1] != frameTime) break;\n        i--;\n      }\n    }\n\n    for (; i < frameCount && time >= frames[i]; i++) firedEvents.push(this.events[i]);\n  }\n\n}\n\nEventTimeline.__initStatic();\n/** Changes a skeleton's {@link Skeleton#drawOrder}.\r\n * @public\r\n * */\n\n\nclass DrawOrderTimeline extends Timeline {\n  static __initStatic2() {\n    this.propertyIds = [\"\" + Property.drawOrder];\n  }\n  /** The draw order for each key frame. See {@link #setFrame(int, float, int[])}. */\n\n\n  constructor(frameCount) {\n    super(frameCount, DrawOrderTimeline.propertyIds);\n    this.drawOrders = new Array(frameCount);\n  }\n\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time in seconds and the draw order for the specified key frame.\r\n   * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\r\n   *           draw order. */\n\n\n  setFrame(frame, time, drawOrder) {\n    this.frames[frame] = time;\n    this.drawOrders[frame] = drawOrder;\n  }\n\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    if (direction == MixDirection.mixOut) {\n      if (blend == MixBlend.setup) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n      return;\n    }\n\n    if (time < this.frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n      return;\n    }\n\n    let drawOrderToSetupIndex = this.drawOrders[Timeline.search1(this.frames, time)];\n    if (!drawOrderToSetupIndex) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);else {\n      let drawOrder = skeleton.drawOrder;\n      let slots = skeleton.slots;\n\n      for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++) drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n    }\n  }\n\n}\n\nDrawOrderTimeline.__initStatic2();\n/** Changes an IK constraint's {@link IkConstraint#mix}, {@link IkConstraint#softness},\r\n * {@link IkConstraint#bendDirection}, {@link IkConstraint#stretch}, and {@link IkConstraint#compress}.\r\n * @public\r\n * */\n\n\nclass IkConstraintTimeline extends CurveTimeline {\n  /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */\n  constructor(frameCount, bezierCount, ikConstraintIndex) {\n    super(frameCount, bezierCount, [Property.ikConstraint + \"|\" + ikConstraintIndex]);\n    this.ikConstraintIndex = ikConstraintIndex;\n  }\n\n  getFrameEntries() {\n    return 6\n    /*ENTRIES*/\n    ;\n  }\n  /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */\n\n\n  setFrame(frame, time, mix, softness, bendDirection, compress, stretch) {\n    frame *= 6\n    /*ENTRIES*/\n    ;\n    this.frames[frame] = time;\n    this.frames[frame + 1\n    /*MIX*/\n    ] = mix;\n    this.frames[frame + 2\n    /*SOFTNESS*/\n    ] = softness;\n    this.frames[frame + 3\n    /*BEND_DIRECTION*/\n    ] = bendDirection;\n    this.frames[frame + 4\n    /*COMPRESS*/\n    ] = compress ? 1 : 0;\n    this.frames[frame + 5\n    /*STRETCH*/\n    ] = stretch ? 1 : 0;\n  }\n\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    let constraint = skeleton.ikConstraints[this.ikConstraintIndex];\n    if (!constraint.active) return;\n    let frames = this.frames;\n\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.mix = constraint.data.mix;\n          constraint.softness = constraint.data.softness;\n          constraint.bendDirection = constraint.data.bendDirection;\n          constraint.compress = constraint.data.compress;\n          constraint.stretch = constraint.data.stretch;\n          return;\n\n        case MixBlend.first:\n          constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n          constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\n          constraint.bendDirection = constraint.data.bendDirection;\n          constraint.compress = constraint.data.compress;\n          constraint.stretch = constraint.data.stretch;\n      }\n\n      return;\n    }\n\n    let mix = 0,\n        softness = 0;\n    let i = Timeline.search(frames, time, 6\n    /*ENTRIES*/\n    );\n    let curveType = this.curves[i / 6\n    /*ENTRIES*/\n    ];\n\n    switch (curveType) {\n      case 0\n      /*LINEAR*/\n      :\n        let before = frames[i];\n        mix = frames[i + 1\n        /*MIX*/\n        ];\n        softness = frames[i + 2\n        /*SOFTNESS*/\n        ];\n        let t = (time - before) / (frames[i + 6\n        /*ENTRIES*/\n        ] - before);\n        mix += (frames[i + 6\n        /*ENTRIES*/\n        + 1\n        /*MIX*/\n        ] - mix) * t;\n        softness += (frames[i + 6\n        /*ENTRIES*/\n        + 2\n        /*SOFTNESS*/\n        ] - softness) * t;\n        break;\n\n      case 1\n      /*STEPPED*/\n      :\n        mix = frames[i + 1\n        /*MIX*/\n        ];\n        softness = frames[i + 2\n        /*SOFTNESS*/\n        ];\n        break;\n\n      default:\n        mix = this.getBezierValue(time, i, 1\n        /*MIX*/\n        , curveType - 2\n        /*BEZIER*/\n        );\n        softness = this.getBezierValue(time, i, 2\n        /*SOFTNESS*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        - 2\n        /*BEZIER*/\n        );\n    }\n\n    if (blend == MixBlend.setup) {\n      constraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;\n      constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;\n\n      if (direction == MixDirection.mixOut) {\n        constraint.bendDirection = constraint.data.bendDirection;\n        constraint.compress = constraint.data.compress;\n        constraint.stretch = constraint.data.stretch;\n      } else {\n        constraint.bendDirection = frames[i + 3\n        /*BEND_DIRECTION*/\n        ];\n        constraint.compress = frames[i + 4\n        /*COMPRESS*/\n        ] != 0;\n        constraint.stretch = frames[i + 5\n        /*STRETCH*/\n        ] != 0;\n      }\n    } else {\n      constraint.mix += (mix - constraint.mix) * alpha;\n      constraint.softness += (softness - constraint.softness) * alpha;\n\n      if (direction == MixDirection.mixIn) {\n        constraint.bendDirection = frames[i + 3\n        /*BEND_DIRECTION*/\n        ];\n        constraint.compress = frames[i + 4\n        /*COMPRESS*/\n        ] != 0;\n        constraint.stretch = frames[i + 5\n        /*STRETCH*/\n        ] != 0;\n      }\n    }\n  }\n\n}\n/** Changes a transform constraint's {@link TransformConstraint#rotateMix}, {@link TransformConstraint#translateMix},\r\n * {@link TransformConstraint#scaleMix}, and {@link TransformConstraint#shearMix}.\r\n * @public\r\n * */\n\n\nclass TransformConstraintTimeline extends CurveTimeline {\n  /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */\n  constructor(frameCount, bezierCount, transformConstraintIndex) {\n    super(frameCount, bezierCount, [Property.transformConstraint + \"|\" + transformConstraintIndex]);\n    this.transformConstraintIndex = transformConstraintIndex;\n  }\n\n  getFrameEntries() {\n    return 7\n    /*ENTRIES*/\n    ;\n  }\n  /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\n\n\n  setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY) {\n    let frames = this.frames;\n    frame *= 7\n    /*ENTRIES*/\n    ;\n    frames[frame] = time;\n    frames[frame + 1\n    /*ROTATE*/\n    ] = mixRotate;\n    frames[frame + 2\n    /*X*/\n    ] = mixX;\n    frames[frame + 3\n    /*Y*/\n    ] = mixY;\n    frames[frame + 4\n    /*SCALEX*/\n    ] = mixScaleX;\n    frames[frame + 5\n    /*SCALEY*/\n    ] = mixScaleY;\n    frames[frame + 6\n    /*SHEARY*/\n    ] = mixShearY;\n  }\n\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    let constraint = skeleton.transformConstraints[this.transformConstraintIndex];\n    if (!constraint.active) return;\n    let frames = this.frames;\n\n    if (time < frames[0]) {\n      let data = constraint.data;\n\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.mixRotate = data.mixRotate;\n          constraint.mixX = data.mixX;\n          constraint.mixY = data.mixY;\n          constraint.mixScaleX = data.mixScaleX;\n          constraint.mixScaleY = data.mixScaleY;\n          constraint.mixShearY = data.mixShearY;\n          return;\n\n        case MixBlend.first:\n          constraint.mixRotate += (data.mixRotate - constraint.mixRotate) * alpha;\n          constraint.mixX += (data.mixX - constraint.mixX) * alpha;\n          constraint.mixY += (data.mixY - constraint.mixY) * alpha;\n          constraint.mixScaleX += (data.mixScaleX - constraint.mixScaleX) * alpha;\n          constraint.mixScaleY += (data.mixScaleY - constraint.mixScaleY) * alpha;\n          constraint.mixShearY += (data.mixShearY - constraint.mixShearY) * alpha;\n      }\n\n      return;\n    }\n\n    let rotate, x, y, scaleX, scaleY, shearY;\n    let i = Timeline.search(frames, time, 7\n    /*ENTRIES*/\n    );\n    let curveType = this.curves[i / 7\n    /*ENTRIES*/\n    ];\n\n    switch (curveType) {\n      case 0\n      /*LINEAR*/\n      :\n        let before = frames[i];\n        rotate = frames[i + 1\n        /*ROTATE*/\n        ];\n        x = frames[i + 2\n        /*X*/\n        ];\n        y = frames[i + 3\n        /*Y*/\n        ];\n        scaleX = frames[i + 4\n        /*SCALEX*/\n        ];\n        scaleY = frames[i + 5\n        /*SCALEY*/\n        ];\n        shearY = frames[i + 6\n        /*SHEARY*/\n        ];\n        let t = (time - before) / (frames[i + 7\n        /*ENTRIES*/\n        ] - before);\n        rotate += (frames[i + 7\n        /*ENTRIES*/\n        + 1\n        /*ROTATE*/\n        ] - rotate) * t;\n        x += (frames[i + 7\n        /*ENTRIES*/\n        + 2\n        /*X*/\n        ] - x) * t;\n        y += (frames[i + 7\n        /*ENTRIES*/\n        + 3\n        /*Y*/\n        ] - y) * t;\n        scaleX += (frames[i + 7\n        /*ENTRIES*/\n        + 4\n        /*SCALEX*/\n        ] - scaleX) * t;\n        scaleY += (frames[i + 7\n        /*ENTRIES*/\n        + 5\n        /*SCALEY*/\n        ] - scaleY) * t;\n        shearY += (frames[i + 7\n        /*ENTRIES*/\n        + 6\n        /*SHEARY*/\n        ] - shearY) * t;\n        break;\n\n      case 1\n      /*STEPPED*/\n      :\n        rotate = frames[i + 1\n        /*ROTATE*/\n        ];\n        x = frames[i + 2\n        /*X*/\n        ];\n        y = frames[i + 3\n        /*Y*/\n        ];\n        scaleX = frames[i + 4\n        /*SCALEX*/\n        ];\n        scaleY = frames[i + 5\n        /*SCALEY*/\n        ];\n        shearY = frames[i + 6\n        /*SHEARY*/\n        ];\n        break;\n\n      default:\n        rotate = this.getBezierValue(time, i, 1\n        /*ROTATE*/\n        , curveType - 2\n        /*BEZIER*/\n        );\n        x = this.getBezierValue(time, i, 2\n        /*X*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        - 2\n        /*BEZIER*/\n        );\n        y = this.getBezierValue(time, i, 3\n        /*Y*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        * 2 - 2\n        /*BEZIER*/\n        );\n        scaleX = this.getBezierValue(time, i, 4\n        /*SCALEX*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        * 3 - 2\n        /*BEZIER*/\n        );\n        scaleY = this.getBezierValue(time, i, 5\n        /*SCALEY*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        * 4 - 2\n        /*BEZIER*/\n        );\n        shearY = this.getBezierValue(time, i, 6\n        /*SHEARY*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        * 5 - 2\n        /*BEZIER*/\n        );\n    }\n\n    if (blend == MixBlend.setup) {\n      let data = constraint.data;\n      constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\n      constraint.mixX = data.mixX + (x - data.mixX) * alpha;\n      constraint.mixY = data.mixY + (y - data.mixY) * alpha;\n      constraint.mixScaleX = data.mixScaleX + (scaleX - data.mixScaleX) * alpha;\n      constraint.mixScaleY = data.mixScaleY + (scaleY - data.mixScaleY) * alpha;\n      constraint.mixShearY = data.mixShearY + (shearY - data.mixShearY) * alpha;\n    } else {\n      constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\n      constraint.mixX += (x - constraint.mixX) * alpha;\n      constraint.mixY += (y - constraint.mixY) * alpha;\n      constraint.mixScaleX += (scaleX - constraint.mixScaleX) * alpha;\n      constraint.mixScaleY += (scaleY - constraint.mixScaleY) * alpha;\n      constraint.mixShearY += (shearY - constraint.mixShearY) * alpha;\n    }\n  }\n\n}\n/** Changes a path constraint's {@link PathConstraint#position}.\r\n * @public\r\n * */\n\n\nclass PathConstraintPositionTimeline extends CurveTimeline1 {\n  /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */\n  constructor(frameCount, bezierCount, pathConstraintIndex) {\n    super(frameCount, bezierCount, Property.pathConstraintPosition + \"|\" + pathConstraintIndex);\n    this.pathConstraintIndex = pathConstraintIndex;\n  }\n\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    let constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (!constraint.active) return;\n    let frames = this.frames;\n\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.position = constraint.data.position;\n          return;\n\n        case MixBlend.first:\n          constraint.position += (constraint.data.position - constraint.position) * alpha;\n      }\n\n      return;\n    }\n\n    let position = this.getCurveValue(time);\n    if (blend == MixBlend.setup) constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;else constraint.position += (position - constraint.position) * alpha;\n  }\n\n}\n/** Changes a path constraint's {@link PathConstraint#spacing}.\r\n * @public\r\n * */\n\n\nclass PathConstraintSpacingTimeline extends CurveTimeline1 {\n  /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\n  __init18() {\n    this.pathConstraintIndex = 0;\n  }\n\n  constructor(frameCount, bezierCount, pathConstraintIndex) {\n    super(frameCount, bezierCount, Property.pathConstraintSpacing + \"|\" + pathConstraintIndex);\n\n    PathConstraintSpacingTimeline.prototype.__init18.call(this);\n\n    this.pathConstraintIndex = pathConstraintIndex;\n  }\n\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    let constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (!constraint.active) return;\n    let frames = this.frames;\n\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.spacing = constraint.data.spacing;\n          return;\n\n        case MixBlend.first:\n          constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n      }\n\n      return;\n    }\n\n    let spacing = this.getCurveValue(time);\n    if (blend == MixBlend.setup) constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;else constraint.spacing += (spacing - constraint.spacing) * alpha;\n  }\n\n}\n/** Changes a transform constraint's {@link PathConstraint#getMixRotate()}, {@link PathConstraint#getMixX()}, and\r\n * {@link PathConstraint#getMixY()}.\r\n * @public\r\n * */\n\n\nclass PathConstraintMixTimeline extends CurveTimeline {\n  /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\n  __init19() {\n    this.pathConstraintIndex = 0;\n  }\n\n  constructor(frameCount, bezierCount, pathConstraintIndex) {\n    super(frameCount, bezierCount, [Property.pathConstraintMix + \"|\" + pathConstraintIndex]);\n\n    PathConstraintMixTimeline.prototype.__init19.call(this);\n\n    this.pathConstraintIndex = pathConstraintIndex;\n  }\n\n  getFrameEntries() {\n    return 4\n    /*ENTRIES*/\n    ;\n  }\n\n  setFrame(frame, time, mixRotate, mixX, mixY) {\n    let frames = this.frames;\n    frame <<= 2;\n    frames[frame] = time;\n    frames[frame + 1\n    /*ROTATE*/\n    ] = mixRotate;\n    frames[frame + 2\n    /*X*/\n    ] = mixX;\n    frames[frame + 3\n    /*Y*/\n    ] = mixY;\n  }\n\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    let constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (!constraint.active) return;\n    let frames = this.frames;\n\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.mixRotate = constraint.data.mixRotate;\n          constraint.mixX = constraint.data.mixX;\n          constraint.mixY = constraint.data.mixY;\n          return;\n\n        case MixBlend.first:\n          constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;\n          constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;\n          constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;\n      }\n\n      return;\n    }\n\n    let rotate, x, y;\n    let i = Timeline.search(frames, time, 4\n    /*ENTRIES*/\n    );\n    let curveType = this.curves[i >> 2];\n\n    switch (curveType) {\n      case 0\n      /*LINEAR*/\n      :\n        let before = frames[i];\n        rotate = frames[i + 1\n        /*ROTATE*/\n        ];\n        x = frames[i + 2\n        /*X*/\n        ];\n        y = frames[i + 3\n        /*Y*/\n        ];\n        let t = (time - before) / (frames[i + 4\n        /*ENTRIES*/\n        ] - before);\n        rotate += (frames[i + 4\n        /*ENTRIES*/\n        + 1\n        /*ROTATE*/\n        ] - rotate) * t;\n        x += (frames[i + 4\n        /*ENTRIES*/\n        + 2\n        /*X*/\n        ] - x) * t;\n        y += (frames[i + 4\n        /*ENTRIES*/\n        + 3\n        /*Y*/\n        ] - y) * t;\n        break;\n\n      case 1\n      /*STEPPED*/\n      :\n        rotate = frames[i + 1\n        /*ROTATE*/\n        ];\n        x = frames[i + 2\n        /*X*/\n        ];\n        y = frames[i + 3\n        /*Y*/\n        ];\n        break;\n\n      default:\n        rotate = this.getBezierValue(time, i, 1\n        /*ROTATE*/\n        , curveType - 2\n        /*BEZIER*/\n        );\n        x = this.getBezierValue(time, i, 2\n        /*X*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        - 2\n        /*BEZIER*/\n        );\n        y = this.getBezierValue(time, i, 3\n        /*Y*/\n        , curveType + 18\n        /*BEZIER_SIZE*/\n        * 2 - 2\n        /*BEZIER*/\n        );\n    }\n\n    if (blend == MixBlend.setup) {\n      let data = constraint.data;\n      constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\n      constraint.mixX = data.mixX + (x - data.mixX) * alpha;\n      constraint.mixY = data.mixY + (y - data.mixY) * alpha;\n    } else {\n      constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\n      constraint.mixX += (x - constraint.mixX) * alpha;\n      constraint.mixY += (y - constraint.mixY) * alpha;\n    }\n  }\n\n}\n/** Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies\r\n * multiple animations on top of each other (layering).\r\n *\r\n * See [Applying Animations](http://esotericsoftware.com/spine-applying-animations/) in the Spine Runtimes Guide.\r\n * @public\r\n * */\n\n\nclass AnimationState {\n  static emptyAnimation() {\n    if (!_emptyAnimation) _emptyAnimation = new Animation(\"<empty>\", [], 0);\n    return _emptyAnimation;\n  }\n  /** The AnimationStateData to look up mix durations. */\n\n  /** The list of tracks that currently have animations, which may contain null entries. */\n\n\n  __init() {\n    this.tracks = new Array();\n  }\n  /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\r\n   * or faster. Defaults to 1.\r\n   *\r\n   * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\n\n\n  __init2() {\n    this.timeScale = 1;\n  }\n\n  __init3() {\n    this.unkeyedState = 0;\n  }\n\n  __init4() {\n    this.events = new Array();\n  }\n\n  __init5() {\n    this.listeners = new Array();\n  }\n\n  __init6() {\n    this.queue = new EventQueue(this);\n  }\n\n  __init7() {\n    this.propertyIDs = new StringSet();\n  }\n\n  __init8() {\n    this.animationsChanged = false;\n  }\n\n  __init9() {\n    this.trackEntryPool = new Pool(() => new TrackEntry());\n  }\n\n  constructor(data) {\n    AnimationState.prototype.__init.call(this);\n\n    AnimationState.prototype.__init2.call(this);\n\n    AnimationState.prototype.__init3.call(this);\n\n    AnimationState.prototype.__init4.call(this);\n\n    AnimationState.prototype.__init5.call(this);\n\n    AnimationState.prototype.__init6.call(this);\n\n    AnimationState.prototype.__init7.call(this);\n\n    AnimationState.prototype.__init8.call(this);\n\n    AnimationState.prototype.__init9.call(this);\n\n    this.data = data;\n  }\n  /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\n\n\n  update(delta) {\n    delta *= this.timeScale;\n    let tracks = this.tracks;\n\n    for (let i = 0, n = tracks.length; i < n; i++) {\n      let current = tracks[i];\n      if (!current) continue;\n      current.animationLast = current.nextAnimationLast;\n      current.trackLast = current.nextTrackLast;\n      let currentDelta = delta * current.timeScale;\n\n      if (current.delay > 0) {\n        current.delay -= currentDelta;\n        if (current.delay > 0) continue;\n        currentDelta = -current.delay;\n        current.delay = 0;\n      }\n\n      let next = current.next;\n\n      if (next) {\n        // When the next entry's delay is passed, change to the next entry, preserving leftover time.\n        let nextTime = current.trackLast - next.delay;\n\n        if (nextTime >= 0) {\n          next.delay = 0;\n          next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n          current.trackTime += currentDelta;\n          this.setCurrent(i, next, true);\n\n          while (next.mixingFrom) {\n            next.mixTime += delta;\n            next = next.mixingFrom;\n          }\n\n          continue;\n        }\n      } else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {\n        tracks[i] = null;\n        this.queue.end(current);\n        this.clearNext(current);\n        continue;\n      }\n\n      if (current.mixingFrom && this.updateMixingFrom(current, delta)) {\n        // End mixing from entries once all have completed.\n        let from = current.mixingFrom;\n        current.mixingFrom = null;\n        if (from) from.mixingTo = null;\n\n        while (from) {\n          this.queue.end(from);\n          from = from.mixingFrom;\n        }\n      }\n\n      current.trackTime += currentDelta;\n    }\n\n    this.queue.drain();\n  }\n  /** Returns true when all mixing from entries are complete. */\n\n\n  updateMixingFrom(to, delta) {\n    let from = to.mixingFrom;\n    if (!from) return true;\n    let finished = this.updateMixingFrom(from, delta);\n    from.animationLast = from.nextAnimationLast;\n    from.trackLast = from.nextTrackLast; // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\n\n    if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\n      // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).\n      if (from.totalAlpha == 0 || to.mixDuration == 0) {\n        to.mixingFrom = from.mixingFrom;\n        if (from.mixingFrom) from.mixingFrom.mixingTo = to;\n        to.interruptAlpha = from.interruptAlpha;\n        this.queue.end(from);\n      }\n\n      return finished;\n    }\n\n    from.trackTime += delta * from.timeScale;\n    to.mixTime += delta;\n    return false;\n  }\n  /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\r\n   * animation state can be applied to multiple skeletons to pose them identically.\r\n   * @returns True if any animations were applied. */\n\n\n  apply(skeleton) {\n    if (!skeleton) throw new Error(\"skeleton cannot be null.\");\n    if (this.animationsChanged) this._animationsChanged();\n    let events = this.events;\n    let tracks = this.tracks;\n    let applied = false;\n\n    for (let i = 0, n = tracks.length; i < n; i++) {\n      let current = tracks[i];\n      if (!current || current.delay > 0) continue;\n      applied = true;\n      let blend = i == 0 ? MixBlend.first : current.mixBlend; // Apply mixing from entries first.\n\n      let mix = current.alpha;\n      if (current.mixingFrom) mix *= this.applyMixingFrom(current, skeleton, blend);else if (current.trackTime >= current.trackEnd && !current.next) mix = 0; // Apply current entry.\n\n      let animationLast = current.animationLast,\n          animationTime = current.getAnimationTime(),\n          applyTime = animationTime;\n      let applyEvents = events;\n\n      if (current.reverse) {\n        applyTime = current.animation.duration - applyTime;\n        applyEvents = null;\n      }\n\n      let timelines = current.animation.timelines;\n      let timelineCount = timelines.length;\n\n      if (i == 0 && mix == 1 || blend == MixBlend.add) {\n        for (let ii = 0; ii < timelineCount; ii++) {\n          // Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\n          // to sometimes stop rendering when using color correction, as their RGBA values become NaN.\n          // (https://github.com/pixijs/pixi-spine/issues/302)\n          Utils.webkit602BugfixHelper(mix, blend);\n          var timeline = timelines[ii];\n          if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);else timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, blend, MixDirection.mixIn);\n        }\n      } else {\n        let timelineMode = current.timelineMode;\n        let firstFrame = current.timelinesRotation.length != timelineCount << 1;\n        if (firstFrame) current.timelinesRotation.length = timelineCount << 1;\n\n        for (let ii = 0; ii < timelineCount; ii++) {\n          let timeline = timelines[ii];\n          let timelineBlend = timelineMode[ii] == SUBSEQUENT ? blend : MixBlend.setup;\n\n          if (timeline instanceof RotateTimeline) {\n            this.applyRotateTimeline(timeline, skeleton, applyTime, mix, timelineBlend, current.timelinesRotation, ii << 1, firstFrame);\n          } else if (timeline instanceof AttachmentTimeline) {\n            this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\n          } else {\n            // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n            Utils.webkit602BugfixHelper(mix, blend);\n            timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, timelineBlend, MixDirection.mixIn);\n          }\n        }\n      }\n\n      this.queueEvents(current, animationTime);\n      events.length = 0;\n      current.nextAnimationLast = animationTime;\n      current.nextTrackLast = current.trackTime;\n    } // Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so\n    // subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or\n    // the time is before the first key).\n\n\n    var setupState = this.unkeyedState + SETUP;\n    var slots = skeleton.slots;\n\n    for (var i = 0, n = skeleton.slots.length; i < n; i++) {\n      var slot = slots[i];\n\n      if (slot.attachmentState == setupState) {\n        var attachmentName = slot.data.attachmentName;\n        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n      }\n    }\n\n    this.unkeyedState += 2; // Increasing after each use avoids the need to reset attachmentState for every slot.\n\n    this.queue.drain();\n    return applied;\n  }\n\n  applyMixingFrom(to, skeleton, blend) {\n    let from = to.mixingFrom;\n    if (from.mixingFrom) this.applyMixingFrom(from, skeleton, blend);\n    let mix = 0;\n\n    if (to.mixDuration == 0) {\n      // Single frame mix to undo mixingFrom changes.\n      mix = 1;\n      if (blend == MixBlend.first) blend = MixBlend.setup;\n    } else {\n      mix = to.mixTime / to.mixDuration;\n      if (mix > 1) mix = 1;\n      if (blend != MixBlend.first) blend = from.mixBlend;\n    }\n\n    let attachments = mix < from.attachmentThreshold,\n        drawOrder = mix < from.drawOrderThreshold;\n    let timelines = from.animation.timelines;\n    let timelineCount = timelines.length;\n    let alphaHold = from.alpha * to.interruptAlpha,\n        alphaMix = alphaHold * (1 - mix);\n    let animationLast = from.animationLast,\n        animationTime = from.getAnimationTime(),\n        applyTime = animationTime;\n    let events = null;\n    if (from.reverse) applyTime = from.animation.duration - applyTime;else if (mix < from.eventThreshold) events = this.events;\n\n    if (blend == MixBlend.add) {\n      for (let i = 0; i < timelineCount; i++) timelines[i].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, MixDirection.mixOut);\n    } else {\n      let timelineMode = from.timelineMode;\n      let timelineHoldMix = from.timelineHoldMix;\n      let firstFrame = from.timelinesRotation.length != timelineCount << 1;\n      if (firstFrame) from.timelinesRotation.length = timelineCount << 1;\n      from.totalAlpha = 0;\n\n      for (let i = 0; i < timelineCount; i++) {\n        let timeline = timelines[i];\n        let direction = MixDirection.mixOut;\n        let timelineBlend;\n        let alpha = 0;\n\n        switch (timelineMode[i]) {\n          case SUBSEQUENT:\n            if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\n            timelineBlend = blend;\n            alpha = alphaMix;\n            break;\n\n          case FIRST:\n            timelineBlend = MixBlend.setup;\n            alpha = alphaMix;\n            break;\n\n          case HOLD_SUBSEQUENT:\n            timelineBlend = blend;\n            alpha = alphaHold;\n            break;\n\n          case HOLD_FIRST:\n            timelineBlend = MixBlend.setup;\n            alpha = alphaHold;\n            break;\n\n          default:\n            timelineBlend = MixBlend.setup;\n            let holdMix = timelineHoldMix[i];\n            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n            break;\n        }\n\n        from.totalAlpha += alpha;\n        if (timeline instanceof RotateTimeline) this.applyRotateTimeline(timeline, skeleton, applyTime, alpha, timelineBlend, from.timelinesRotation, i << 1, firstFrame);else if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, applyTime, timelineBlend, attachments);else {\n          // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n          Utils.webkit602BugfixHelper(alpha, blend);\n          if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup) direction = MixDirection.mixIn;\n          timeline.apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);\n        }\n      }\n    }\n\n    if (to.mixDuration > 0) this.queueEvents(from, animationTime);\n    this.events.length = 0;\n    from.nextAnimationLast = animationTime;\n    from.nextTrackLast = from.trackTime;\n    return mix;\n  }\n\n  applyAttachmentTimeline(timeline, skeleton, time, blend, attachments) {\n    var slot = skeleton.slots[timeline.slotIndex];\n    if (!slot.bone.active) return;\n\n    if (time < timeline.frames[0]) {\n      // Time is before first frame.\n      if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\n    } else this.setAttachment(skeleton, slot, timeline.attachmentNames[Timeline.search1(timeline.frames, time)], attachments); // If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.\n\n\n    if (slot.attachmentState <= this.unkeyedState) slot.attachmentState = this.unkeyedState + SETUP;\n  }\n\n  setAttachment(skeleton, slot, attachmentName, attachments) {\n    slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n    if (attachments) slot.attachmentState = this.unkeyedState + CURRENT;\n  }\n\n  applyRotateTimeline(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {\n    if (firstFrame) timelinesRotation[i] = 0;\n\n    if (alpha == 1) {\n      timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\n      return;\n    }\n\n    let bone = skeleton.bones[timeline.boneIndex];\n    if (!bone.active) return;\n    let frames = timeline.frames;\n    let r1 = 0,\n        r2 = 0;\n\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.rotation = bone.data.rotation;\n\n        default:\n          return;\n\n        case MixBlend.first:\n          r1 = bone.rotation;\n          r2 = bone.data.rotation;\n      }\n    } else {\n      r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\n      r2 = bone.data.rotation + timeline.getCurveValue(time);\n    } // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\n\n\n    let total = 0,\n        diff = r2 - r1;\n    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;\n\n    if (diff == 0) {\n      total = timelinesRotation[i];\n    } else {\n      let lastTotal = 0,\n          lastDiff = 0;\n\n      if (firstFrame) {\n        lastTotal = 0;\n        lastDiff = diff;\n      } else {\n        lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\n\n        lastDiff = timelinesRotation[i + 1]; // Difference between bones.\n      }\n\n      let current = diff > 0,\n          dir = lastTotal >= 0; // Detect cross at 0 (not 180).\n\n      if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n        // A cross after a 360 rotation is a loop.\n        if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\n        dir = current;\n      }\n\n      total = diff + lastTotal - lastTotal % 360; // Store loops as part of lastTotal.\n\n      if (dir != current) total += 360 * MathUtils.signum(lastTotal);\n      timelinesRotation[i] = total;\n    }\n\n    timelinesRotation[i + 1] = diff;\n    bone.rotation = r1 + total * alpha;\n  }\n\n  queueEvents(entry, animationTime) {\n    let animationStart = entry.animationStart,\n        animationEnd = entry.animationEnd;\n    let duration = animationEnd - animationStart;\n    let trackLastWrapped = entry.trackLast % duration; // Queue events before complete.\n\n    let events = this.events;\n    let i = 0,\n        n = events.length;\n\n    for (; i < n; i++) {\n      let event = events[i];\n      if (event.time < trackLastWrapped) break;\n      if (event.time > animationEnd) continue; // Discard events outside animation start/end.\n\n      this.queue.event(entry, event);\n    } // Queue complete if completed a loop iteration or the animation.\n\n\n    let complete = false;\n    if (entry.loop) complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;else complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n    if (complete) this.queue.complete(entry); // Queue events after complete.\n\n    for (; i < n; i++) {\n      let event = events[i];\n      if (event.time < animationStart) continue; // Discard events outside animation start/end.\n\n      this.queue.event(entry, event);\n    }\n  }\n  /** Removes all animations from all tracks, leaving skeletons in their current pose.\r\n   *\r\n   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\r\n   * rather than leaving them in their current pose. */\n\n\n  clearTracks() {\n    let oldDrainDisabled = this.queue.drainDisabled;\n    this.queue.drainDisabled = true;\n\n    for (let i = 0, n = this.tracks.length; i < n; i++) this.clearTrack(i);\n\n    this.tracks.length = 0;\n    this.queue.drainDisabled = oldDrainDisabled;\n    this.queue.drain();\n  }\n  /** Removes all animations from the track, leaving skeletons in their current pose.\r\n   *\r\n   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\r\n   * rather than leaving them in their current pose. */\n\n\n  clearTrack(trackIndex) {\n    if (trackIndex >= this.tracks.length) return;\n    let current = this.tracks[trackIndex];\n    if (!current) return;\n    this.queue.end(current);\n    this.clearNext(current);\n    let entry = current;\n\n    while (true) {\n      let from = entry.mixingFrom;\n      if (!from) break;\n      this.queue.end(from);\n      entry.mixingFrom = null;\n      entry.mixingTo = null;\n      entry = from;\n    }\n\n    this.tracks[current.trackIndex] = null;\n    this.queue.drain();\n  }\n\n  setCurrent(index, current, interrupt) {\n    let from = this.expandToIndex(index);\n    this.tracks[index] = current;\n    current.previous = null;\n\n    if (from) {\n      if (interrupt) this.queue.interrupt(from);\n      current.mixingFrom = from;\n      from.mixingTo = current;\n      current.mixTime = 0; // Store the interrupted mix percentage.\n\n      if (from.mixingFrom && from.mixDuration > 0) current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n      from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\n    }\n\n    this.queue.start(current);\n  }\n  /** Sets an animation by name.\r\n   *\r\n   * See {@link #setAnimationWith()}. */\n\n\n  setAnimation(trackIndex, animationName, loop = false) {\n    let animation = this.data.skeletonData.findAnimation(animationName);\n    if (!animation) throw new Error(\"Animation not found: \" + animationName);\n    return this.setAnimationWith(trackIndex, animation, loop);\n  }\n  /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\r\n   * applied to a skeleton, it is replaced (not mixed from).\r\n   * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\r\n   *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\r\n   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n   *         after the {@link AnimationStateListener#dispose()} event occurs. */\n\n\n  setAnimationWith(trackIndex, animation, loop = false) {\n    if (!animation) throw new Error(\"animation cannot be null.\");\n    let interrupt = true;\n    let current = this.expandToIndex(trackIndex);\n\n    if (current) {\n      if (current.nextTrackLast == -1) {\n        // Don't mix from an entry that was never applied.\n        this.tracks[trackIndex] = current.mixingFrom;\n        this.queue.interrupt(current);\n        this.queue.end(current);\n        this.clearNext(current);\n        current = current.mixingFrom;\n        interrupt = false;\n      } else this.clearNext(current);\n    }\n\n    let entry = this.trackEntry(trackIndex, animation, loop, current);\n    this.setCurrent(trackIndex, entry, interrupt);\n    this.queue.drain();\n    return entry;\n  }\n  /** Queues an animation by name.\r\n   *\r\n   * See {@link #addAnimationWith()}. */\n\n\n  addAnimation(trackIndex, animationName, loop = false, delay = 0) {\n    let animation = this.data.skeletonData.findAnimation(animationName);\n    if (!animation) throw new Error(\"Animation not found: \" + animationName);\n    return this.addAnimationWith(trackIndex, animation, loop, delay);\n  }\n  /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\r\n   * equivalent to calling {@link #setAnimationWith()}.\r\n   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\r\n   *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\r\n   *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\r\n   *           previous entry is looping, its next loop completion is used instead of its duration.\r\n   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n   *         after the {@link AnimationStateListener#dispose()} event occurs. */\n\n\n  addAnimationWith(trackIndex, animation, loop = false, delay = 0) {\n    if (!animation) throw new Error(\"animation cannot be null.\");\n    let last = this.expandToIndex(trackIndex);\n\n    if (last) {\n      while (last.next) last = last.next;\n    }\n\n    let entry = this.trackEntry(trackIndex, animation, loop, last);\n\n    if (!last) {\n      this.setCurrent(trackIndex, entry, true);\n      this.queue.drain();\n    } else {\n      last.next = entry;\n      entry.previous = last;\n      if (delay <= 0) delay += last.getTrackComplete() - entry.mixDuration;\n    }\n\n    entry.delay = delay;\n    return entry;\n  }\n  /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\r\n   * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\r\n   *\r\n   * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\r\n   * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\r\n   * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\r\n   * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\r\n   * 0 still mixes out over one frame.\r\n   *\r\n   * Mixing in is done by first setting an empty animation, then adding an animation using\r\n   * {@link #addAnimation()} and on the returned track entry, set the\r\n   * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\r\n   * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\r\n   * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\n\n\n  setEmptyAnimation(trackIndex, mixDuration = 0) {\n    let entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation(), false);\n    entry.mixDuration = mixDuration;\n    entry.trackEnd = mixDuration;\n    return entry;\n  }\n  /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\r\n   * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\r\n   * {@link #setEmptyAnimation()}.\r\n   *\r\n   * See {@link #setEmptyAnimation()}.\r\n   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\r\n   *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\r\n   *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\r\n   *           loop completion is used instead of its duration.\r\n   * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n   *         after the {@link AnimationStateListener#dispose()} event occurs. */\n\n\n  addEmptyAnimation(trackIndex, mixDuration = 0, delay = 0) {\n    let entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation(), false, delay <= 0 ? 1 : delay);\n    entry.mixDuration = mixDuration;\n    entry.trackEnd = mixDuration;\n    if (delay <= 0 && entry.previous) entry.delay = entry.previous.getTrackComplete() - entry.mixDuration + delay;\n    return entry;\n  }\n  /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\r\n   * duration. */\n\n\n  setEmptyAnimations(mixDuration = 0) {\n    let oldDrainDisabled = this.queue.drainDisabled;\n    this.queue.drainDisabled = true;\n\n    for (let i = 0, n = this.tracks.length; i < n; i++) {\n      let current = this.tracks[i];\n      if (current) this.setEmptyAnimation(current.trackIndex, mixDuration);\n    }\n\n    this.queue.drainDisabled = oldDrainDisabled;\n    this.queue.drain();\n  }\n\n  expandToIndex(index) {\n    if (index < this.tracks.length) return this.tracks[index];\n    Utils.ensureArrayCapacity(this.tracks, index + 1, null);\n    this.tracks.length = index + 1;\n    return null;\n  }\n  /** @param last May be null. */\n\n\n  trackEntry(trackIndex, animation, loop, last) {\n    let entry = this.trackEntryPool.obtain();\n    entry.trackIndex = trackIndex;\n    entry.animation = animation;\n    entry.loop = loop;\n    entry.holdPrevious = false;\n    entry.eventThreshold = 0;\n    entry.attachmentThreshold = 0;\n    entry.drawOrderThreshold = 0;\n    entry.animationStart = 0;\n    entry.animationEnd = animation.duration;\n    entry.animationLast = -1;\n    entry.nextAnimationLast = -1;\n    entry.delay = 0;\n    entry.trackTime = 0;\n    entry.trackLast = -1;\n    entry.nextTrackLast = -1;\n    entry.trackEnd = Number.MAX_VALUE;\n    entry.timeScale = 1;\n    entry.alpha = 1;\n    entry.interruptAlpha = 1;\n    entry.mixTime = 0;\n    entry.mixDuration = !last ? 0 : this.data.getMix(last.animation, animation);\n    entry.mixBlend = MixBlend.replace;\n    return entry;\n  }\n  /** Removes the {@link TrackEntry#getNext() next entry} and all entries after it for the specified entry. */\n\n\n  clearNext(entry) {\n    let next = entry.next;\n\n    while (next) {\n      this.queue.dispose(next);\n      next = next.next;\n    }\n\n    entry.next = null;\n  }\n\n  _animationsChanged() {\n    this.animationsChanged = false;\n    this.propertyIDs.clear();\n    let tracks = this.tracks;\n\n    for (let i = 0, n = tracks.length; i < n; i++) {\n      let entry = tracks[i];\n      if (!entry) continue;\n\n      while (entry.mixingFrom) entry = entry.mixingFrom;\n\n      do {\n        if (!entry.mixingTo || entry.mixBlend != MixBlend.add) this.computeHold(entry);\n        entry = entry.mixingTo;\n      } while (entry);\n    }\n  }\n\n  computeHold(entry) {\n    let to = entry.mixingTo;\n    let timelines = entry.animation.timelines;\n    let timelinesCount = entry.animation.timelines.length;\n    let timelineMode = entry.timelineMode;\n    timelineMode.length = timelinesCount;\n    let timelineHoldMix = entry.timelineHoldMix;\n    timelineHoldMix.length = 0;\n    let propertyIDs = this.propertyIDs;\n\n    if (to && to.holdPrevious) {\n      for (let i = 0; i < timelinesCount; i++) timelineMode[i] = propertyIDs.addAll(timelines[i].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;\n\n      return;\n    }\n\n    outer: for (let i = 0; i < timelinesCount; i++) {\n      let timeline = timelines[i];\n      let ids = timeline.getPropertyIds();\n      if (!propertyIDs.addAll(ids)) timelineMode[i] = SUBSEQUENT;else if (!to || timeline instanceof AttachmentTimeline || timeline instanceof DrawOrderTimeline || timeline instanceof EventTimeline || !to.animation.hasTimeline(ids)) {\n        timelineMode[i] = FIRST;\n      } else {\n        for (let next = to.mixingTo; next; next = next.mixingTo) {\n          if (next.animation.hasTimeline(ids)) continue;\n\n          if (entry.mixDuration > 0) {\n            timelineMode[i] = HOLD_MIX;\n            timelineHoldMix[i] = next;\n            continue outer;\n          }\n\n          break;\n        }\n\n        timelineMode[i] = HOLD_FIRST;\n      }\n    }\n  }\n  /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\n\n\n  getCurrent(trackIndex) {\n    if (trackIndex >= this.tracks.length) return null;\n    return this.tracks[trackIndex];\n  }\n  /** Adds a listener to receive events for all track entries. */\n\n\n  addListener(listener) {\n    if (!listener) throw new Error(\"listener cannot be null.\");\n    this.listeners.push(listener);\n  }\n  /** Removes the listener added with {@link #addListener()}. */\n\n\n  removeListener(listener) {\n    let index = this.listeners.indexOf(listener);\n    if (index >= 0) this.listeners.splice(index, 1);\n  }\n  /** Removes all listeners added with {@link #addListener()}. */\n\n\n  clearListeners() {\n    this.listeners.length = 0;\n  }\n  /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\r\n   * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\r\n   * are not wanted because new animations are being set. */\n\n\n  clearListenerNotifications() {\n    this.queue.clear();\n  } //deprecated stuff\n\n\n  static __initStatic() {\n    this.deprecatedWarning1 = false;\n  }\n\n  setAnimationByName(trackIndex, animationName, loop) {\n    if (!AnimationState.deprecatedWarning1) {\n      AnimationState.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\n    }\n\n    this.setAnimation(trackIndex, animationName, loop);\n  }\n\n  static __initStatic2() {\n    this.deprecatedWarning2 = false;\n  }\n\n  addAnimationByName(trackIndex, animationName, loop, delay) {\n    if (!AnimationState.deprecatedWarning2) {\n      AnimationState.deprecatedWarning2 = true;\n      console.warn(\"Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\n    }\n\n    this.addAnimation(trackIndex, animationName, loop, delay);\n  }\n\n  static __initStatic3() {\n    this.deprecatedWarning3 = false;\n  }\n\n  hasAnimation(animationName) {\n    let animation = this.data.skeletonData.findAnimation(animationName);\n    return animation !== null;\n  }\n\n  hasAnimationByName(animationName) {\n    if (!AnimationState.deprecatedWarning3) {\n      AnimationState.deprecatedWarning3 = true;\n      console.warn(\"Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\n    }\n\n    return this.hasAnimation(animationName);\n  }\n\n}\n\nAnimationState.__initStatic();\n\nAnimationState.__initStatic2();\n\nAnimationState.__initStatic3();\n/** Stores settings and other state for the playback of an animation on an {@link AnimationState} track.\r\n *\r\n * References to a track entry must not be kept after the {@link AnimationStateListener#dispose()} event occurs.\r\n * @public\r\n * */\n\n\nclass TrackEntry {\n  constructor() {\n    TrackEntry.prototype.__init10.call(this);\n\n    TrackEntry.prototype.__init11.call(this);\n\n    TrackEntry.prototype.__init12.call(this);\n\n    TrackEntry.prototype.__init13.call(this);\n  }\n  /** The animation to apply for this track entry. */\n\n  /** The animation queued to start after this animation, or null. `next` makes up a linked list. */\n\n  /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no\r\n   * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */\n\n  /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is\r\n   * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */\n\n  /** The listener for events generated by this track entry, or null.\r\n   *\r\n   * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation\r\n   * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */\n\n  /** The index of the track where this track entry is either current or queued.\r\n   *\r\n   * See {@link AnimationState#getCurrent()}. */\n\n  /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\r\n   * duration. */\n\n  /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead\r\n   * of being mixed out.\r\n   *\r\n   * When mixing between animations that key the same property, if a lower track also keys that property then the value will\r\n   * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%\r\n   * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation\r\n   * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which\r\n   * keys the property, only when a higher track also keys the property.\r\n   *\r\n   * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the\r\n   * previous animation. */\n\n  /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\r\n   * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event\r\n   * timelines are not applied while this animation is being mixed out. */\n\n  /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the\r\n   * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to\r\n   * 0, so attachment timelines are not applied while this animation is being mixed out. */\n\n  /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\r\n   * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,\r\n   * so draw order timelines are not applied while this animation is being mixed out. */\n\n  /** Seconds when this animation starts, both initially and after looping. Defaults to 0.\r\n   *\r\n   * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same\r\n   * value to prevent timeline keys before the start time from triggering. */\n\n  /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will\r\n   * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */\n\n  /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this\r\n   * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and\r\n   * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation\r\n   * is applied. */\n\n  /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`\r\n   * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from\r\n   * the start of the previous animation to when this track entry will become the current track entry (ie when the previous\r\n   * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).\r\n   *\r\n   * {@link #timeScale} affects the delay. */\n\n  /** Current time in seconds this track entry has been the current track entry. The track time determines\r\n   * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting\r\n   * looping. */\n\n  /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float\r\n   * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time\r\n   * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the\r\n   * properties keyed by the animation are set to the setup pose and the track is cleared.\r\n   *\r\n   * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation\r\n   * abruptly cease being applied. */\n\n  /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or\r\n   * faster. Defaults to 1.\r\n   *\r\n   * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to\r\n   * match the animation speed.\r\n   *\r\n   * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\r\n   * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If\r\n   * the time scale is not 1, the delay may need to be adjusted.\r\n   *\r\n   * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */\n\n  /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults\r\n   * to 1, which overwrites the skeleton's current pose with this animation.\r\n   *\r\n   * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to\r\n   * use alpha on track 0 if the skeleton pose is from the last frame render. */\n\n  /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be\r\n   * slightly more than `mixDuration` when the mix is complete. */\n\n  /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData\r\n   * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).\r\n   *\r\n   * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the\r\n   * properties it was animating.\r\n   *\r\n   * The `mixDuration` can be set manually rather than use the value from\r\n   * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new\r\n   * track entry only before {@link AnimationState#update(float)} is first called.\r\n   *\r\n   * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\r\n   * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set\r\n   * afterward. */\n\n  /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\r\n   * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\r\n   * the values from the lower tracks.\r\n   *\r\n   * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\r\n   * called. */\n\n\n  __init10() {\n    this.mixBlend = MixBlend.replace;\n  }\n\n  __init11() {\n    this.timelineMode = new Array();\n  }\n\n  __init12() {\n    this.timelineHoldMix = new Array();\n  }\n\n  __init13() {\n    this.timelinesRotation = new Array();\n  }\n\n  reset() {\n    this.previous = null;\n    this.next = null;\n    this.mixingFrom = null;\n    this.mixingTo = null;\n    this.animation = null;\n    this.listener = null;\n    this.timelineMode.length = 0;\n    this.timelineHoldMix.length = 0;\n    this.timelinesRotation.length = 0;\n  }\n  /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\r\n   * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\r\n   * `animationStart` time. */\n\n\n  getAnimationTime() {\n    if (this.loop) {\n      let duration = this.animationEnd - this.animationStart;\n      if (duration == 0) return this.animationStart;\n      return this.trackTime % duration + this.animationStart;\n    }\n\n    return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n  }\n\n  setAnimationLast(animationLast) {\n    this.animationLast = animationLast;\n    this.nextAnimationLast = animationLast;\n  }\n  /** Returns true if at least one loop has been completed.\r\n   *\r\n   * See {@link AnimationStateListener#complete()}. */\n\n\n  isComplete() {\n    return this.trackTime >= this.animationEnd - this.animationStart;\n  }\n  /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\r\n   * long way around when using {@link #alpha} and starting animations on other tracks.\r\n   *\r\n   * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\r\n   * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\r\n   * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\r\n   * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\n\n\n  resetRotationDirections() {\n    this.timelinesRotation.length = 0;\n  }\n\n  getTrackComplete() {\n    let duration = this.animationEnd - this.animationStart;\n\n    if (duration != 0) {\n      if (this.loop) return duration * (1 + (this.trackTime / duration | 0)); // Completion of next loop.\n\n      if (this.trackTime < duration) return duration; // Before duration.\n    }\n\n    return this.trackTime; // Next update.\n  } //deprecated stuff\n\n\n  static __initStatic4() {\n    this.deprecatedWarning1 = false;\n  }\n\n  static __initStatic5() {\n    this.deprecatedWarning2 = false;\n  }\n\n  get time() {\n    if (!TrackEntry.deprecatedWarning1) {\n      TrackEntry.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n    }\n\n    return this.trackTime;\n  }\n\n  set time(value) {\n    if (!TrackEntry.deprecatedWarning1) {\n      TrackEntry.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n    }\n\n    this.trackTime = value;\n  }\n\n  get endTime() {\n    if (!TrackEntry.deprecatedWarning2) {\n      TrackEntry.deprecatedWarning2 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n    }\n\n    return this.trackTime;\n  }\n\n  set endTime(value) {\n    if (!TrackEntry.deprecatedWarning2) {\n      TrackEntry.deprecatedWarning2 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n    }\n\n    this.trackTime = value;\n  }\n\n  loopsCount() {\n    return Math.floor(this.trackTime / this.trackEnd);\n  }\n\n}\n\nTrackEntry.__initStatic4();\n\nTrackEntry.__initStatic5();\n/**\r\n * @public\r\n */\n\n\nclass EventQueue {\n  __init14() {\n    this.objects = [];\n  }\n\n  __init15() {\n    this.drainDisabled = false;\n  }\n\n  constructor(animState) {\n    EventQueue.prototype.__init14.call(this);\n\n    EventQueue.prototype.__init15.call(this);\n\n    this.animState = animState;\n  }\n\n  start(entry) {\n    this.objects.push(EventType.start);\n    this.objects.push(entry);\n    this.animState.animationsChanged = true;\n  }\n\n  interrupt(entry) {\n    this.objects.push(EventType.interrupt);\n    this.objects.push(entry);\n  }\n\n  end(entry) {\n    this.objects.push(EventType.end);\n    this.objects.push(entry);\n    this.animState.animationsChanged = true;\n  }\n\n  dispose(entry) {\n    this.objects.push(EventType.dispose);\n    this.objects.push(entry);\n  }\n\n  complete(entry) {\n    this.objects.push(EventType.complete);\n    this.objects.push(entry);\n  }\n\n  event(entry, event) {\n    this.objects.push(EventType.event);\n    this.objects.push(entry);\n    this.objects.push(event);\n  }\n\n  drain() {\n    if (this.drainDisabled) return;\n    this.drainDisabled = true;\n    let objects = this.objects;\n    let listeners = this.animState.listeners;\n\n    for (let i = 0; i < objects.length; i += 2) {\n      let type = objects[i];\n      let entry = objects[i + 1];\n\n      switch (type) {\n        case EventType.start:\n          if (entry.listener != null && entry.listener.start) entry.listener.start(entry);\n\n          for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].start) listeners[ii].start(entry);\n\n          break;\n\n        case EventType.interrupt:\n          if (entry.listener != null && entry.listener.interrupt) entry.listener.interrupt(entry);\n\n          for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].interrupt) listeners[ii].interrupt(entry);\n\n          break;\n\n        case EventType.end:\n          if (entry.listener != null && entry.listener.end) entry.listener.end(entry);\n\n          for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].end) listeners[ii].end(entry);\n\n        // Fall through.\n\n        case EventType.dispose:\n          if (entry.listener != null && entry.listener.dispose) entry.listener.dispose(entry);\n\n          for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].dispose) listeners[ii].dispose(entry);\n\n          this.animState.trackEntryPool.free(entry);\n          break;\n\n        case EventType.complete:\n          if (entry.listener != null && entry.listener.complete) entry.listener.complete(entry);\n\n          for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].complete) listeners[ii].complete(entry);\n\n          break;\n\n        case EventType.event:\n          let event = objects[i++ + 2];\n          if (entry.listener != null && entry.listener.event) entry.listener.event(entry, event);\n\n          for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].event) listeners[ii].event(entry, event);\n\n          break;\n      }\n    }\n\n    this.clear();\n    this.drainDisabled = false;\n  }\n\n  clear() {\n    this.objects.length = 0;\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nvar EventType;\n\n(function (EventType) {\n  const start = 0;\n  EventType[EventType[\"start\"] = start] = \"start\";\n  const interrupt = start + 1;\n  EventType[EventType[\"interrupt\"] = interrupt] = \"interrupt\";\n  const end = interrupt + 1;\n  EventType[EventType[\"end\"] = end] = \"end\";\n  const dispose = end + 1;\n  EventType[EventType[\"dispose\"] = dispose] = \"dispose\";\n  const complete = dispose + 1;\n  EventType[EventType[\"complete\"] = complete] = \"complete\";\n  const event = complete + 1;\n  EventType[EventType[\"event\"] = event] = \"event\";\n})(EventType || (EventType = {}));\n/** The interface to implement for receiving TrackEntry events. It is always safe to call AnimationState methods when receiving\r\n * events.\r\n *\r\n * See TrackEntry {@link TrackEntry#listener} and AnimationState\r\n * {@link AnimationState#addListener()}.\r\n * @public\r\n * */\n\n/**\r\n * @public\r\n */\n\n\nclass AnimationStateAdapter {\n  start(entry) {}\n\n  interrupt(entry) {}\n\n  end(entry) {}\n\n  dispose(entry) {}\n\n  complete(entry) {}\n\n  event(entry, event) {}\n\n}\n/** 1. A previously applied timeline has set this property.\r\n *\r\n * Result: Mix from the current pose to the timeline pose. */\n\n\nconst SUBSEQUENT = 0;\n/** 1. This is the first timeline to set this property.\r\n * 2. The next track entry applied after this one does not have a timeline to set this property.\r\n *\r\n * Result: Mix from the setup pose to the timeline pose. */\n\nconst FIRST = 1;\n/** 1) A previously applied timeline has set this property.<br>\r\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\r\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\r\n * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading\r\n * animations that key the same property. A subsequent timeline will set this property using a mix. */\n\nconst HOLD_SUBSEQUENT = 2;\n/** 1) This is the first timeline to set this property.<br>\r\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\r\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\r\n * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading animations\r\n * that key the same property. A subsequent timeline will set this property using a mix. */\n\nconst HOLD_FIRST = 3;\n/** 1. This is the first timeline to set this property.\r\n * 2. The next track entry to be applied does have a timeline to set this property.\r\n * 3. The next track entry after that one does have a timeline to set this property.\r\n * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.\r\n *\r\n * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than\r\n * 2 track entries in a row have a timeline that sets the same property.\r\n *\r\n * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid\r\n * \"dipping\" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A\r\n * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into\r\n * place. */\n\nconst HOLD_MIX = 4;\nconst SETUP = 1;\nconst CURRENT = 2;\nlet _emptyAnimation = null;\n/** Stores mix (crossfade) durations to be applied when {@link AnimationState} animations are changed.\r\n * @public\r\n * */\n\nclass AnimationStateData {\n  /** The SkeletonData to look up animations when they are specified by name. */\n  __init() {\n    this.animationToMixTime = {};\n  }\n  /** The mix duration to use when no mix duration has been defined between two animations. */\n\n\n  __init2() {\n    this.defaultMix = 0;\n  }\n\n  constructor(skeletonData) {\n    AnimationStateData.prototype.__init.call(this);\n\n    AnimationStateData.prototype.__init2.call(this);\n\n    if (skeletonData == null) throw new Error(\"skeletonData cannot be null.\");\n    this.skeletonData = skeletonData;\n  }\n  /** Sets a mix duration by animation name.\r\n   *\r\n   * See {@link #setMixWith()}. */\n\n\n  setMix(fromName, toName, duration) {\n    let from = this.skeletonData.findAnimation(fromName);\n    if (from == null) throw new Error(\"Animation not found: \" + fromName);\n    let to = this.skeletonData.findAnimation(toName);\n    if (to == null) throw new Error(\"Animation not found: \" + toName);\n    this.setMixWith(from, to, duration);\n  }\n  /** Sets the mix duration when changing from the specified animation to the other.\r\n   *\r\n   * See {@link TrackEntry#mixDuration}. */\n\n\n  setMixWith(from, to, duration) {\n    if (from == null) throw new Error(\"from cannot be null.\");\n    if (to == null) throw new Error(\"to cannot be null.\");\n    let key = from.name + \".\" + to.name;\n    this.animationToMixTime[key] = duration;\n  }\n  /** Returns the mix duration to use when changing from the specified animation to the other, or the {@link #defaultMix} if\r\n   * no mix duration has been set. */\n\n\n  getMix(from, to) {\n    let key = from.name + \".\" + to.name;\n    let value = this.animationToMixTime[key];\n    return value === undefined ? this.defaultMix : value;\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass AtlasAttachmentLoader {\n  constructor(atlas) {\n    this.atlas = atlas;\n  }\n  /** @return May be null to not load an attachment. */\n  // @ts-ignore\n\n\n  newRegionAttachment(skin, name, path) {\n    let region = this.atlas.findRegion(path);\n    if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\n    let attachment = new RegionAttachment(name);\n    attachment.region = region;\n    return attachment;\n  }\n  /** @return May be null to not load an attachment. */\n  // @ts-ignore\n\n\n  newMeshAttachment(skin, name, path) {\n    let region = this.atlas.findRegion(path);\n    if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\n    let attachment = new MeshAttachment(name);\n    attachment.region = region;\n    return attachment;\n  }\n  /** @return May be null to not load an attachment. */\n  // @ts-ignore\n\n\n  newBoundingBoxAttachment(skin, name) {\n    return new BoundingBoxAttachment(name);\n  }\n  /** @return May be null to not load an attachment */\n  // @ts-ignore\n\n\n  newPathAttachment(skin, name) {\n    return new PathAttachment(name);\n  } // @ts-ignore\n\n\n  newPointAttachment(skin, name) {\n    return new PointAttachment(name);\n  } // @ts-ignore\n\n\n  newClippingAttachment(skin, name) {\n    return new ClippingAttachment(name);\n  }\n\n}\n/** Stores the setup pose for a {@link Bone}.\r\n * @public\r\n * */\n\n\nclass BoneData {\n  /** The index of the bone in {@link Skeleton#getBones()}. */\n\n  /** The name of the bone, which is unique across all bones in the skeleton. */\n\n  /** @returns May be null. */\n\n  /** The bone's length. */\n\n  /** The local x translation. */\n  __init() {\n    this.x = 0;\n  }\n  /** The local y translation. */\n\n\n  __init2() {\n    this.y = 0;\n  }\n  /** The local rotation. */\n\n\n  __init3() {\n    this.rotation = 0;\n  }\n  /** The local scaleX. */\n\n\n  __init4() {\n    this.scaleX = 1;\n  }\n  /** The local scaleY. */\n\n\n  __init5() {\n    this.scaleY = 1;\n  }\n  /** The local shearX. */\n\n\n  __init6() {\n    this.shearX = 0;\n  }\n  /** The local shearX. */\n\n\n  __init7() {\n    this.shearY = 0;\n  }\n  /** The transform mode for how parent world transforms affect this bone. */\n\n\n  __init8() {\n    this.transformMode = TransformMode.Normal;\n  }\n  /** When true, {@link Skeleton#updateWorldTransform()} only updates this bone if the {@link Skeleton#skin} contains this\r\n   * bone.\r\n   * @see Skin#bones */\n\n\n  __init9() {\n    this.skinRequired = false;\n  }\n  /** The color of the bone as it was in Spine. Available only when nonessential data was exported. Bones are not usually\r\n   * rendered at runtime. */\n\n\n  __init10() {\n    this.color = new Color();\n  }\n\n  constructor(index, name, parent) {\n    BoneData.prototype.__init.call(this);\n\n    BoneData.prototype.__init2.call(this);\n\n    BoneData.prototype.__init3.call(this);\n\n    BoneData.prototype.__init4.call(this);\n\n    BoneData.prototype.__init5.call(this);\n\n    BoneData.prototype.__init6.call(this);\n\n    BoneData.prototype.__init7.call(this);\n\n    BoneData.prototype.__init8.call(this);\n\n    BoneData.prototype.__init9.call(this);\n\n    BoneData.prototype.__init10.call(this);\n\n    if (index < 0) throw new Error(\"index must be >= 0.\");\n    if (name == null) throw new Error(\"name cannot be null.\");\n    this.index = index;\n    this.name = name;\n    this.parent = parent;\n  }\n\n}\n/** Determines how a bone inherits world transforms from parent bones.\r\n * @public\r\n * */\n\n\nvar TransformMode;\n\n(function (TransformMode) {\n  const Normal = 0;\n  TransformMode[TransformMode[\"Normal\"] = Normal] = \"Normal\";\n  const OnlyTranslation = Normal + 1;\n  TransformMode[TransformMode[\"OnlyTranslation\"] = OnlyTranslation] = \"OnlyTranslation\";\n  const NoRotationOrReflection = OnlyTranslation + 1;\n  TransformMode[TransformMode[\"NoRotationOrReflection\"] = NoRotationOrReflection] = \"NoRotationOrReflection\";\n  const NoScale = NoRotationOrReflection + 1;\n  TransformMode[TransformMode[\"NoScale\"] = NoScale] = \"NoScale\";\n  const NoScaleOrReflection = NoScale + 1;\n  TransformMode[TransformMode[\"NoScaleOrReflection\"] = NoScaleOrReflection] = \"NoScaleOrReflection\";\n})(TransformMode || (TransformMode = {}));\n/** Stores a bone's current pose.\r\n *\r\n * A bone has a local transform which is used to compute its world transform. A bone also has an applied transform, which is a\r\n * local transform that can be applied to compute the world transform. The local transform and applied transform may differ if a\r\n * constraint or application code modifies the world transform after it was computed from the local transform.\r\n * @public\r\n * */\n\n\nclass Bone {\n  //be careful! Spine b,c is c,b in pixi matrix\n  __init() {\n    this.matrix = new Matrix();\n  }\n\n  get worldX() {\n    return this.matrix.tx;\n  }\n\n  get worldY() {\n    return this.matrix.ty;\n  }\n  /** The bone's setup pose data. */\n\n  /** The skeleton this bone belongs to. */\n\n  /** The parent bone, or null if this is the root bone. */\n\n  /** The immediate children of this bone. */\n\n\n  __init2() {\n    this.children = new Array();\n  }\n  /** The local x translation. */\n\n\n  __init3() {\n    this.x = 0;\n  }\n  /** The local y translation. */\n\n\n  __init4() {\n    this.y = 0;\n  }\n  /** The local rotation in degrees, counter clockwise. */\n\n\n  __init5() {\n    this.rotation = 0;\n  }\n  /** The local scaleX. */\n\n\n  __init6() {\n    this.scaleX = 0;\n  }\n  /** The local scaleY. */\n\n\n  __init7() {\n    this.scaleY = 0;\n  }\n  /** The local shearX. */\n\n\n  __init8() {\n    this.shearX = 0;\n  }\n  /** The local shearY. */\n\n\n  __init9() {\n    this.shearY = 0;\n  }\n  /** The applied local x translation. */\n\n\n  __init10() {\n    this.ax = 0;\n  }\n  /** The applied local y translation. */\n\n\n  __init11() {\n    this.ay = 0;\n  }\n  /** The applied local rotation in degrees, counter clockwise. */\n\n\n  __init12() {\n    this.arotation = 0;\n  }\n  /** The applied local scaleX. */\n\n\n  __init13() {\n    this.ascaleX = 0;\n  }\n  /** The applied local scaleY. */\n\n\n  __init14() {\n    this.ascaleY = 0;\n  }\n  /** The applied local shearX. */\n\n\n  __init15() {\n    this.ashearX = 0;\n  }\n  /** The applied local shearY. */\n\n\n  __init16() {\n    this.ashearY = 0;\n  }\n\n  __init17() {\n    this.sorted = false;\n  }\n\n  __init18() {\n    this.active = false;\n  }\n  /** @param parent May be null. */\n\n\n  constructor(data, skeleton, parent) {\n    Bone.prototype.__init.call(this);\n\n    Bone.prototype.__init2.call(this);\n\n    Bone.prototype.__init3.call(this);\n\n    Bone.prototype.__init4.call(this);\n\n    Bone.prototype.__init5.call(this);\n\n    Bone.prototype.__init6.call(this);\n\n    Bone.prototype.__init7.call(this);\n\n    Bone.prototype.__init8.call(this);\n\n    Bone.prototype.__init9.call(this);\n\n    Bone.prototype.__init10.call(this);\n\n    Bone.prototype.__init11.call(this);\n\n    Bone.prototype.__init12.call(this);\n\n    Bone.prototype.__init13.call(this);\n\n    Bone.prototype.__init14.call(this);\n\n    Bone.prototype.__init15.call(this);\n\n    Bone.prototype.__init16.call(this);\n\n    Bone.prototype.__init17.call(this);\n\n    Bone.prototype.__init18.call(this);\n\n    if (!data) throw new Error(\"data cannot be null.\");\n    if (!skeleton) throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.skeleton = skeleton;\n    this.parent = parent;\n    this.setToSetupPose();\n  }\n  /** Returns false when the bone has not been computed because {@link BoneData#skinRequired} is true and the\r\n   * {@link Skeleton#skin active skin} does not {@link Skin#bones contain} this bone. */\n\n\n  isActive() {\n    return this.active;\n  }\n  /** Computes the world transform using the parent bone and this bone's local applied transform. */\n\n\n  update() {\n    this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);\n  }\n  /** Computes the world transform using the parent bone and this bone's local transform.\r\n   *\r\n   * See {@link #updateWorldTransformWith()}. */\n\n\n  updateWorldTransform() {\n    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n  }\n  /** Computes the world transform using the parent bone and the specified local transform. The applied transform is set to the\r\n   * specified local transform. Child bones are not updated.\r\n   *\r\n   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\r\n   * Runtimes Guide. */\n\n\n  updateWorldTransformWith(x, y, rotation, scaleX, scaleY, shearX, shearY) {\n    this.ax = x;\n    this.ay = y;\n    this.arotation = rotation;\n    this.ascaleX = scaleX;\n    this.ascaleY = scaleY;\n    this.ashearX = shearX;\n    this.ashearY = shearY;\n    let parent = this.parent;\n    let m = this.matrix;\n    let sx = this.skeleton.scaleX;\n    let sy = settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;\n\n    if (!parent) {\n      // Root bone.\n      let skeleton = this.skeleton;\n      let rotationY = rotation + 90 + shearY;\n      m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\n      m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\n      m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\n      m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\n      m.tx = x * sx + skeleton.x;\n      m.ty = y * sy + skeleton.y;\n      return;\n    }\n\n    let pa = parent.matrix.a,\n        pb = parent.matrix.c,\n        pc = parent.matrix.b,\n        pd = parent.matrix.d;\n    m.tx = pa * x + pb * y + parent.matrix.tx;\n    m.ty = pc * x + pd * y + parent.matrix.ty;\n\n    switch (this.data.transformMode) {\n      case TransformMode.Normal:\n        {\n          let rotationY = rotation + 90 + shearY;\n          let la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n          let lb = MathUtils.cosDeg(rotationY) * scaleY;\n          let lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n          let ld = MathUtils.sinDeg(rotationY) * scaleY;\n          m.a = pa * la + pb * lc;\n          m.c = pa * lb + pb * ld;\n          m.b = pc * la + pd * lc;\n          m.d = pc * lb + pd * ld;\n          return;\n        }\n\n      case TransformMode.OnlyTranslation:\n        {\n          let rotationY = rotation + 90 + shearY;\n          m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\n          m.c = MathUtils.cosDeg(rotationY) * scaleY;\n          m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\n          m.d = MathUtils.sinDeg(rotationY) * scaleY;\n          break;\n        }\n\n      case TransformMode.NoRotationOrReflection:\n        {\n          let s = pa * pa + pc * pc;\n          let prx = 0;\n\n          if (s > 0.0001) {\n            s = Math.abs(pa * pd - pb * pc) / s;\n            pa /= this.skeleton.scaleX;\n            pc /= this.skeleton.scaleY;\n            pb = pc * s;\n            pd = pa * s;\n            prx = Math.atan2(pc, pa) * MathUtils.radDeg;\n          } else {\n            pa = 0;\n            pc = 0;\n            prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n          }\n\n          let rx = rotation + shearX - prx;\n          let ry = rotation + shearY - prx + 90;\n          let la = MathUtils.cosDeg(rx) * scaleX;\n          let lb = MathUtils.cosDeg(ry) * scaleY;\n          let lc = MathUtils.sinDeg(rx) * scaleX;\n          let ld = MathUtils.sinDeg(ry) * scaleY;\n          m.a = pa * la - pb * lc;\n          m.c = pa * lb - pb * ld;\n          m.b = pc * la + pd * lc;\n          m.d = pc * lb + pd * ld;\n          break;\n        }\n\n      case TransformMode.NoScale:\n      case TransformMode.NoScaleOrReflection:\n        {\n          let cos = MathUtils.cosDeg(rotation);\n          let sin = MathUtils.sinDeg(rotation);\n          let za = (pa * cos + pb * sin) / sx;\n          let zc = (pc * cos + pd * sin) / sy;\n          let s = Math.sqrt(za * za + zc * zc);\n          if (s > 0.00001) s = 1 / s;\n          za *= s;\n          zc *= s;\n          s = Math.sqrt(za * za + zc * zc);\n          if (this.data.transformMode == TransformMode.NoScale && pa * pd - pb * pc < 0 != (settings.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0)) s = -s;\n          let r = Math.PI / 2 + Math.atan2(zc, za);\n          let zb = Math.cos(r) * s;\n          let zd = Math.sin(r) * s;\n          let la = MathUtils.cosDeg(shearX) * scaleX;\n          let lb = MathUtils.cosDeg(90 + shearY) * scaleY;\n          let lc = MathUtils.sinDeg(shearX) * scaleX;\n          let ld = MathUtils.sinDeg(90 + shearY) * scaleY;\n          m.a = za * la + zb * lc;\n          m.c = za * lb + zb * ld;\n          m.b = zc * la + zd * lc;\n          m.d = zc * lb + zd * ld;\n          break;\n        }\n    }\n\n    m.a *= sx;\n    m.c *= sx;\n    m.b *= sy;\n    m.d *= sy;\n  }\n  /** Sets this bone's local transform to the setup pose. */\n\n\n  setToSetupPose() {\n    let data = this.data;\n    this.x = data.x;\n    this.y = data.y;\n    this.rotation = data.rotation;\n    this.scaleX = data.scaleX;\n    this.scaleY = data.scaleY;\n    this.shearX = data.shearX;\n    this.shearY = data.shearY;\n  }\n  /** The world rotation for the X axis, calculated using {@link #a} and {@link #c}. */\n\n\n  getWorldRotationX() {\n    return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n  }\n  /** The world rotation for the Y axis, calculated using {@link #b} and {@link #d}. */\n\n\n  getWorldRotationY() {\n    return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n  }\n  /** The magnitude (always positive) of the world scale X, calculated using {@link #a} and {@link #c}. */\n\n\n  getWorldScaleX() {\n    let m = this.matrix;\n    return Math.sqrt(m.a * m.a + m.b * m.b);\n  }\n  /** The magnitude (always positive) of the world scale Y, calculated using {@link #b} and {@link #d}. */\n\n\n  getWorldScaleY() {\n    let m = this.matrix;\n    return Math.sqrt(m.c * m.c + m.d * m.d);\n  }\n  /** Computes the applied transform values from the world transform.\r\n   *\r\n   * If the world transform is modified (by a constraint, {@link #rotateWorld(float)}, etc) then this method should be called so\r\n   * the applied transform matches the world transform. The applied transform may be needed by other code (eg to apply other\r\n   * constraints).\r\n   *\r\n   * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. The applied transform after\r\n   * calling this method is equivalent to the local transform used to compute the world transform, but may not be identical. */\n\n\n  updateAppliedTransform() {\n    let parent = this.parent;\n    let m = this.matrix;\n\n    if (!parent) {\n      this.ax = m.tx;\n      this.ay = m.ty;\n      this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n      this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n      this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n      this.ashearX = 0;\n      this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\n      return;\n    }\n\n    let pm = parent.matrix;\n    let pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n    let dx = m.tx - pm.tx,\n        dy = m.ty - pm.ty;\n    this.ax = dx * pm.d * pid - dy * pm.c * pid;\n    this.ay = dy * pm.a * pid - dx * pm.b * pid;\n    let ia = pid * pm.d;\n    let id = pid * pm.a;\n    let ib = pid * pm.c;\n    let ic = pid * pm.b;\n    let ra = ia * m.a - ib * m.b;\n    let rb = ia * m.c - ib * m.d;\n    let rc = id * m.b - ic * m.a;\n    let rd = id * m.d - ic * m.c;\n    this.ashearX = 0;\n    this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n\n    if (this.ascaleX > 0.0001) {\n      let det = ra * rd - rb * rc;\n      this.ascaleY = det / this.ascaleX;\n      this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n      this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n    } else {\n      this.ascaleX = 0;\n      this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n      this.ashearY = 0;\n      this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n    }\n  }\n  /** Transforms a point from world coordinates to the bone's local coordinates. */\n\n\n  worldToLocal(world) {\n    let m = this.matrix;\n    let a = m.a,\n        b = m.c,\n        c = m.b,\n        d = m.d;\n    let invDet = 1 / (a * d - b * c);\n    let x = world.x - m.tx,\n        y = world.y - m.ty;\n    world.x = x * d * invDet - y * b * invDet;\n    world.y = y * a * invDet - x * c * invDet;\n    return world;\n  }\n  /** Transforms a point from the bone's local coordinates to world coordinates. */\n\n\n  localToWorld(local) {\n    let m = this.matrix;\n    let x = local.x,\n        y = local.y;\n    local.x = x * m.a + y * m.c + m.tx;\n    local.y = x * m.b + y * m.d + m.ty;\n    return local;\n  }\n  /** Transforms a world rotation to a local rotation. */\n\n\n  worldToLocalRotation(worldRotation) {\n    let sin = MathUtils.sinDeg(worldRotation),\n        cos = MathUtils.cosDeg(worldRotation);\n    let mat = this.matrix;\n    return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\n  }\n  /** Transforms a local rotation to a world rotation. */\n\n\n  localToWorldRotation(localRotation) {\n    localRotation -= this.rotation - this.shearX;\n    let sin = MathUtils.sinDeg(localRotation),\n        cos = MathUtils.cosDeg(localRotation);\n    let mat = this.matrix;\n    return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\n  }\n  /** Rotates the world transform the specified amount.\r\n   * <p>\r\n   * After changes are made to the world transform, {@link #updateAppliedTransform()} should be called and {@link #update()} will\r\n   * need to be called on any child bones, recursively. */\n\n\n  rotateWorld(degrees) {\n    let mat = this.matrix;\n    let a = mat.a,\n        b = mat.c,\n        c = mat.b,\n        d = mat.d;\n    let cos = MathUtils.cosDeg(degrees),\n        sin = MathUtils.sinDeg(degrees);\n    mat.a = cos * a - sin * c;\n    mat.c = cos * b - sin * d;\n    mat.b = sin * a + cos * c;\n    mat.d = sin * b + cos * d;\n  }\n\n}\n/** The base class for all constraint datas.\r\n * @public\r\n * */\n\n\nclass ConstraintData {\n  constructor(name, order, skinRequired) {\n    this.name = name;\n    this.order = order;\n    this.skinRequired = skinRequired;\n  }\n\n}\n/** Stores the current pose values for an {@link Event}.\r\n *\r\n * See Timeline {@link Timeline#apply()},\r\n * AnimationStateListener {@link AnimationStateListener#event()}, and\r\n * [Events](http://esotericsoftware.com/spine-events) in the Spine User Guide.\r\n * @public\r\n * */\n\n\nclass Event {\n  constructor(time, data) {\n    if (data == null) throw new Error(\"data cannot be null.\");\n    this.time = time;\n    this.data = data;\n  }\n\n}\n/** Stores the setup pose values for an {@link Event}.\r\n *\r\n * See [Events](http://esotericsoftware.com/spine-events) in the Spine User Guide.\r\n * @public\r\n * */\n\n\nclass EventData {\n  constructor(name) {\n    this.name = name;\n  }\n\n}\n/** Stores the current pose for an IK constraint. An IK constraint adjusts the rotation of 1 or 2 constrained bones so the tip of\r\n * the last bone is as close to the target bone as possible.\r\n *\r\n * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide.\r\n * @public\r\n * */\n\n\nclass IkConstraint {\n  /** The IK constraint's setup pose data. */\n\n  /** The bones that will be modified by this IK constraint. */\n\n  /** The bone that is the IK target. */\n\n  /** Controls the bend direction of the IK bones, either 1 or -1. */\n  __init() {\n    this.bendDirection = 0;\n  }\n  /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\n\n\n  __init2() {\n    this.compress = false;\n  }\n  /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\r\n   * and the parent bone has local nonuniform scale, stretch is not applied. */\n\n\n  __init3() {\n    this.stretch = false;\n  }\n  /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\n\n\n  __init4() {\n    this.mix = 1;\n  }\n  /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\n\n\n  __init5() {\n    this.softness = 0;\n  }\n\n  __init6() {\n    this.active = false;\n  }\n\n  constructor(data, skeleton) {\n    IkConstraint.prototype.__init.call(this);\n\n    IkConstraint.prototype.__init2.call(this);\n\n    IkConstraint.prototype.__init3.call(this);\n\n    IkConstraint.prototype.__init4.call(this);\n\n    IkConstraint.prototype.__init5.call(this);\n\n    IkConstraint.prototype.__init6.call(this);\n\n    if (!data) throw new Error(\"data cannot be null.\");\n    if (!skeleton) throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.mix = data.mix;\n    this.softness = data.softness;\n    this.bendDirection = data.bendDirection;\n    this.compress = data.compress;\n    this.stretch = data.stretch;\n    this.bones = new Array();\n\n    for (let i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n\n    this.target = skeleton.findBone(data.target.name);\n  }\n\n  isActive() {\n    return this.active;\n  }\n\n  update() {\n    if (this.mix == 0) return;\n    let target = this.target;\n    let bones = this.bones;\n\n    switch (bones.length) {\n      case 1:\n        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n        break;\n\n      case 2:\n        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);\n        break;\n    }\n  }\n  /** Applies 1 bone IK. The target is specified in the world coordinate system. */\n\n\n  apply1(bone, targetX, targetY, compress, stretch, uniform, alpha) {\n    let p = bone.parent.matrix;\n    let pa = p.a,\n        pb = p.c,\n        pc = p.b,\n        pd = p.d;\n    let rotationIK = -bone.ashearX - bone.arotation,\n        tx = 0,\n        ty = 0;\n\n    switch (bone.data.transformMode) {\n      case TransformMode.OnlyTranslation:\n        tx = targetX - bone.worldX;\n        ty = targetY - bone.worldY;\n        break;\n\n      case TransformMode.NoRotationOrReflection:\n        let s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\n        let sa = pa / bone.skeleton.scaleX;\n        let sc = pc / bone.skeleton.scaleY;\n        pb = -sc * s * bone.skeleton.scaleX;\n        pd = sa * s * bone.skeleton.scaleY;\n        rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\n      // Fall through\n\n      default:\n        let x = targetX - p.tx,\n            y = targetY - p.ty;\n        let d = pa * pd - pb * pc;\n        tx = (x * pd - y * pb) / d - bone.ax;\n        ty = (y * pa - x * pc) / d - bone.ay;\n    }\n\n    rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\n    if (bone.ascaleX < 0) rotationIK += 180;\n    if (rotationIK > 180) rotationIK -= 360;else if (rotationIK < -180) rotationIK += 360;\n    let sx = bone.ascaleX,\n        sy = bone.ascaleY;\n\n    if (compress || stretch) {\n      switch (bone.data.transformMode) {\n        case TransformMode.NoScale:\n        case TransformMode.NoScaleOrReflection:\n          tx = targetX - bone.worldX;\n          ty = targetY - bone.worldY;\n      }\n\n      let b = bone.data.length * sx,\n          dd = Math.sqrt(tx * tx + ty * ty);\n\n      if (compress && dd < b || stretch && dd > b && b > 0.0001) {\n        let s = (dd / b - 1) * alpha + 1;\n        sx *= s;\n        if (uniform) sy *= s;\n      }\n    }\n\n    bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\n  }\n  /** Applies 2 bone IK. The target is specified in the world coordinate system.\r\n   * @param child A direct descendant of the parent bone. */\n\n\n  apply2(parent, child, targetX, targetY, bendDir, stretch, uniform, softness, alpha) {\n    let px = parent.ax,\n        py = parent.ay,\n        psx = parent.ascaleX,\n        psy = parent.ascaleY,\n        sx = psx,\n        sy = psy,\n        csx = child.ascaleX;\n    let pmat = parent.matrix;\n    let os1 = 0,\n        os2 = 0,\n        s2 = 0;\n\n    if (psx < 0) {\n      psx = -psx;\n      os1 = 180;\n      s2 = -1;\n    } else {\n      os1 = 0;\n      s2 = 1;\n    }\n\n    if (psy < 0) {\n      psy = -psy;\n      s2 = -s2;\n    }\n\n    if (csx < 0) {\n      csx = -csx;\n      os2 = 180;\n    } else os2 = 0;\n\n    let cx = child.ax,\n        cy = 0,\n        cwx = 0,\n        cwy = 0,\n        a = pmat.a,\n        b = pmat.c,\n        c = pmat.b,\n        d = pmat.d;\n    let u = Math.abs(psx - psy) <= 0.0001;\n\n    if (!u || stretch) {\n      cy = 0;\n      cwx = a * cx + pmat.tx;\n      cwy = c * cx + pmat.ty;\n    } else {\n      cy = child.ay;\n      cwx = a * cx + b * cy + pmat.tx;\n      cwy = c * cx + d * cy + pmat.ty;\n    }\n\n    let pp = parent.parent.matrix;\n    a = pp.a;\n    b = pp.c;\n    c = pp.b;\n    d = pp.d;\n    let id = 1 / (a * d - b * c),\n        x = cwx - pp.tx,\n        y = cwy - pp.ty;\n    let dx = (x * d - y * b) * id - px,\n        dy = (y * a - x * c) * id - py;\n    let l1 = Math.sqrt(dx * dx + dy * dy),\n        l2 = child.data.length * csx,\n        a1,\n        a2;\n\n    if (l1 < 0.0001) {\n      this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\n      child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n      return;\n    }\n\n    x = targetX - pp.tx;\n    y = targetY - pp.ty;\n    let tx = (x * d - y * b) * id - px,\n        ty = (y * a - x * c) * id - py;\n    let dd = tx * tx + ty * ty;\n\n    if (softness != 0) {\n      softness *= psx * (csx + 1) * 0.5;\n      let td = Math.sqrt(dd),\n          sd = td - l1 - l2 * psx + softness;\n\n      if (sd > 0) {\n        let p = Math.min(1, sd / (softness * 2)) - 1;\n        p = (sd - softness * (1 - p * p)) / td;\n        tx -= p * tx;\n        ty -= p * ty;\n        dd = tx * tx + ty * ty;\n      }\n    }\n\n    outer: if (u) {\n      l2 *= psx;\n      let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n\n      if (cos < -1) {\n        cos = -1;\n        a2 = Math.PI * bendDir;\n      } else if (cos > 1) {\n        cos = 1;\n        a2 = 0;\n\n        if (stretch) {\n          a = (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n          sx *= a;\n          if (uniform) sy *= a;\n        }\n      } else a2 = Math.acos(cos) * bendDir;\n\n      a = l1 + l2 * cos;\n      b = l2 * Math.sin(a2);\n      a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n    } else {\n      a = psx * l2;\n      b = psy * l2;\n      let aa = a * a,\n          bb = b * b,\n          ta = Math.atan2(ty, tx);\n      c = bb * l1 * l1 + aa * dd - aa * bb;\n      let c1 = -2 * bb * l1,\n          c2 = bb - aa;\n      d = c1 * c1 - 4 * c2 * c;\n\n      if (d >= 0) {\n        let q = Math.sqrt(d);\n        if (c1 < 0) q = -q;\n        q = -(c1 + q) * 0.5;\n        let r0 = q / c2,\n            r1 = c / q;\n        let r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n\n        if (r * r <= dd) {\n          y = Math.sqrt(dd - r * r) * bendDir;\n          a1 = ta - Math.atan2(y, r);\n          a2 = Math.atan2(y / psy, (r - l1) / psx);\n          break outer;\n        }\n      }\n\n      let minAngle = MathUtils.PI,\n          minX = l1 - a,\n          minDist = minX * minX,\n          minY = 0;\n      let maxAngle = 0,\n          maxX = l1 + a,\n          maxDist = maxX * maxX,\n          maxY = 0;\n      c = -a * l1 / (aa - bb);\n\n      if (c >= -1 && c <= 1) {\n        c = Math.acos(c);\n        x = a * Math.cos(c) + l1;\n        y = b * Math.sin(c);\n        d = x * x + y * y;\n\n        if (d < minDist) {\n          minAngle = c;\n          minDist = d;\n          minX = x;\n          minY = y;\n        }\n\n        if (d > maxDist) {\n          maxAngle = c;\n          maxDist = d;\n          maxX = x;\n          maxY = y;\n        }\n      }\n\n      if (dd <= (minDist + maxDist) * 0.5) {\n        a1 = ta - Math.atan2(minY * bendDir, minX);\n        a2 = minAngle * bendDir;\n      } else {\n        a1 = ta - Math.atan2(maxY * bendDir, maxX);\n        a2 = maxAngle * bendDir;\n      }\n    }\n\n    let os = Math.atan2(cy, cx) * s2;\n    let rotation = parent.arotation;\n    a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n    if (a1 > 180) a1 -= 360;else if (a1 < -180) //\n      a1 += 360;\n    parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, sy, 0, 0);\n    rotation = child.arotation;\n    a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n    if (a2 > 180) a2 -= 360;else if (a2 < -180) //\n      a2 += 360;\n    child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n  }\n\n}\n/** Stores the setup pose for an {@link IkConstraint}.\r\n * <p>\r\n * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide.\r\n * @public\r\n * */\n\n\nclass IkConstraintData extends ConstraintData {\n  /** The bones that are constrained by this IK constraint. */\n  __init() {\n    this.bones = new Array();\n  }\n  /** The bone that is the IK target. */\n\n  /** Controls the bend direction of the IK bones, either 1 or -1. */\n\n\n  __init2() {\n    this.bendDirection = 1;\n  }\n  /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\n\n\n  __init3() {\n    this.compress = false;\n  }\n  /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\r\n   * and the parent bone has local nonuniform scale, stretch is not applied. */\n\n\n  __init4() {\n    this.stretch = false;\n  }\n  /** When true, only a single bone is being constrained, and {@link #getCompress()} or {@link #getStretch()} is used, the bone\r\n   * is scaled on both the X and Y axes. */\n\n\n  __init5() {\n    this.uniform = false;\n  }\n  /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\n\n\n  __init6() {\n    this.mix = 1;\n  }\n  /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\n\n\n  __init7() {\n    this.softness = 0;\n  }\n\n  constructor(name) {\n    super(name, 0, false);\n\n    IkConstraintData.prototype.__init.call(this);\n\n    IkConstraintData.prototype.__init2.call(this);\n\n    IkConstraintData.prototype.__init3.call(this);\n\n    IkConstraintData.prototype.__init4.call(this);\n\n    IkConstraintData.prototype.__init5.call(this);\n\n    IkConstraintData.prototype.__init6.call(this);\n\n    IkConstraintData.prototype.__init7.call(this);\n  }\n\n}\n/** Stores the setup pose for a {@link PathConstraint}.\r\n *\r\n * See [Path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide.\r\n * @public\r\n * */\n\n\nclass PathConstraintData extends ConstraintData {\n  /** The bones that will be modified by this path constraint. */\n  __init() {\n    this.bones = new Array();\n  }\n  /** The slot whose path attachment will be used to constrained the bones. */\n\n  /** The mode for positioning the first bone on the path. */\n\n  /** The mode for positioning the bones after the first bone on the path. */\n\n  /** The mode for adjusting the rotation of the bones. */\n\n  /** An offset added to the constrained bone rotation. */\n\n  /** The position along the path. */\n\n  /** The spacing between bones. */\n\n\n  __init2() {\n    this.mixRotate = 0;\n  }\n\n  __init3() {\n    this.mixX = 0;\n  }\n\n  __init4() {\n    this.mixY = 0;\n  }\n\n  constructor(name) {\n    super(name, 0, false);\n\n    PathConstraintData.prototype.__init.call(this);\n\n    PathConstraintData.prototype.__init2.call(this);\n\n    PathConstraintData.prototype.__init3.call(this);\n\n    PathConstraintData.prototype.__init4.call(this);\n  }\n\n}\n/** Controls how the first bone is positioned along the path.\r\n *\r\n * See [Position mode](http://esotericsoftware.com/spine-path-constraints#Position-mode) in the Spine User Guide.\r\n * @public\r\n * */\n\n\nvar PositionMode;\n\n(function (PositionMode) {\n  const Fixed = 0;\n  PositionMode[PositionMode[\"Fixed\"] = Fixed] = \"Fixed\";\n  const Percent = Fixed + 1;\n  PositionMode[PositionMode[\"Percent\"] = Percent] = \"Percent\";\n})(PositionMode || (PositionMode = {}));\n/** Controls how bones after the first bone are positioned along the path.\r\n *\r\n * [Spacing mode](http://esotericsoftware.com/spine-path-constraints#Spacing-mode) in the Spine User Guide.\r\n * @public\r\n * */\n\n\nvar SpacingMode;\n\n(function (SpacingMode) {\n  const Length = 0;\n  SpacingMode[SpacingMode[\"Length\"] = Length] = \"Length\";\n  const Fixed = Length + 1;\n  SpacingMode[SpacingMode[\"Fixed\"] = Fixed] = \"Fixed\";\n  const Percent = Fixed + 1;\n  SpacingMode[SpacingMode[\"Percent\"] = Percent] = \"Percent\";\n  const Proportional = Percent + 1;\n  SpacingMode[SpacingMode[\"Proportional\"] = Proportional] = \"Proportional\";\n})(SpacingMode || (SpacingMode = {}));\n/** Controls how bones are rotated, translated, and scaled to match the path.\r\n *\r\n * [Rotate mode](http://esotericsoftware.com/spine-path-constraints#Rotate-mod) in the Spine User Guide.\r\n * @public\r\n * */\n\n\nvar RotateMode;\n\n(function (RotateMode) {\n  const Tangent = 0;\n  RotateMode[RotateMode[\"Tangent\"] = Tangent] = \"Tangent\";\n  const Chain = Tangent + 1;\n  RotateMode[RotateMode[\"Chain\"] = Chain] = \"Chain\";\n  const ChainScale = Chain + 1;\n  RotateMode[RotateMode[\"ChainScale\"] = ChainScale] = \"ChainScale\";\n})(RotateMode || (RotateMode = {}));\n/** Stores the current pose for a path constraint. A path constraint adjusts the rotation, translation, and scale of the\r\n * constrained bones so they follow a {@link PathAttachment}.\r\n *\r\n * See [Path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide.\r\n * @public\r\n * */\n\n\nclass PathConstraint {\n  static __initStatic() {\n    this.NONE = -1;\n  }\n\n  static __initStatic2() {\n    this.BEFORE = -2;\n  }\n\n  static __initStatic3() {\n    this.AFTER = -3;\n  }\n\n  static __initStatic4() {\n    this.epsilon = 0.00001;\n  }\n  /** The path constraint's setup pose data. */\n\n  /** The bones that will be modified by this path constraint. */\n\n  /** The slot whose path attachment will be used to constrained the bones. */\n\n  /** The position along the path. */\n\n\n  __init() {\n    this.position = 0;\n  }\n  /** The spacing between bones. */\n\n\n  __init2() {\n    this.spacing = 0;\n  }\n\n  __init3() {\n    this.mixRotate = 0;\n  }\n\n  __init4() {\n    this.mixX = 0;\n  }\n\n  __init5() {\n    this.mixY = 0;\n  }\n\n  __init6() {\n    this.spaces = new Array();\n  }\n\n  __init7() {\n    this.positions = new Array();\n  }\n\n  __init8() {\n    this.world = new Array();\n  }\n\n  __init9() {\n    this.curves = new Array();\n  }\n\n  __init10() {\n    this.lengths = new Array();\n  }\n\n  __init11() {\n    this.segments = new Array();\n  }\n\n  __init12() {\n    this.active = false;\n  }\n\n  constructor(data, skeleton) {\n    PathConstraint.prototype.__init.call(this);\n\n    PathConstraint.prototype.__init2.call(this);\n\n    PathConstraint.prototype.__init3.call(this);\n\n    PathConstraint.prototype.__init4.call(this);\n\n    PathConstraint.prototype.__init5.call(this);\n\n    PathConstraint.prototype.__init6.call(this);\n\n    PathConstraint.prototype.__init7.call(this);\n\n    PathConstraint.prototype.__init8.call(this);\n\n    PathConstraint.prototype.__init9.call(this);\n\n    PathConstraint.prototype.__init10.call(this);\n\n    PathConstraint.prototype.__init11.call(this);\n\n    PathConstraint.prototype.__init12.call(this);\n\n    if (data == null) throw new Error(\"data cannot be null.\");\n    if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.bones = new Array();\n\n    for (let i = 0, n = data.bones.length; i < n; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n\n    this.target = skeleton.findSlot(data.target.name);\n    this.position = data.position;\n    this.spacing = data.spacing;\n    this.mixRotate = data.mixRotate;\n    this.mixX = data.mixX;\n    this.mixY = data.mixY;\n  }\n\n  isActive() {\n    return this.active;\n  }\n\n  update() {\n    let attachment = this.target.getAttachment();\n    if (!(attachment instanceof PathAttachment)) return;\n    let mixRotate = this.mixRotate,\n        mixX = this.mixX,\n        mixY = this.mixY;\n    if (mixRotate == 0 && mixX == 0 && mixY == 0) return;\n    let data = this.data;\n    let tangents = data.rotateMode == RotateMode.Tangent,\n        scale = data.rotateMode == RotateMode.ChainScale;\n    let boneCount = this.bones.length,\n        spacesCount = tangents ? boneCount : boneCount + 1;\n    let bones = this.bones;\n    let spaces = Utils.setArraySize(this.spaces, spacesCount),\n        lengths = scale ? this.lengths = Utils.setArraySize(this.lengths, boneCount) : null;\n    let spacing = this.spacing;\n\n    switch (data.spacingMode) {\n      case SpacingMode.Percent:\n        if (scale) {\n          for (let i = 0, n = spacesCount - 1; i < n; i++) {\n            let bone = bones[i];\n            let setupLength = bone.data.length;\n            if (setupLength < PathConstraint.epsilon) lengths[i] = 0;else {\n              let x = setupLength * bone.matrix.a,\n                  y = setupLength * bone.matrix.b;\n              lengths[i] = Math.sqrt(x * x + y * y);\n            }\n          }\n        }\n\n        Utils.arrayFill(spaces, 1, spacesCount, spacing);\n        break;\n\n      case SpacingMode.Proportional:\n        let sum = 0;\n\n        for (let i = 0, n = spacesCount - 1; i < n;) {\n          let bone = bones[i];\n          let setupLength = bone.data.length;\n\n          if (setupLength < PathConstraint.epsilon) {\n            if (scale) lengths[i] = 0;\n            spaces[++i] = spacing;\n          } else {\n            let x = setupLength * bone.matrix.a,\n                y = setupLength * bone.matrix.b;\n            let length = Math.sqrt(x * x + y * y);\n            if (scale) lengths[i] = length;\n            spaces[++i] = length;\n            sum += length;\n          }\n        }\n\n        if (sum > 0) {\n          sum = spacesCount / sum * spacing;\n\n          for (let i = 1; i < spacesCount; i++) spaces[i] *= sum;\n        }\n\n        break;\n\n      default:\n        let lengthSpacing = data.spacingMode == SpacingMode.Length;\n\n        for (let i = 0, n = spacesCount - 1; i < n;) {\n          let bone = bones[i];\n          let setupLength = bone.data.length;\n\n          if (setupLength < PathConstraint.epsilon) {\n            if (scale) lengths[i] = 0;\n            spaces[++i] = spacing;\n          } else {\n            let x = setupLength * bone.matrix.a,\n                y = setupLength * bone.matrix.b;\n            let length = Math.sqrt(x * x + y * y);\n            if (scale) lengths[i] = length;\n            spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;\n          }\n        }\n\n    }\n\n    let positions = this.computeWorldPositions(attachment, spacesCount, tangents);\n    let boneX = positions[0],\n        boneY = positions[1],\n        offsetRotation = data.offsetRotation;\n    let tip = false;\n    if (offsetRotation == 0) tip = data.rotateMode == RotateMode.Chain;else {\n      tip = false;\n      let p = this.target.bone.matrix;\n      offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    }\n\n    for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n      let bone = bones[i];\n      let mat = bone.matrix;\n      mat.tx += (boneX - mat.tx) * mixX;\n      mat.ty += (boneY - mat.ty) * mixY;\n      let x = positions[p],\n          y = positions[p + 1],\n          dx = x - boneX,\n          dy = y - boneY;\n\n      if (scale) {\n        let length = lengths[i];\n\n        if (length != 0) {\n          let s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * mixRotate + 1;\n          mat.a *= s;\n          mat.b *= s;\n        }\n      }\n\n      boneX = x;\n      boneY = y;\n\n      if (mixRotate > 0) {\n        let a = mat.a,\n            b = mat.c,\n            c = mat.b,\n            d = mat.d,\n            r = 0,\n            cos = 0,\n            sin = 0;\n        if (tangents) r = positions[p - 1];else if (spaces[i + 1] == 0) r = positions[p + 2];else r = Math.atan2(dy, dx);\n        r -= Math.atan2(c, a);\n\n        if (tip) {\n          cos = Math.cos(r);\n          sin = Math.sin(r);\n          let length = bone.data.length;\n          boneX += (length * (cos * a - sin * c) - dx) * mixRotate;\n          boneY += (length * (sin * a + cos * c) - dy) * mixRotate;\n        } else {\n          r += offsetRotation;\n        }\n\n        if (r > MathUtils.PI) r -= MathUtils.PI2;else if (r < -MathUtils.PI) //\n          r += MathUtils.PI2;\n        r *= mixRotate;\n        cos = Math.cos(r);\n        sin = Math.sin(r);\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n      }\n\n      bone.updateAppliedTransform();\n    }\n  }\n\n  computeWorldPositions(path, spacesCount, tangents) {\n    let target = this.target;\n    let position = this.position;\n    let spaces = this.spaces,\n        out = Utils.setArraySize(this.positions, spacesCount * 3 + 2),\n        world = null;\n    let closed = path.closed;\n    let verticesLength = path.worldVerticesLength,\n        curveCount = verticesLength / 6,\n        prevCurve = PathConstraint.NONE;\n\n    if (!path.constantSpeed) {\n      let lengths = path.lengths;\n      curveCount -= closed ? 1 : 2;\n      let pathLength = lengths[curveCount];\n      if (this.data.positionMode == PositionMode.Percent) position *= pathLength;\n      let multiplier;\n\n      switch (this.data.spacingMode) {\n        case SpacingMode.Percent:\n          multiplier = pathLength;\n          break;\n\n        case SpacingMode.Proportional:\n          multiplier = pathLength / spacesCount;\n          break;\n\n        default:\n          multiplier = 1;\n      }\n\n      world = Utils.setArraySize(this.world, 8);\n\n      for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n        let space = spaces[i] * multiplier;\n        position += space;\n        let p = position;\n\n        if (closed) {\n          p %= pathLength;\n          if (p < 0) p += pathLength;\n          curve = 0;\n        } else if (p < 0) {\n          if (prevCurve != PathConstraint.BEFORE) {\n            prevCurve = PathConstraint.BEFORE;\n            path.computeWorldVertices(target, 2, 4, world, 0, 2);\n          }\n\n          this.addBeforePosition(p, world, 0, out, o);\n          continue;\n        } else if (p > pathLength) {\n          if (prevCurve != PathConstraint.AFTER) {\n            prevCurve = PathConstraint.AFTER;\n            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n          }\n\n          this.addAfterPosition(p - pathLength, world, 0, out, o);\n          continue;\n        } // Determine curve containing position.\n\n\n        for (;; curve++) {\n          let length = lengths[curve];\n          if (p > length) continue;\n          if (curve == 0) p /= length;else {\n            let prev = lengths[curve - 1];\n            p = (p - prev) / (length - prev);\n          }\n          break;\n        }\n\n        if (curve != prevCurve) {\n          prevCurve = curve;\n\n          if (closed && curve == curveCount) {\n            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n            path.computeWorldVertices(target, 0, 4, world, 4, 2);\n          } else path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n        }\n\n        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);\n      }\n\n      return out;\n    } // World vertices.\n\n\n    if (closed) {\n      verticesLength += 2;\n      world = Utils.setArraySize(this.world, verticesLength);\n      path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n      path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n      world[verticesLength - 2] = world[0];\n      world[verticesLength - 1] = world[1];\n    } else {\n      curveCount--;\n      verticesLength -= 4;\n      world = Utils.setArraySize(this.world, verticesLength);\n      path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n    } // Curve lengths.\n\n\n    let curves = Utils.setArraySize(this.curves, curveCount);\n    let pathLength = 0;\n    let x1 = world[0],\n        y1 = world[1],\n        cx1 = 0,\n        cy1 = 0,\n        cx2 = 0,\n        cy2 = 0,\n        x2 = 0,\n        y2 = 0;\n    let tmpx = 0,\n        tmpy = 0,\n        dddfx = 0,\n        dddfy = 0,\n        ddfx = 0,\n        ddfy = 0,\n        dfx = 0,\n        dfy = 0;\n\n    for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n      cx1 = world[w];\n      cy1 = world[w + 1];\n      cx2 = world[w + 2];\n      cy2 = world[w + 3];\n      x2 = world[w + 4];\n      y2 = world[w + 5];\n      tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n      tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n      dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n      dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n      ddfx = tmpx * 2 + dddfx;\n      ddfy = tmpy * 2 + dddfy;\n      dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n      dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx;\n      dfy += ddfy;\n      ddfx += dddfx;\n      ddfy += dddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx;\n      dfy += ddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx + dddfx;\n      dfy += ddfy + dddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      curves[i] = pathLength;\n      x1 = x2;\n      y1 = y2;\n    }\n\n    if (this.data.positionMode == PositionMode.Percent) position *= pathLength;\n    let multiplier = 0;\n\n    switch (this.data.spacingMode) {\n      case SpacingMode.Percent:\n        multiplier = pathLength;\n        break;\n\n      case SpacingMode.Proportional:\n        multiplier = pathLength / spacesCount;\n        break;\n\n      default:\n        multiplier = 1;\n    }\n\n    let segments = this.segments;\n    let curveLength = 0;\n\n    for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n      let space = spaces[i] * multiplier;\n      position += space;\n      let p = position;\n\n      if (closed) {\n        p %= pathLength;\n        if (p < 0) p += pathLength;\n        curve = 0;\n      } else if (p < 0) {\n        this.addBeforePosition(p, world, 0, out, o);\n        continue;\n      } else if (p > pathLength) {\n        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n        continue;\n      } // Determine curve containing position.\n\n\n      for (;; curve++) {\n        let length = curves[curve];\n        if (p > length) continue;\n        if (curve == 0) p /= length;else {\n          let prev = curves[curve - 1];\n          p = (p - prev) / (length - prev);\n        }\n        break;\n      } // Curve segment lengths.\n\n\n      if (curve != prevCurve) {\n        prevCurve = curve;\n        let ii = curve * 6;\n        x1 = world[ii];\n        y1 = world[ii + 1];\n        cx1 = world[ii + 2];\n        cy1 = world[ii + 3];\n        cx2 = world[ii + 4];\n        cy2 = world[ii + 5];\n        x2 = world[ii + 6];\n        y2 = world[ii + 7];\n        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n        ddfx = tmpx * 2 + dddfx;\n        ddfy = tmpy * 2 + dddfy;\n        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[0] = curveLength;\n\n        for (ii = 1; ii < 8; ii++) {\n          dfx += ddfx;\n          dfy += ddfy;\n          ddfx += dddfx;\n          ddfy += dddfy;\n          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n          segments[ii] = curveLength;\n        }\n\n        dfx += ddfx;\n        dfy += ddfy;\n        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[8] = curveLength;\n        dfx += ddfx + dddfx;\n        dfy += ddfy + dddfy;\n        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[9] = curveLength;\n        segment = 0;\n      } // Weight by segment length.\n\n\n      p *= curveLength;\n\n      for (;; segment++) {\n        let length = segments[segment];\n        if (p > length) continue;\n        if (segment == 0) p /= length;else {\n          let prev = segments[segment - 1];\n          p = segment + (p - prev) / (length - prev);\n        }\n        break;\n      }\n\n      this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);\n    }\n\n    return out;\n  }\n\n  addBeforePosition(p, temp, i, out, o) {\n    let x1 = temp[i],\n        y1 = temp[i + 1],\n        dx = temp[i + 2] - x1,\n        dy = temp[i + 3] - y1,\n        r = Math.atan2(dy, dx);\n    out[o] = x1 + p * Math.cos(r);\n    out[o + 1] = y1 + p * Math.sin(r);\n    out[o + 2] = r;\n  }\n\n  addAfterPosition(p, temp, i, out, o) {\n    let x1 = temp[i + 2],\n        y1 = temp[i + 3],\n        dx = x1 - temp[i],\n        dy = y1 - temp[i + 1],\n        r = Math.atan2(dy, dx);\n    out[o] = x1 + p * Math.cos(r);\n    out[o + 1] = y1 + p * Math.sin(r);\n    out[o + 2] = r;\n  }\n\n  addCurvePosition(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {\n    if (p == 0 || isNaN(p)) {\n      out[o] = x1;\n      out[o + 1] = y1;\n      out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\n      return;\n    }\n\n    let tt = p * p,\n        ttt = tt * p,\n        u = 1 - p,\n        uu = u * u,\n        uuu = uu * u;\n    let ut = u * p,\n        ut3 = ut * 3,\n        uut3 = u * ut3,\n        utt3 = ut3 * p;\n    let x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt,\n        y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n    out[o] = x;\n    out[o + 1] = y;\n\n    if (tangents) {\n      if (p < 0.001) out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);else out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n    }\n  }\n\n}\n\nPathConstraint.__initStatic();\n\nPathConstraint.__initStatic2();\n\nPathConstraint.__initStatic3();\n\nPathConstraint.__initStatic4();\n/** Stores a slot's current pose. Slots organize attachments for {@link Skeleton#drawOrder} purposes and provide a place to store\r\n * state for an attachment. State cannot be stored in an attachment itself because attachments are stateless and may be shared\r\n * across multiple skeletons.\r\n * @public\r\n * */\n\n\nclass Slot {\n  //this is canon\n\n  /** The slot's setup pose data. */\n\n  /** The bone this slot belongs to. */\n\n  /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\r\n   * color tinting. */\n\n  /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\r\n   * color's alpha is not used. */\n\n  /** Values to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a\r\n   * weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.\r\n   *\r\n   * See {@link VertexAttachment#computeWorldVertices()} and {@link DeformTimeline}. */\n  __init() {\n    this.deform = new Array();\n  }\n\n  constructor(data, bone) {\n    Slot.prototype.__init.call(this);\n\n    if (data == null) throw new Error(\"data cannot be null.\");\n    if (bone == null) throw new Error(\"bone cannot be null.\");\n    this.data = data;\n    this.bone = bone;\n    this.color = new Color();\n    this.darkColor = data.darkColor == null ? null : new Color();\n    this.setToSetupPose();\n    this.blendMode = this.data.blendMode;\n  }\n  /** The skeleton this slot belongs to. */\n\n\n  getSkeleton() {\n    return this.bone.skeleton;\n  }\n  /** The current attachment for the slot, or null if the slot has no attachment. */\n\n\n  getAttachment() {\n    return this.attachment;\n  }\n  /** Sets the slot's attachment and, if the attachment changed, resets {@link #attachmentTime} and clears {@link #deform}.\r\n   * @param attachment May be null. */\n\n\n  setAttachment(attachment) {\n    if (this.attachment == attachment) return;\n    this.attachment = attachment;\n    this.attachmentTime = this.bone.skeleton.time;\n    this.deform.length = 0;\n  }\n\n  setAttachmentTime(time) {\n    this.attachmentTime = this.bone.skeleton.time - time;\n  }\n  /** The time that has elapsed since the last time the attachment was set or cleared. Relies on Skeleton\r\n   * {@link Skeleton#time}. */\n\n\n  getAttachmentTime() {\n    return this.bone.skeleton.time - this.attachmentTime;\n  }\n  /** Sets this slot to the setup pose. */\n\n\n  setToSetupPose() {\n    this.color.setFromColor(this.data.color);\n    if (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);\n    if (this.data.attachmentName == null) this.attachment = null;else {\n      this.attachment = null;\n      this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n    }\n  }\n\n}\n/** Stores the current pose for a transform constraint. A transform constraint adjusts the world transform of the constrained\n * bones to match that of the target bone.\n *\n * See [Transform constraints](http://esotericsoftware.com/spine-transform-constraints) in the Spine User Guide.\n * @public\n * */\n\n\nclass TransformConstraint {\n  /** The transform constraint's setup pose data. */\n\n  /** The bones that will be modified by this transform constraint. */\n\n  /** The target bone whose world transform will be copied to the constrained bones. */\n  __init() {\n    this.mixRotate = 0;\n  }\n\n  __init2() {\n    this.mixX = 0;\n  }\n\n  __init3() {\n    this.mixY = 0;\n  }\n\n  __init4() {\n    this.mixScaleX = 0;\n  }\n\n  __init5() {\n    this.mixScaleY = 0;\n  }\n\n  __init6() {\n    this.mixShearY = 0;\n  }\n\n  __init7() {\n    this.temp = new Vector2();\n  }\n\n  __init8() {\n    this.active = false;\n  }\n\n  constructor(data, skeleton) {\n    TransformConstraint.prototype.__init.call(this);\n\n    TransformConstraint.prototype.__init2.call(this);\n\n    TransformConstraint.prototype.__init3.call(this);\n\n    TransformConstraint.prototype.__init4.call(this);\n\n    TransformConstraint.prototype.__init5.call(this);\n\n    TransformConstraint.prototype.__init6.call(this);\n\n    TransformConstraint.prototype.__init7.call(this);\n\n    TransformConstraint.prototype.__init8.call(this);\n\n    if (!data) throw new Error(\"data cannot be null.\");\n    if (!skeleton) throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.mixRotate = data.mixRotate;\n    this.mixX = data.mixX;\n    this.mixY = data.mixY;\n    this.mixScaleX = data.mixScaleX;\n    this.mixScaleY = data.mixScaleY;\n    this.mixShearY = data.mixShearY;\n    this.bones = new Array();\n\n    for (let i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n\n    this.target = skeleton.findBone(data.target.name);\n  }\n\n  isActive() {\n    return this.active;\n  }\n\n  update() {\n    if (this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleX == 0 && this.mixShearY == 0) return;\n\n    if (this.data.local) {\n      if (this.data.relative) this.applyRelativeLocal();else this.applyAbsoluteLocal();\n    } else {\n      if (this.data.relative) this.applyRelativeWorld();else this.applyAbsoluteWorld();\n    }\n  }\n\n  applyAbsoluteWorld() {\n    let mixRotate = this.mixRotate,\n        mixX = this.mixX,\n        mixY = this.mixY,\n        mixScaleX = this.mixScaleX,\n        mixScaleY = this.mixScaleY,\n        mixShearY = this.mixShearY;\n    let translate = mixX != 0 || mixY != 0;\n    let target = this.target;\n    const targetMat = target.matrix;\n    let ta = targetMat.a,\n        tb = targetMat.c,\n        tc = targetMat.b,\n        td = targetMat.d;\n    let degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    let offsetRotation = this.data.offsetRotation * degRadReflect;\n    let offsetShearY = this.data.offsetShearY * degRadReflect;\n    let bones = this.bones;\n\n    for (let i = 0, n = bones.length; i < n; i++) {\n      let bone = bones[i];\n      const mat = bone.matrix;\n\n      if (mixRotate != 0) {\n        let a = mat.a,\n            b = mat.c,\n            c = mat.b,\n            d = mat.d;\n        let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n        if (r > MathUtils.PI) r -= MathUtils.PI2;else if (r < -MathUtils.PI) //\n          r += MathUtils.PI2;\n        r *= mixRotate;\n        let cos = Math.cos(r),\n            sin = Math.sin(r);\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n      }\n\n      if (translate) {\n        let temp = this.temp;\n        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n        mat.tx += (temp.x - mat.tx) * mixX;\n        mat.ty += (temp.y - mat.ty) * mixY;\n      }\n\n      if (mixScaleX != 0) {\n        let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\n        if (s != 0) s = (s + (Math.sqrt(ta * ta + tc * tc) - s + this.data.offsetScaleX) * mixScaleX) / s;\n        mat.a *= s;\n        mat.b *= s;\n      }\n\n      if (mixScaleY != 0) {\n        let s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\n        if (s != 0) s = (s + (Math.sqrt(tb * tb + td * td) - s + this.data.offsetScaleY) * mixScaleY) / s;\n        mat.c *= s;\n        mat.d *= s;\n      }\n\n      if (mixShearY > 0) {\n        let b = mat.c,\n            d = mat.d;\n        let by = Math.atan2(d, b);\n        let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\n        if (r > MathUtils.PI) r -= MathUtils.PI2;else if (r < -MathUtils.PI) //\n          r += MathUtils.PI2;\n        r = by + (r + offsetShearY) * mixShearY;\n        let s = Math.sqrt(b * b + d * d);\n        mat.c = Math.cos(r) * s;\n        mat.d = Math.sin(r) * s;\n      }\n\n      bone.updateAppliedTransform();\n    }\n  }\n\n  applyRelativeWorld() {\n    let mixRotate = this.mixRotate,\n        mixX = this.mixX,\n        mixY = this.mixY,\n        mixScaleX = this.mixScaleX,\n        mixScaleY = this.mixScaleY,\n        mixShearY = this.mixShearY;\n    let translate = mixX != 0 || mixY != 0;\n    let target = this.target;\n    let targetMat = target.matrix;\n    let ta = targetMat.a,\n        tb = targetMat.c,\n        tc = targetMat.b,\n        td = targetMat.d;\n    let degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    let offsetRotation = this.data.offsetRotation * degRadReflect,\n        offsetShearY = this.data.offsetShearY * degRadReflect;\n    let bones = this.bones;\n\n    for (let i = 0, n = bones.length; i < n; i++) {\n      let bone = bones[i];\n      const mat = bone.matrix;\n\n      if (mixRotate != 0) {\n        let a = mat.a,\n            b = mat.c,\n            c = mat.b,\n            d = mat.d;\n        let r = Math.atan2(tc, ta) + offsetRotation;\n        if (r > MathUtils.PI) r -= MathUtils.PI2;else if (r < -MathUtils.PI) //\n          r += MathUtils.PI2;\n        r *= mixRotate;\n        let cos = Math.cos(r),\n            sin = Math.sin(r);\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n      }\n\n      if (translate) {\n        let temp = this.temp;\n        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n        mat.tx += temp.x * mixX;\n        mat.ty += temp.y * mixY;\n      }\n\n      if (mixScaleX != 0) {\n        let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * mixScaleX + 1;\n        mat.a *= s;\n        mat.b *= s;\n      }\n\n      if (mixScaleY != 0) {\n        let s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * mixScaleY + 1;\n        mat.c *= s;\n        mat.d *= s;\n      }\n\n      if (mixShearY > 0) {\n        let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n        if (r > MathUtils.PI) r -= MathUtils.PI2;else if (r < -MathUtils.PI) //\n          r += MathUtils.PI2;\n        let b = mat.c,\n            d = mat.d;\n        r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * mixShearY;\n        let s = Math.sqrt(b * b + d * d);\n        mat.c = Math.cos(r) * s;\n        mat.d = Math.sin(r) * s;\n      }\n\n      bone.updateAppliedTransform();\n    }\n  }\n\n  applyAbsoluteLocal() {\n    let mixRotate = this.mixRotate,\n        mixX = this.mixX,\n        mixY = this.mixY,\n        mixScaleX = this.mixScaleX,\n        mixScaleY = this.mixScaleY,\n        mixShearY = this.mixShearY;\n    let target = this.target;\n    let bones = this.bones;\n\n    for (let i = 0, n = bones.length; i < n; i++) {\n      let bone = bones[i];\n      let rotation = bone.arotation;\n\n      if (mixRotate != 0) {\n        let r = target.arotation - rotation + this.data.offsetRotation;\n        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n        rotation += r * mixRotate;\n      }\n\n      let x = bone.ax,\n          y = bone.ay;\n      x += (target.ax - x + this.data.offsetX) * mixX;\n      y += (target.ay - y + this.data.offsetY) * mixY;\n      let scaleX = bone.ascaleX,\n          scaleY = bone.ascaleY;\n      if (mixScaleX != 0 && scaleX != 0) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * mixScaleX) / scaleX;\n      if (mixScaleY != 0 && scaleY != 0) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * mixScaleY) / scaleY;\n      let shearY = bone.ashearY;\n\n      if (mixShearY != 0) {\n        let r = target.ashearY - shearY + this.data.offsetShearY;\n        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n        shearY += r * mixShearY;\n      }\n\n      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n    }\n  }\n\n  applyRelativeLocal() {\n    let mixRotate = this.mixRotate,\n        mixX = this.mixX,\n        mixY = this.mixY,\n        mixScaleX = this.mixScaleX,\n        mixScaleY = this.mixScaleY,\n        mixShearY = this.mixShearY;\n    let target = this.target;\n    let bones = this.bones;\n\n    for (let i = 0, n = bones.length; i < n; i++) {\n      let bone = bones[i];\n      let rotation = bone.arotation + (target.arotation + this.data.offsetRotation) * mixRotate;\n      let x = bone.ax + (target.ax + this.data.offsetX) * mixX;\n      let y = bone.ay + (target.ay + this.data.offsetY) * mixY;\n      let scaleX = bone.ascaleX * ((target.ascaleX - 1 + this.data.offsetScaleX) * mixScaleX) + 1;\n      let scaleY = bone.ascaleY * ((target.ascaleY - 1 + this.data.offsetScaleY) * mixScaleY) + 1;\n      let shearY = bone.ashearY + (target.ashearY + this.data.offsetShearY) * mixShearY;\n      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n    }\n  }\n\n}\n/** Stores the current pose for a skeleton.\n *\n * See [Instance objects](http://esotericsoftware.com/spine-runtime-architecture#Instance-objects) in the Spine Runtimes Guide.\n * @public\n * */\n\n\nclass Skeleton {\n  /** The skeleton's setup pose data. */\n\n  /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\n\n  /** The skeleton's slots. */\n\n  /** The skeleton's slots in the order they should be drawn. The returned array may be modified to change the draw order. */\n\n  /** The skeleton's IK constraints. */\n\n  /** The skeleton's transform constraints. */\n\n  /** The skeleton's path constraints. */\n\n  /** The list of bones and constraints, sorted in the order they should be updated, as computed by {@link #updateCache()}. */\n  __init() {\n    this._updateCache = new Array();\n  }\n  /** The skeleton's current skin. May be null. */\n\n  /** The color to tint all the skeleton's attachments. */\n\n  /** Returns the skeleton's time. This can be used for tracking, such as with Slot {@link Slot#attachmentTime}.\n   * <p>\n   * See {@link #update()}. */\n\n\n  __init2() {\n    this.time = 0;\n  }\n  /** Scales the entire skeleton on the X axis. This affects all bones, even if the bone's transform mode disallows scale\n   * inheritance. */\n\n\n  __init3() {\n    this.scaleX = 1;\n  }\n  /** Scales the entire skeleton on the Y axis. This affects all bones, even if the bone's transform mode disallows scale\n   * inheritance. */\n\n\n  __init4() {\n    this.scaleY = 1;\n  }\n  /** Sets the skeleton X position, which is added to the root bone worldX position. */\n\n\n  __init5() {\n    this.x = 0;\n  }\n  /** Sets the skeleton Y position, which is added to the root bone worldY position. */\n\n\n  __init6() {\n    this.y = 0;\n  }\n\n  constructor(data) {\n    Skeleton.prototype.__init.call(this);\n\n    Skeleton.prototype.__init2.call(this);\n\n    Skeleton.prototype.__init3.call(this);\n\n    Skeleton.prototype.__init4.call(this);\n\n    Skeleton.prototype.__init5.call(this);\n\n    Skeleton.prototype.__init6.call(this);\n\n    if (!data) throw new Error(\"data cannot be null.\");\n    this.data = data;\n    this.bones = new Array();\n\n    for (let i = 0; i < data.bones.length; i++) {\n      let boneData = data.bones[i];\n      let bone;\n      if (!boneData.parent) bone = new Bone(boneData, this, null);else {\n        let parent = this.bones[boneData.parent.index];\n        bone = new Bone(boneData, this, parent);\n        parent.children.push(bone);\n      }\n      this.bones.push(bone);\n    }\n\n    this.slots = new Array();\n    this.drawOrder = new Array();\n\n    for (let i = 0; i < data.slots.length; i++) {\n      let slotData = data.slots[i];\n      let bone = this.bones[slotData.boneData.index];\n      let slot = new Slot(slotData, bone);\n      this.slots.push(slot);\n      this.drawOrder.push(slot);\n    }\n\n    this.ikConstraints = new Array();\n\n    for (let i = 0; i < data.ikConstraints.length; i++) {\n      let ikConstraintData = data.ikConstraints[i];\n      this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n    }\n\n    this.transformConstraints = new Array();\n\n    for (let i = 0; i < data.transformConstraints.length; i++) {\n      let transformConstraintData = data.transformConstraints[i];\n      this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n    }\n\n    this.pathConstraints = new Array();\n\n    for (let i = 0; i < data.pathConstraints.length; i++) {\n      let pathConstraintData = data.pathConstraints[i];\n      this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n    }\n\n    this.color = new Color(1, 1, 1, 1);\n    this.updateCache();\n  }\n  /** Caches information about bones and constraints. Must be called if the {@link #getSkin()} is modified or if bones,\n   * constraints, or weighted path attachments are added or removed. */\n\n\n  updateCache() {\n    let updateCache = this._updateCache;\n    updateCache.length = 0;\n    let bones = this.bones;\n\n    for (let i = 0, n = bones.length; i < n; i++) {\n      let bone = bones[i];\n      bone.sorted = bone.data.skinRequired;\n      bone.active = !bone.sorted;\n    }\n\n    if (this.skin) {\n      let skinBones = this.skin.bones;\n\n      for (let i = 0, n = this.skin.bones.length; i < n; i++) {\n        let bone = this.bones[skinBones[i].index];\n\n        do {\n          bone.sorted = false;\n          bone.active = true;\n          bone = bone.parent;\n        } while (bone);\n      }\n    } // IK first, lowest hierarchy depth first.\n\n\n    let ikConstraints = this.ikConstraints;\n    let transformConstraints = this.transformConstraints;\n    let pathConstraints = this.pathConstraints;\n    let ikCount = ikConstraints.length,\n        transformCount = transformConstraints.length,\n        pathCount = pathConstraints.length;\n    let constraintCount = ikCount + transformCount + pathCount;\n\n    outer: for (let i = 0; i < constraintCount; i++) {\n      for (let ii = 0; ii < ikCount; ii++) {\n        let constraint = ikConstraints[ii];\n\n        if (constraint.data.order == i) {\n          this.sortIkConstraint(constraint);\n          continue outer;\n        }\n      }\n\n      for (let ii = 0; ii < transformCount; ii++) {\n        let constraint = transformConstraints[ii];\n\n        if (constraint.data.order == i) {\n          this.sortTransformConstraint(constraint);\n          continue outer;\n        }\n      }\n\n      for (let ii = 0; ii < pathCount; ii++) {\n        let constraint = pathConstraints[ii];\n\n        if (constraint.data.order == i) {\n          this.sortPathConstraint(constraint);\n          continue outer;\n        }\n      }\n    }\n\n    for (let i = 0, n = bones.length; i < n; i++) this.sortBone(bones[i]);\n  }\n\n  sortIkConstraint(constraint) {\n    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));\n    if (!constraint.active) return;\n    let target = constraint.target;\n    this.sortBone(target);\n    let constrained = constraint.bones;\n    let parent = constrained[0];\n    this.sortBone(parent);\n\n    if (constrained.length == 1) {\n      this._updateCache.push(constraint);\n\n      this.sortReset(parent.children);\n    } else {\n      let child = constrained[constrained.length - 1];\n      this.sortBone(child);\n\n      this._updateCache.push(constraint);\n\n      this.sortReset(parent.children);\n      child.sorted = true;\n    }\n  }\n\n  sortPathConstraint(constraint) {\n    constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));\n    if (!constraint.active) return;\n    let slot = constraint.target;\n    let slotIndex = slot.data.index;\n    let slotBone = slot.bone;\n    if (this.skin) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n    if (this.data.defaultSkin && this.data.defaultSkin != this.skin) this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n\n    for (let i = 0, n = this.data.skins.length; i < n; i++) this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n\n    let attachment = slot.getAttachment();\n    if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n    let constrained = constraint.bones;\n    let boneCount = constrained.length;\n\n    for (let i = 0; i < boneCount; i++) this.sortBone(constrained[i]);\n\n    this._updateCache.push(constraint);\n\n    for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\n\n    for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\n  }\n\n  sortTransformConstraint(constraint) {\n    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));\n    if (!constraint.active) return;\n    this.sortBone(constraint.target);\n    let constrained = constraint.bones;\n    let boneCount = constrained.length;\n\n    if (constraint.data.local) {\n      for (let i = 0; i < boneCount; i++) {\n        let child = constrained[i];\n        this.sortBone(child.parent);\n        this.sortBone(child);\n      }\n    } else {\n      for (let i = 0; i < boneCount; i++) {\n        this.sortBone(constrained[i]);\n      }\n    }\n\n    this._updateCache.push(constraint);\n\n    for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\n\n    for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\n  }\n\n  sortPathConstraintAttachment(skin, slotIndex, slotBone) {\n    let attachments = skin.attachments[slotIndex];\n    if (!attachments) return;\n\n    for (let key in attachments) {\n      this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n    }\n  }\n\n  sortPathConstraintAttachmentWith(attachment, slotBone) {\n    if (!(attachment instanceof PathAttachment)) return;\n    let pathBones = attachment.bones;\n    if (!pathBones) this.sortBone(slotBone);else {\n      let bones = this.bones;\n\n      for (let i = 0, n = pathBones.length; i < n;) {\n        let nn = pathBones[i++];\n        nn += i;\n\n        while (i < nn) this.sortBone(bones[pathBones[i++]]);\n      }\n    }\n  }\n\n  sortBone(bone) {\n    if (bone.sorted) return;\n    let parent = bone.parent;\n    if (parent) this.sortBone(parent);\n    bone.sorted = true;\n\n    this._updateCache.push(bone);\n  }\n\n  sortReset(bones) {\n    for (let i = 0, n = bones.length; i < n; i++) {\n      let bone = bones[i];\n      if (!bone.active) continue;\n      if (bone.sorted) this.sortReset(bone.children);\n      bone.sorted = false;\n    }\n  }\n  /** Updates the world transform for each bone and applies all constraints.\n   *\n   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n   * Runtimes Guide. */\n\n\n  updateWorldTransform() {\n    let bones = this.bones;\n\n    for (let i = 0, n = bones.length; i < n; i++) {\n      let bone = bones[i];\n      bone.ax = bone.x;\n      bone.ay = bone.y;\n      bone.arotation = bone.rotation;\n      bone.ascaleX = bone.scaleX;\n      bone.ascaleY = bone.scaleY;\n      bone.ashearX = bone.shearX;\n      bone.ashearY = bone.shearY;\n    }\n\n    let updateCache = this._updateCache;\n\n    for (let i = 0, n = updateCache.length; i < n; i++) updateCache[i].update();\n  }\n\n  updateWorldTransformWith(parent) {\n    // Apply the parent bone transform to the root bone. The root bone always inherits scale, rotation and reflection.\n    let rootBone = this.getRootBone();\n    let pa = parent.matrix.a,\n        pb = parent.matrix.c,\n        pc = parent.matrix.b,\n        pd = parent.matrix.d;\n    rootBone.matrix.tx = pa * this.x + pb * this.y + parent.worldX;\n    rootBone.matrix.ty = pc * this.x + pd * this.y + parent.worldY;\n    let rotationY = rootBone.rotation + 90 + rootBone.shearY;\n    let la = MathUtils.cosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\n    let lb = MathUtils.cosDeg(rotationY) * rootBone.scaleY;\n    let lc = MathUtils.sinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\n    let ld = MathUtils.sinDeg(rotationY) * rootBone.scaleY;\n    const sx = this.scaleX;\n    const sy = settings.yDown ? -this.scaleY : this.scaleY;\n    rootBone.matrix.a = (pa * la + pb * lc) * sx;\n    rootBone.matrix.c = (pa * lb + pb * ld) * sx;\n    rootBone.matrix.b = (pc * la + pd * lc) * sy;\n    rootBone.matrix.d = (pc * lb + pd * ld) * sy; // Update everything except root bone.\n\n    let updateCache = this._updateCache;\n\n    for (let i = 0, n = updateCache.length; i < n; i++) {\n      let updatable = updateCache[i];\n      if (updatable != rootBone) updatable.update();\n    }\n  }\n  /** Sets the bones, constraints, and slots to their setup pose values. */\n\n\n  setToSetupPose() {\n    this.setBonesToSetupPose();\n    this.setSlotsToSetupPose();\n  }\n  /** Sets the bones and constraints to their setup pose values. */\n\n\n  setBonesToSetupPose() {\n    let bones = this.bones;\n\n    for (let i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose();\n\n    let ikConstraints = this.ikConstraints;\n\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      let constraint = ikConstraints[i];\n      constraint.mix = constraint.data.mix;\n      constraint.softness = constraint.data.softness;\n      constraint.bendDirection = constraint.data.bendDirection;\n      constraint.compress = constraint.data.compress;\n      constraint.stretch = constraint.data.stretch;\n    }\n\n    let transformConstraints = this.transformConstraints;\n\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      let constraint = transformConstraints[i];\n      let data = constraint.data;\n      constraint.mixRotate = data.mixRotate;\n      constraint.mixX = data.mixX;\n      constraint.mixY = data.mixY;\n      constraint.mixScaleX = data.mixScaleX;\n      constraint.mixScaleY = data.mixScaleY;\n      constraint.mixShearY = data.mixShearY;\n    }\n\n    let pathConstraints = this.pathConstraints;\n\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      let constraint = pathConstraints[i];\n      let data = constraint.data;\n      constraint.position = data.position;\n      constraint.spacing = data.spacing;\n      constraint.mixRotate = data.mixRotate;\n      constraint.mixX = data.mixX;\n      constraint.mixY = data.mixY;\n    }\n  }\n  /** Sets the slots and draw order to their setup pose values. */\n\n\n  setSlotsToSetupPose() {\n    let slots = this.slots;\n    Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n\n    for (let i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose();\n  }\n  /** @returns May return null. */\n\n\n  getRootBone() {\n    if (this.bones.length == 0) return null;\n    return this.bones[0];\n  }\n  /** @returns May be null. */\n\n\n  findBone(boneName) {\n    if (!boneName) throw new Error(\"boneName cannot be null.\");\n    let bones = this.bones;\n\n    for (let i = 0, n = bones.length; i < n; i++) {\n      let bone = bones[i];\n      if (bone.data.name == boneName) return bone;\n    }\n\n    return null;\n  }\n  /** @returns -1 if the bone was not found. */\n\n\n  findBoneIndex(boneName) {\n    if (!boneName) throw new Error(\"boneName cannot be null.\");\n    let bones = this.bones;\n\n    for (let i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return i;\n\n    return -1;\n  }\n  /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\n   * repeatedly.\n   * @returns May be null. */\n\n\n  findSlot(slotName) {\n    if (!slotName) throw new Error(\"slotName cannot be null.\");\n    let slots = this.slots;\n\n    for (let i = 0, n = slots.length; i < n; i++) {\n      let slot = slots[i];\n      if (slot.data.name == slotName) return slot;\n    }\n\n    return null;\n  }\n  /** @returns -1 if the bone was not found. */\n\n\n  findSlotIndex(slotName) {\n    if (!slotName) throw new Error(\"slotName cannot be null.\");\n    let slots = this.slots;\n\n    for (let i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return i;\n\n    return -1;\n  }\n  /** Sets a skin by name.\n   *\n   * See {@link #setSkin()}. */\n\n\n  setSkinByName(skinName) {\n    let skin = this.data.findSkin(skinName);\n    if (!skin) throw new Error(\"Skin not found: \" + skinName);\n    this.setSkin(skin);\n  }\n  /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#defaultSkin default skin}. If the\n   * skin is changed, {@link #updateCache()} is called.\n   *\n   * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n   * old skin, each slot's setup mode attachment is attached from the new skin.\n   *\n   * After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling\n   * {@link #setSlotsToSetupPose()}. Also, often {@link AnimationState#apply()} is called before the next time the\n   * skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.\n   * @param newSkin May be null. */\n\n\n  setSkin(newSkin) {\n    if (newSkin == this.skin) return;\n\n    if (newSkin) {\n      if (this.skin) newSkin.attachAll(this, this.skin);else {\n        let slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n          let slot = slots[i];\n          let name = slot.data.attachmentName;\n\n          if (name) {\n            let attachment = newSkin.getAttachment(i, name);\n            if (attachment) slot.setAttachment(attachment);\n          }\n        }\n      }\n    }\n\n    this.skin = newSkin;\n    this.updateCache();\n  }\n  /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment\n   * name.\n   *\n   * See {@link #getAttachment()}.\n   * @returns May be null. */\n\n\n  getAttachmentByName(slotName, attachmentName) {\n    return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n  }\n  /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot index and\n   * attachment name. First the skin is checked and if the attachment was not found, the default skin is checked.\n   *\n   * See [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\n   * @returns May be null. */\n\n\n  getAttachment(slotIndex, attachmentName) {\n    if (!attachmentName) throw new Error(\"attachmentName cannot be null.\");\n\n    if (this.skin) {\n      let attachment = this.skin.getAttachment(slotIndex, attachmentName);\n      if (attachment) return attachment;\n    }\n\n    if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n    return null;\n  }\n  /** A convenience method to set an attachment by finding the slot with {@link #findSlot()}, finding the attachment with\n   * {@link #getAttachment()}, then setting the slot's {@link Slot#attachment}.\n   * @param attachmentName May be null to clear the slot's attachment. */\n\n\n  setAttachment(slotName, attachmentName) {\n    if (!slotName) throw new Error(\"slotName cannot be null.\");\n    let slots = this.slots;\n\n    for (let i = 0, n = slots.length; i < n; i++) {\n      let slot = slots[i];\n\n      if (slot.data.name == slotName) {\n        let attachment = null;\n\n        if (attachmentName) {\n          attachment = this.getAttachment(i, attachmentName);\n          if (!attachment) throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\n        }\n\n        slot.setAttachment(attachment);\n        return;\n      }\n    }\n\n    throw new Error(\"Slot not found: \" + slotName);\n  }\n  /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\n   * than to call it repeatedly.\n   * @return May be null. */\n\n\n  findIkConstraint(constraintName) {\n    if (!constraintName) throw new Error(\"constraintName cannot be null.\");\n    let ikConstraints = this.ikConstraints;\n\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      let ikConstraint = ikConstraints[i];\n      if (ikConstraint.data.name == constraintName) return ikConstraint;\n    }\n\n    return null;\n  }\n  /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\n   * this method than to call it repeatedly.\n   * @return May be null. */\n\n\n  findTransformConstraint(constraintName) {\n    if (!constraintName) throw new Error(\"constraintName cannot be null.\");\n    let transformConstraints = this.transformConstraints;\n\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      let constraint = transformConstraints[i];\n      if (constraint.data.name == constraintName) return constraint;\n    }\n\n    return null;\n  }\n  /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\n   * than to call it repeatedly.\n   * @return May be null. */\n\n\n  findPathConstraint(constraintName) {\n    if (!constraintName) throw new Error(\"constraintName cannot be null.\");\n    let pathConstraints = this.pathConstraints;\n\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      let constraint = pathConstraints[i];\n      if (constraint.data.name == constraintName) return constraint;\n    }\n\n    return null;\n  }\n  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n   * @param offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.\n   * @param size An output value, the width and height of the AABB.\n   * @param temp Working memory to temporarily store attachments' computed world vertices. */\n\n\n  getBounds(offset, size, temp = new Array(2)) {\n    if (!offset) throw new Error(\"offset cannot be null.\");\n    if (!size) throw new Error(\"size cannot be null.\");\n    let drawOrder = this.drawOrder;\n    let minX = Number.POSITIVE_INFINITY,\n        minY = Number.POSITIVE_INFINITY,\n        maxX = Number.NEGATIVE_INFINITY,\n        maxY = Number.NEGATIVE_INFINITY;\n\n    for (let i = 0, n = drawOrder.length; i < n; i++) {\n      let slot = drawOrder[i];\n      if (!slot.bone.active) continue;\n      let verticesLength = 0;\n      let vertices = null;\n      let attachment = slot.getAttachment();\n\n      if (attachment instanceof RegionAttachment) {\n        verticesLength = 8;\n        vertices = Utils.setArraySize(temp, verticesLength, 0);\n        attachment.computeWorldVertices(slot.bone, vertices, 0, 2);\n      } else if (attachment instanceof MeshAttachment) {\n        let mesh = attachment;\n        verticesLength = mesh.worldVerticesLength;\n        vertices = Utils.setArraySize(temp, verticesLength, 0);\n        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n      }\n\n      if (vertices) {\n        for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n          let x = vertices[ii],\n              y = vertices[ii + 1];\n          minX = Math.min(minX, x);\n          minY = Math.min(minY, y);\n          maxX = Math.max(maxX, x);\n          maxY = Math.max(maxY, y);\n        }\n      }\n    }\n\n    offset.set(minX, minY);\n    size.set(maxX - minX, maxY - minY);\n  }\n  /** Increments the skeleton's {@link #time}. */\n\n\n  update(delta) {\n    this.time += delta;\n  }\n\n  get flipX() {\n    return this.scaleX == -1;\n  }\n\n  set flipX(value) {\n    if (!Skeleton.deprecatedWarning1) {\n      Skeleton.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\n    }\n\n    this.scaleX = value ? 1.0 : -1.0;\n  }\n\n  get flipY() {\n    return this.scaleY == -1;\n  }\n\n  set flipY(value) {\n    if (!Skeleton.deprecatedWarning1) {\n      Skeleton.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\n    }\n\n    this.scaleY = value ? 1.0 : -1.0;\n  }\n\n  static __initStatic() {\n    this.deprecatedWarning1 = false;\n  }\n\n}\n\nSkeleton.__initStatic();\n/** Stores the setup pose and all of the stateless data for a skeleton.\r\n *\r\n * See [Data objects](http://esotericsoftware.com/spine-runtime-architecture#Data-objects) in the Spine Runtimes\r\n * Guide.\r\n * @public\r\n * */\n\n\nclass SkeletonData {\n  constructor() {\n    SkeletonData.prototype.__init.call(this);\n\n    SkeletonData.prototype.__init2.call(this);\n\n    SkeletonData.prototype.__init3.call(this);\n\n    SkeletonData.prototype.__init4.call(this);\n\n    SkeletonData.prototype.__init5.call(this);\n\n    SkeletonData.prototype.__init6.call(this);\n\n    SkeletonData.prototype.__init7.call(this);\n\n    SkeletonData.prototype.__init8.call(this);\n\n    SkeletonData.prototype.__init9.call(this);\n  }\n  /** The skeleton's name, which by default is the name of the skeleton data file, if possible. May be null. */\n\n  /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\n\n\n  __init() {\n    this.bones = new Array();\n  } // Ordered parents first.\n\n  /** The skeleton's slots. */\n\n\n  __init2() {\n    this.slots = new Array();\n  } // Setup pose draw order.\n\n\n  __init3() {\n    this.skins = new Array();\n  }\n  /** The skeleton's default skin. By default this skin contains all attachments that were not in a skin in Spine.\r\n   *\r\n   * See {@link Skeleton#getAttachmentByName()}.\r\n   * May be null. */\n\n  /** The skeleton's events. */\n\n\n  __init4() {\n    this.events = new Array();\n  }\n  /** The skeleton's animations. */\n\n\n  __init5() {\n    this.animations = new Array();\n  }\n  /** The skeleton's IK constraints. */\n\n\n  __init6() {\n    this.ikConstraints = new Array();\n  }\n  /** The skeleton's transform constraints. */\n\n\n  __init7() {\n    this.transformConstraints = new Array();\n  }\n  /** The skeleton's path constraints. */\n\n\n  __init8() {\n    this.pathConstraints = new Array();\n  }\n  /** The X coordinate of the skeleton's axis aligned bounding box in the setup pose. */\n\n  /** The Y coordinate of the skeleton's axis aligned bounding box in the setup pose. */\n\n  /** The width of the skeleton's axis aligned bounding box in the setup pose. */\n\n  /** The height of the skeleton's axis aligned bounding box in the setup pose. */\n\n  /** The Spine version used to export the skeleton data, or null. */\n\n  /** The skeleton data hash. This value will change if any of the skeleton data has changed. May be null. */\n  // Nonessential\n\n  /** The dopesheet FPS in Spine. Available only when nonessential data was exported. */\n\n\n  __init9() {\n    this.fps = 0;\n  }\n  /** The path to the images directory as defined in Spine. Available only when nonessential data was exported. May be null. */\n\n  /** The path to the audio directory as defined in Spine. Available only when nonessential data was exported. May be null. */\n\n  /** Finds a bone by comparing each bone's name. It is more efficient to cache the results of this method than to call it\r\n   * multiple times.\r\n   * @returns May be null. */\n\n\n  findBone(boneName) {\n    if (!boneName) throw new Error(\"boneName cannot be null.\");\n    let bones = this.bones;\n\n    for (let i = 0, n = bones.length; i < n; i++) {\n      let bone = bones[i];\n      if (bone.name == boneName) return bone;\n    }\n\n    return null;\n  }\n\n  findBoneIndex(boneName) {\n    if (!boneName) throw new Error(\"boneName cannot be null.\");\n    let bones = this.bones;\n\n    for (let i = 0, n = bones.length; i < n; i++) if (bones[i].name == boneName) return i;\n\n    return -1;\n  }\n  /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\r\n   * multiple times.\r\n   * @returns May be null. */\n\n\n  findSlot(slotName) {\n    if (!slotName) throw new Error(\"slotName cannot be null.\");\n    let slots = this.slots;\n\n    for (let i = 0, n = slots.length; i < n; i++) {\n      let slot = slots[i];\n      if (slot.name == slotName) return slot;\n    }\n\n    return null;\n  }\n\n  findSlotIndex(slotName) {\n    if (!slotName) throw new Error(\"slotName cannot be null.\");\n    let slots = this.slots;\n\n    for (let i = 0, n = slots.length; i < n; i++) if (slots[i].name == slotName) return i;\n\n    return -1;\n  }\n  /** Finds a skin by comparing each skin's name. It is more efficient to cache the results of this method than to call it\r\n   * multiple times.\r\n   * @returns May be null. */\n\n\n  findSkin(skinName) {\n    if (!skinName) throw new Error(\"skinName cannot be null.\");\n    let skins = this.skins;\n\n    for (let i = 0, n = skins.length; i < n; i++) {\n      let skin = skins[i];\n      if (skin.name == skinName) return skin;\n    }\n\n    return null;\n  }\n  /** Finds an event by comparing each events's name. It is more efficient to cache the results of this method than to call it\r\n   * multiple times.\r\n   * @returns May be null. */\n\n\n  findEvent(eventDataName) {\n    if (!eventDataName) throw new Error(\"eventDataName cannot be null.\");\n    let events = this.events;\n\n    for (let i = 0, n = events.length; i < n; i++) {\n      let event = events[i];\n      if (event.name == eventDataName) return event;\n    }\n\n    return null;\n  }\n  /** Finds an animation by comparing each animation's name. It is more efficient to cache the results of this method than to\r\n   * call it multiple times.\r\n   * @returns May be null. */\n\n\n  findAnimation(animationName) {\n    if (!animationName) throw new Error(\"animationName cannot be null.\");\n    let animations = this.animations;\n\n    for (let i = 0, n = animations.length; i < n; i++) {\n      let animation = animations[i];\n      if (animation.name == animationName) return animation;\n    }\n\n    return null;\n  }\n  /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\r\n   * than to call it multiple times.\r\n   * @return May be null. */\n\n\n  findIkConstraint(constraintName) {\n    if (!constraintName) throw new Error(\"constraintName cannot be null.\");\n    let ikConstraints = this.ikConstraints;\n\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      let constraint = ikConstraints[i];\n      if (constraint.name == constraintName) return constraint;\n    }\n\n    return null;\n  }\n  /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\r\n   * this method than to call it multiple times.\r\n   * @return May be null. */\n\n\n  findTransformConstraint(constraintName) {\n    if (!constraintName) throw new Error(\"constraintName cannot be null.\");\n    let transformConstraints = this.transformConstraints;\n\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      let constraint = transformConstraints[i];\n      if (constraint.name == constraintName) return constraint;\n    }\n\n    return null;\n  }\n  /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\r\n   * than to call it multiple times.\r\n   * @return May be null. */\n\n\n  findPathConstraint(constraintName) {\n    if (!constraintName) throw new Error(\"constraintName cannot be null.\");\n    let pathConstraints = this.pathConstraints;\n\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      let constraint = pathConstraints[i];\n      if (constraint.name == constraintName) return constraint;\n    }\n\n    return null;\n  }\n\n  findPathConstraintIndex(pathConstraintName) {\n    if (pathConstraintName == null) throw new Error(\"pathConstraintName cannot be null.\");\n    let pathConstraints = this.pathConstraints;\n\n    for (let i = 0, n = pathConstraints.length; i < n; i++) if (pathConstraints[i].name == pathConstraintName) return i;\n\n    return -1;\n  }\n\n}\n/** Stores the setup pose for a {@link Slot}.\r\n * @public\r\n * */\n\n\nclass SlotData {\n  /** The index of the slot in {@link Skeleton#getSlots()}. */\n\n  /** The name of the slot, which is unique across all slots in the skeleton. */\n\n  /** The bone this slot belongs to. */\n\n  /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\r\n   * color tinting. */\n  __init() {\n    this.color = new Color(1, 1, 1, 1);\n  }\n  /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\r\n   * color's alpha is not used. */\n\n  /** The name of the attachment that is visible for this slot in the setup pose, or null if no attachment is visible. */\n\n  /** The blend mode for drawing the slot's attachment. */\n\n\n  constructor(index, name, boneData) {\n    SlotData.prototype.__init.call(this);\n\n    if (index < 0) throw new Error(\"index must be >= 0.\");\n    if (!name) throw new Error(\"name cannot be null.\");\n    if (!boneData) throw new Error(\"boneData cannot be null.\");\n    this.index = index;\n    this.name = name;\n    this.boneData = boneData;\n  }\n\n}\n/** Stores the setup pose for a {@link TransformConstraint}.\r\n *\r\n * See [Transform constraints](http://esotericsoftware.com/spine-transform-constraints) in the Spine User Guide.\r\n * @public\r\n * */\n\n\nclass TransformConstraintData extends ConstraintData {\n  /** The bones that will be modified by this transform constraint. */\n  __init() {\n    this.bones = new Array();\n  }\n  /** The target bone whose world transform will be copied to the constrained bones. */\n\n\n  __init2() {\n    this.mixRotate = 0;\n  }\n\n  __init3() {\n    this.mixX = 0;\n  }\n\n  __init4() {\n    this.mixY = 0;\n  }\n\n  __init5() {\n    this.mixScaleX = 0;\n  }\n\n  __init6() {\n    this.mixScaleY = 0;\n  }\n\n  __init7() {\n    this.mixShearY = 0;\n  }\n  /** An offset added to the constrained bone rotation. */\n\n\n  __init8() {\n    this.offsetRotation = 0;\n  }\n  /** An offset added to the constrained bone X translation. */\n\n\n  __init9() {\n    this.offsetX = 0;\n  }\n  /** An offset added to the constrained bone Y translation. */\n\n\n  __init10() {\n    this.offsetY = 0;\n  }\n  /** An offset added to the constrained bone scaleX. */\n\n\n  __init11() {\n    this.offsetScaleX = 0;\n  }\n  /** An offset added to the constrained bone scaleY. */\n\n\n  __init12() {\n    this.offsetScaleY = 0;\n  }\n  /** An offset added to the constrained bone shearY. */\n\n\n  __init13() {\n    this.offsetShearY = 0;\n  }\n\n  __init14() {\n    this.relative = false;\n  }\n\n  __init15() {\n    this.local = false;\n  }\n\n  constructor(name) {\n    super(name, 0, false);\n\n    TransformConstraintData.prototype.__init.call(this);\n\n    TransformConstraintData.prototype.__init2.call(this);\n\n    TransformConstraintData.prototype.__init3.call(this);\n\n    TransformConstraintData.prototype.__init4.call(this);\n\n    TransformConstraintData.prototype.__init5.call(this);\n\n    TransformConstraintData.prototype.__init6.call(this);\n\n    TransformConstraintData.prototype.__init7.call(this);\n\n    TransformConstraintData.prototype.__init8.call(this);\n\n    TransformConstraintData.prototype.__init9.call(this);\n\n    TransformConstraintData.prototype.__init10.call(this);\n\n    TransformConstraintData.prototype.__init11.call(this);\n\n    TransformConstraintData.prototype.__init12.call(this);\n\n    TransformConstraintData.prototype.__init13.call(this);\n\n    TransformConstraintData.prototype.__init14.call(this);\n\n    TransformConstraintData.prototype.__init15.call(this);\n  }\n\n}\n/** Stores an entry in the skin consisting of the slot index, name, and attachment\r\n * @public\r\n * **/\n\n\nclass SkinEntry {\n  constructor(slotIndex, name, attachment) {\n    this.slotIndex = slotIndex;\n    this.name = name;\n    this.attachment = attachment;\n  }\n\n}\n/** Stores attachments by slot index and attachment name.\r\n *\r\n * See SkeletonData {@link SkeletonData#defaultSkin}, Skeleton {@link Skeleton#skin}, and\r\n * [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\r\n * @public\r\n * */\n\n\nclass Skin {\n  /** The skin's name, which is unique across all skins in the skeleton. */\n  __init() {\n    this.attachments = new Array();\n  }\n\n  __init2() {\n    this.bones = Array();\n  }\n\n  __init3() {\n    this.constraints = new Array();\n  }\n\n  constructor(name) {\n    Skin.prototype.__init.call(this);\n\n    Skin.prototype.__init2.call(this);\n\n    Skin.prototype.__init3.call(this);\n\n    if (!name) throw new Error(\"name cannot be null.\");\n    this.name = name;\n  }\n  /** Adds an attachment to the skin for the specified slot index and name. */\n\n\n  setAttachment(slotIndex, name, attachment) {\n    if (!attachment) throw new Error(\"attachment cannot be null.\");\n    let attachments = this.attachments;\n    if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n    if (!attachments[slotIndex]) attachments[slotIndex] = {};\n    attachments[slotIndex][name] = attachment;\n  }\n  /** Adds all attachments, bones, and constraints from the specified skin to this skin. */\n\n\n  addSkin(skin) {\n    for (let i = 0; i < skin.bones.length; i++) {\n      let bone = skin.bones[i];\n      let contained = false;\n\n      for (let ii = 0; ii < this.bones.length; ii++) {\n        if (this.bones[ii] == bone) {\n          contained = true;\n          break;\n        }\n      }\n\n      if (!contained) this.bones.push(bone);\n    }\n\n    for (let i = 0; i < skin.constraints.length; i++) {\n      let constraint = skin.constraints[i];\n      let contained = false;\n\n      for (let ii = 0; ii < this.constraints.length; ii++) {\n        if (this.constraints[ii] == constraint) {\n          contained = true;\n          break;\n        }\n      }\n\n      if (!contained) this.constraints.push(constraint);\n    }\n\n    let attachments = skin.getAttachments();\n\n    for (let i = 0; i < attachments.length; i++) {\n      var attachment = attachments[i];\n      this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n    }\n  }\n  /** Adds all bones and constraints and copies of all attachments from the specified skin to this skin. Mesh attachments are not\r\n   * copied, instead a new linked mesh is created. The attachment copies can be modified without affecting the originals. */\n\n\n  copySkin(skin) {\n    for (let i = 0; i < skin.bones.length; i++) {\n      let bone = skin.bones[i];\n      let contained = false;\n\n      for (let ii = 0; ii < this.bones.length; ii++) {\n        if (this.bones[ii] == bone) {\n          contained = true;\n          break;\n        }\n      }\n\n      if (!contained) this.bones.push(bone);\n    }\n\n    for (let i = 0; i < skin.constraints.length; i++) {\n      let constraint = skin.constraints[i];\n      let contained = false;\n\n      for (let ii = 0; ii < this.constraints.length; ii++) {\n        if (this.constraints[ii] == constraint) {\n          contained = true;\n          break;\n        }\n      }\n\n      if (!contained) this.constraints.push(constraint);\n    }\n\n    let attachments = skin.getAttachments();\n\n    for (let i = 0; i < attachments.length; i++) {\n      var attachment = attachments[i];\n      if (!attachment.attachment) continue;\n\n      if (attachment.attachment instanceof MeshAttachment) {\n        attachment.attachment = attachment.attachment.newLinkedMesh();\n        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n      } else {\n        attachment.attachment = attachment.attachment.copy();\n        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n      }\n    }\n  }\n  /** Returns the attachment for the specified slot index and name, or null. */\n\n\n  getAttachment(slotIndex, name) {\n    let dictionary = this.attachments[slotIndex];\n    return dictionary ? dictionary[name] : null;\n  }\n  /** Removes the attachment in the skin for the specified slot index and name, if any. */\n\n\n  removeAttachment(slotIndex, name) {\n    let dictionary = this.attachments[slotIndex];\n    if (dictionary) dictionary[name] = null;\n  }\n  /** Returns all attachments in this skin. */\n\n\n  getAttachments() {\n    let entries = new Array();\n\n    for (var i = 0; i < this.attachments.length; i++) {\n      let slotAttachments = this.attachments[i];\n\n      if (slotAttachments) {\n        for (let name in slotAttachments) {\n          let attachment = slotAttachments[name];\n          if (attachment) entries.push(new SkinEntry(i, name, attachment));\n        }\n      }\n    }\n\n    return entries;\n  }\n  /** Returns all attachments in this skin for the specified slot index. */\n\n\n  getAttachmentsForSlot(slotIndex, attachments) {\n    let slotAttachments = this.attachments[slotIndex];\n\n    if (slotAttachments) {\n      for (let name in slotAttachments) {\n        let attachment = slotAttachments[name];\n        if (attachment) attachments.push(new SkinEntry(slotIndex, name, attachment));\n      }\n    }\n  }\n  /** Clears all attachments, bones, and constraints. */\n\n\n  clear() {\n    this.attachments.length = 0;\n    this.bones.length = 0;\n    this.constraints.length = 0;\n  }\n  /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n\n\n  attachAll(skeleton, oldSkin) {\n    let slotIndex = 0;\n\n    for (let i = 0; i < skeleton.slots.length; i++) {\n      let slot = skeleton.slots[i];\n      let slotAttachment = slot.getAttachment();\n\n      if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n        let dictionary = oldSkin.attachments[slotIndex];\n\n        for (let key in dictionary) {\n          let skinAttachment = dictionary[key];\n\n          if (slotAttachment == skinAttachment) {\n            let attachment = this.getAttachment(slotIndex, key);\n            if (attachment) slot.setAttachment(attachment);\n            break;\n          }\n        }\n      }\n\n      slotIndex++;\n    }\n  }\n\n}\n/** Loads skeleton data in the Spine binary format.\r\n *\r\n * See [Spine binary format](http://esotericsoftware.com/spine-binary-format) and\r\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\r\n * Runtimes Guide.\r\n * @public\r\n * */\n\n\nclass SkeletonBinary {\n  static __initStatic() {\n    this.BlendModeValues = [BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];\n  }\n  /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\r\n   * runtime than were used in Spine.\r\n   *\r\n   * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n\n\n  __init() {\n    this.scale = 1;\n  }\n\n  __init2() {\n    this.linkedMeshes = new Array();\n  }\n\n  constructor(attachmentLoader) {\n    SkeletonBinary.prototype.__init.call(this);\n\n    SkeletonBinary.prototype.__init2.call(this);\n\n    this.attachmentLoader = attachmentLoader;\n  }\n\n  readSkeletonData(binary) {\n    let scale = this.scale;\n    let skeletonData = new SkeletonData();\n    skeletonData.name = \"\"; // BOZO\n\n    let input = new BinaryInput(binary);\n    let lowHash = input.readInt32();\n    let highHash = input.readInt32();\n    skeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);\n    skeletonData.version = input.readString();\n\n    if (skeletonData.version.substr(0, 3) !== '4.0') {\n      let error = `Spine 4.0 loader cant load version ${skeletonData.version}. Please configure your pixi-spine bundle`;\n      console.error(error);\n    }\n\n    skeletonData.x = input.readFloat();\n    skeletonData.y = input.readFloat();\n    skeletonData.width = input.readFloat();\n    skeletonData.height = input.readFloat();\n    let nonessential = input.readBoolean();\n\n    if (nonessential) {\n      skeletonData.fps = input.readFloat();\n      skeletonData.imagesPath = input.readString();\n      skeletonData.audioPath = input.readString();\n    }\n\n    let n = 0; // Strings.\n\n    n = input.readInt(true);\n\n    for (let i = 0; i < n; i++) input.strings.push(input.readString()); // Bones.\n\n\n    n = input.readInt(true);\n\n    for (let i = 0; i < n; i++) {\n      let name = input.readString();\n      let parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\n      let data = new BoneData(i, name, parent);\n      data.rotation = input.readFloat();\n      data.x = input.readFloat() * scale;\n      data.y = input.readFloat() * scale;\n      data.scaleX = input.readFloat();\n      data.scaleY = input.readFloat();\n      data.shearX = input.readFloat();\n      data.shearY = input.readFloat();\n      data.length = input.readFloat() * scale;\n      data.transformMode = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      if (nonessential) Color.rgba8888ToColor(data.color, input.readInt32());\n      skeletonData.bones.push(data);\n    } // Slots.\n\n\n    n = input.readInt(true);\n\n    for (let i = 0; i < n; i++) {\n      let slotName = input.readString();\n      let boneData = skeletonData.bones[input.readInt(true)];\n      let data = new SlotData(i, slotName, boneData);\n      Color.rgba8888ToColor(data.color, input.readInt32());\n      let darkColor = input.readInt32();\n      if (darkColor != -1) Color.rgb888ToColor(data.darkColor = new Color(), darkColor);\n      data.attachmentName = input.readStringRef();\n      data.blendMode = SkeletonBinary.BlendModeValues[input.readInt(true)];\n      skeletonData.slots.push(data);\n    } // IK constraints.\n\n\n    n = input.readInt(true);\n\n    for (let i = 0, nn; i < n; i++) {\n      let data = new IkConstraintData(input.readString());\n      data.order = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      nn = input.readInt(true);\n\n      for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n\n      data.target = skeletonData.bones[input.readInt(true)];\n      data.mix = input.readFloat();\n      data.softness = input.readFloat() * scale;\n      data.bendDirection = input.readByte();\n      data.compress = input.readBoolean();\n      data.stretch = input.readBoolean();\n      data.uniform = input.readBoolean();\n      skeletonData.ikConstraints.push(data);\n    } // Transform constraints.\n\n\n    n = input.readInt(true);\n\n    for (let i = 0, nn; i < n; i++) {\n      let data = new TransformConstraintData(input.readString());\n      data.order = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      nn = input.readInt(true);\n\n      for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n\n      data.target = skeletonData.bones[input.readInt(true)];\n      data.local = input.readBoolean();\n      data.relative = input.readBoolean();\n      data.offsetRotation = input.readFloat();\n      data.offsetX = input.readFloat() * scale;\n      data.offsetY = input.readFloat() * scale;\n      data.offsetScaleX = input.readFloat();\n      data.offsetScaleY = input.readFloat();\n      data.offsetShearY = input.readFloat();\n      data.mixRotate = input.readFloat();\n      data.mixX = input.readFloat();\n      data.mixY = input.readFloat();\n      data.mixScaleX = input.readFloat();\n      data.mixScaleY = input.readFloat();\n      data.mixShearY = input.readFloat();\n      skeletonData.transformConstraints.push(data);\n    } // Path constraints.\n\n\n    n = input.readInt(true);\n\n    for (let i = 0, nn; i < n; i++) {\n      let data = new PathConstraintData(input.readString());\n      data.order = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      nn = input.readInt(true);\n\n      for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n\n      data.target = skeletonData.slots[input.readInt(true)];\n      data.positionMode = input.readInt(true);\n      data.spacingMode = input.readInt(true);\n      data.rotateMode = input.readInt(true);\n      data.offsetRotation = input.readFloat();\n      data.position = input.readFloat();\n      if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n      data.spacing = input.readFloat();\n      if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n      data.mixRotate = input.readFloat();\n      data.mixX = input.readFloat();\n      data.mixY = input.readFloat();\n      skeletonData.pathConstraints.push(data);\n    } // Default skin.\n\n\n    let defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\n\n    if (defaultSkin) {\n      skeletonData.defaultSkin = defaultSkin;\n      skeletonData.skins.push(defaultSkin);\n    } // Skins.\n\n\n    {\n      let i = skeletonData.skins.length;\n      Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));\n\n      for (; i < n; i++) skeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);\n    } // Linked meshes.\n\n    n = this.linkedMeshes.length;\n\n    for (let i = 0; i < n; i++) {\n      let linkedMesh = this.linkedMeshes[i];\n      let skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n      let parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n      linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent : linkedMesh.mesh;\n      linkedMesh.mesh.setParentMesh(parent); // linkedMesh.mesh.updateUVs();\n    }\n\n    this.linkedMeshes.length = 0; // Events.\n\n    n = input.readInt(true);\n\n    for (let i = 0; i < n; i++) {\n      let data = new EventData(input.readStringRef());\n      data.intValue = input.readInt(false);\n      data.floatValue = input.readFloat();\n      data.stringValue = input.readString();\n      data.audioPath = input.readString();\n\n      if (data.audioPath) {\n        data.volume = input.readFloat();\n        data.balance = input.readFloat();\n      }\n\n      skeletonData.events.push(data);\n    } // Animations.\n\n\n    n = input.readInt(true);\n\n    for (let i = 0; i < n; i++) skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));\n\n    return skeletonData;\n  }\n\n  readSkin(input, skeletonData, defaultSkin, nonessential) {\n    let skin = null;\n    let slotCount = 0;\n\n    if (defaultSkin) {\n      slotCount = input.readInt(true);\n      if (slotCount == 0) return null;\n      skin = new Skin(\"default\");\n    } else {\n      skin = new Skin(input.readStringRef());\n      skin.bones.length = input.readInt(true);\n\n      for (let i = 0, n = skin.bones.length; i < n; i++) skin.bones[i] = skeletonData.bones[input.readInt(true)];\n\n      for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\n\n      for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\n\n      for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\n\n      slotCount = input.readInt(true);\n    }\n\n    for (let i = 0; i < slotCount; i++) {\n      let slotIndex = input.readInt(true);\n\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        let name = input.readStringRef();\n        let attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\n        if (attachment) skin.setAttachment(slotIndex, name, attachment);\n      }\n    }\n\n    return skin;\n  }\n\n  readAttachment(input, skeletonData, skin, slotIndex, attachmentName, nonessential) {\n    let scale = this.scale;\n    let name = input.readStringRef();\n    if (!name) name = attachmentName;\n\n    switch (input.readByte()) {\n      case AttachmentType.Region:\n        {\n          let path = input.readStringRef();\n          let rotation = input.readFloat();\n          let x = input.readFloat();\n          let y = input.readFloat();\n          let scaleX = input.readFloat();\n          let scaleY = input.readFloat();\n          let width = input.readFloat();\n          let height = input.readFloat();\n          let color = input.readInt32();\n          if (!path) path = name;\n          let region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n          if (!region) return null;\n          region.path = path;\n          region.x = x * scale;\n          region.y = y * scale;\n          region.scaleX = scaleX;\n          region.scaleY = scaleY;\n          region.rotation = rotation;\n          region.width = width * scale;\n          region.height = height * scale;\n          Color.rgba8888ToColor(region.color, color); // region.updateOffset();\n\n          return region;\n        }\n\n      case AttachmentType.BoundingBox:\n        {\n          let vertexCount = input.readInt(true);\n          let vertices = this.readVertices(input, vertexCount);\n          let color = nonessential ? input.readInt32() : 0;\n          let box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n          if (!box) return null;\n          box.worldVerticesLength = vertexCount << 1;\n          box.vertices = vertices.vertices;\n          box.bones = vertices.bones;\n          if (nonessential) Color.rgba8888ToColor(box.color, color);\n          return box;\n        }\n\n      case AttachmentType.Mesh:\n        {\n          let path = input.readStringRef();\n          let color = input.readInt32();\n          let vertexCount = input.readInt(true);\n          let uvs = this.readFloatArray(input, vertexCount << 1, 1);\n          let triangles = this.readShortArray(input);\n          let vertices = this.readVertices(input, vertexCount);\n          let hullLength = input.readInt(true);\n          let edges = null;\n          let width = 0,\n              height = 0;\n\n          if (nonessential) {\n            edges = this.readShortArray(input);\n            width = input.readFloat();\n            height = input.readFloat();\n          }\n\n          if (!path) path = name;\n          let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n          if (!mesh) return null;\n          mesh.path = path;\n          Color.rgba8888ToColor(mesh.color, color);\n          mesh.bones = vertices.bones;\n          mesh.vertices = vertices.vertices;\n          mesh.worldVerticesLength = vertexCount << 1;\n          mesh.triangles = triangles;\n          mesh.regionUVs = new Float32Array(uvs); // mesh.updateUVs();\n\n          mesh.hullLength = hullLength << 1;\n\n          if (nonessential) {\n            mesh.edges = edges;\n            mesh.width = width * scale;\n            mesh.height = height * scale;\n          }\n\n          return mesh;\n        }\n\n      case AttachmentType.LinkedMesh:\n        {\n          let path = input.readStringRef();\n          let color = input.readInt32();\n          let skinName = input.readStringRef();\n          let parent = input.readStringRef();\n          let inheritDeform = input.readBoolean();\n          let width = 0,\n              height = 0;\n\n          if (nonessential) {\n            width = input.readFloat();\n            height = input.readFloat();\n          }\n\n          if (!path) path = name;\n          let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n          if (!mesh) return null;\n          mesh.path = path;\n          Color.rgba8888ToColor(mesh.color, color);\n\n          if (nonessential) {\n            mesh.width = width * scale;\n            mesh.height = height * scale;\n          }\n\n          this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritDeform));\n          return mesh;\n        }\n\n      case AttachmentType.Path:\n        {\n          let closed = input.readBoolean();\n          let constantSpeed = input.readBoolean();\n          let vertexCount = input.readInt(true);\n          let vertices = this.readVertices(input, vertexCount);\n          let lengths = Utils.newArray(vertexCount / 3, 0);\n\n          for (let i = 0, n = lengths.length; i < n; i++) lengths[i] = input.readFloat() * scale;\n\n          let color = nonessential ? input.readInt32() : 0;\n          let path = this.attachmentLoader.newPathAttachment(skin, name);\n          if (!path) return null;\n          path.closed = closed;\n          path.constantSpeed = constantSpeed;\n          path.worldVerticesLength = vertexCount << 1;\n          path.vertices = vertices.vertices;\n          path.bones = vertices.bones;\n          path.lengths = lengths;\n          if (nonessential) Color.rgba8888ToColor(path.color, color);\n          return path;\n        }\n\n      case AttachmentType.Point:\n        {\n          let rotation = input.readFloat();\n          let x = input.readFloat();\n          let y = input.readFloat();\n          let color = nonessential ? input.readInt32() : 0;\n          let point = this.attachmentLoader.newPointAttachment(skin, name);\n          if (!point) return null;\n          point.x = x * scale;\n          point.y = y * scale;\n          point.rotation = rotation;\n          if (nonessential) Color.rgba8888ToColor(point.color, color);\n          return point;\n        }\n\n      case AttachmentType.Clipping:\n        {\n          let endSlotIndex = input.readInt(true);\n          let vertexCount = input.readInt(true);\n          let vertices = this.readVertices(input, vertexCount);\n          let color = nonessential ? input.readInt32() : 0;\n          let clip = this.attachmentLoader.newClippingAttachment(skin, name);\n          if (!clip) return null;\n          clip.endSlot = skeletonData.slots[endSlotIndex];\n          clip.worldVerticesLength = vertexCount << 1;\n          clip.vertices = vertices.vertices;\n          clip.bones = vertices.bones;\n          if (nonessential) Color.rgba8888ToColor(clip.color, color);\n          return clip;\n        }\n    }\n\n    return null;\n  }\n\n  readVertices(input, vertexCount) {\n    let scale = this.scale;\n    let verticesLength = vertexCount << 1;\n    let vertices = new Vertices();\n\n    if (!input.readBoolean()) {\n      vertices.vertices = this.readFloatArray(input, verticesLength, scale);\n      return vertices;\n    }\n\n    let weights = new Array();\n    let bonesArray = new Array();\n\n    for (let i = 0; i < vertexCount; i++) {\n      let boneCount = input.readInt(true);\n      bonesArray.push(boneCount);\n\n      for (let ii = 0; ii < boneCount; ii++) {\n        bonesArray.push(input.readInt(true));\n        weights.push(input.readFloat() * scale);\n        weights.push(input.readFloat() * scale);\n        weights.push(input.readFloat());\n      }\n    }\n\n    vertices.vertices = Utils.toFloatArray(weights);\n    vertices.bones = bonesArray;\n    return vertices;\n  }\n\n  readFloatArray(input, n, scale) {\n    let array = new Array(n);\n\n    if (scale == 1) {\n      for (let i = 0; i < n; i++) array[i] = input.readFloat();\n    } else {\n      for (let i = 0; i < n; i++) array[i] = input.readFloat() * scale;\n    }\n\n    return array;\n  }\n\n  readShortArray(input) {\n    let n = input.readInt(true);\n    let array = new Array(n);\n\n    for (let i = 0; i < n; i++) array[i] = input.readShort();\n\n    return array;\n  }\n\n  readAnimation(input, name, skeletonData) {\n    input.readInt(true); // Number of timelines.\n\n    let timelines = new Array();\n    let scale = this.scale; // Slot timelines.\n\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      let slotIndex = input.readInt(true);\n\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        let timelineType = input.readByte();\n        let frameCount = input.readInt(true);\n        let frameLast = frameCount - 1;\n\n        switch (timelineType) {\n          case SLOT_ATTACHMENT:\n            {\n              let timeline = new AttachmentTimeline(frameCount, slotIndex);\n\n              for (let frame = 0; frame < frameCount; frame++) timeline.setFrame(frame, input.readFloat(), input.readStringRef());\n\n              timelines.push(timeline);\n              break;\n            }\n\n          case SLOT_RGBA:\n            {\n              let bezierCount = input.readInt(true);\n              let timeline = new RGBATimeline(frameCount, bezierCount, slotIndex);\n              let time = input.readFloat();\n              let r = input.readUnsignedByte() / 255.0;\n              let g = input.readUnsignedByte() / 255.0;\n              let b = input.readUnsignedByte() / 255.0;\n              let a = input.readUnsignedByte() / 255.0;\n\n              for (let frame = 0, bezier = 0;; frame++) {\n                timeline.setFrame(frame, time, r, g, b, a);\n                if (frame == frameLast) break;\n                let time2 = input.readFloat();\n                let r2 = input.readUnsignedByte() / 255.0;\n                let g2 = input.readUnsignedByte() / 255.0;\n                let b2 = input.readUnsignedByte() / 255.0;\n                let a2 = input.readUnsignedByte() / 255.0;\n\n                switch (input.readByte()) {\n                  case CURVE_STEPPED:\n                    timeline.setStepped(frame);\n                    break;\n\n                  case CURVE_BEZIER:\n                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\n                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\n                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\n                    setBezier(input, timeline, bezier++, frame, 3, time, time2, a, a2, 1);\n                }\n\n                time = time2;\n                r = r2;\n                g = g2;\n                b = b2;\n                a = a2;\n              }\n\n              timelines.push(timeline);\n              break;\n            }\n\n          case SLOT_RGB:\n            {\n              let bezierCount = input.readInt(true);\n              let timeline = new RGBTimeline(frameCount, bezierCount, slotIndex);\n              let time = input.readFloat();\n              let r = input.readUnsignedByte() / 255.0;\n              let g = input.readUnsignedByte() / 255.0;\n              let b = input.readUnsignedByte() / 255.0;\n\n              for (let frame = 0, bezier = 0;; frame++) {\n                timeline.setFrame(frame, time, r, g, b);\n                if (frame == frameLast) break;\n                let time2 = input.readFloat();\n                let r2 = input.readUnsignedByte() / 255.0;\n                let g2 = input.readUnsignedByte() / 255.0;\n                let b2 = input.readUnsignedByte() / 255.0;\n\n                switch (input.readByte()) {\n                  case CURVE_STEPPED:\n                    timeline.setStepped(frame);\n                    break;\n\n                  case CURVE_BEZIER:\n                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\n                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\n                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\n                }\n\n                time = time2;\n                r = r2;\n                g = g2;\n                b = b2;\n              }\n\n              timelines.push(timeline);\n              break;\n            }\n\n          case SLOT_RGBA2:\n            {\n              let bezierCount = input.readInt(true);\n              let timeline = new RGBA2Timeline(frameCount, bezierCount, slotIndex);\n              let time = input.readFloat();\n              let r = input.readUnsignedByte() / 255.0;\n              let g = input.readUnsignedByte() / 255.0;\n              let b = input.readUnsignedByte() / 255.0;\n              let a = input.readUnsignedByte() / 255.0;\n              let r2 = input.readUnsignedByte() / 255.0;\n              let g2 = input.readUnsignedByte() / 255.0;\n              let b2 = input.readUnsignedByte() / 255.0;\n\n              for (let frame = 0, bezier = 0;; frame++) {\n                timeline.setFrame(frame, time, r, g, b, a, r2, g2, b2);\n                if (frame == frameLast) break;\n                let time2 = input.readFloat();\n                let nr = input.readUnsignedByte() / 255.0;\n                let ng = input.readUnsignedByte() / 255.0;\n                let nb = input.readUnsignedByte() / 255.0;\n                let na = input.readUnsignedByte() / 255.0;\n                let nr2 = input.readUnsignedByte() / 255.0;\n                let ng2 = input.readUnsignedByte() / 255.0;\n                let nb2 = input.readUnsignedByte() / 255.0;\n\n                switch (input.readByte()) {\n                  case CURVE_STEPPED:\n                    timeline.setStepped(frame);\n                    break;\n\n                  case CURVE_BEZIER:\n                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\n                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\n                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\n                    setBezier(input, timeline, bezier++, frame, 3, time, time2, a, na, 1);\n                    setBezier(input, timeline, bezier++, frame, 4, time, time2, r2, nr2, 1);\n                    setBezier(input, timeline, bezier++, frame, 5, time, time2, g2, ng2, 1);\n                    setBezier(input, timeline, bezier++, frame, 6, time, time2, b2, nb2, 1);\n                }\n\n                time = time2;\n                r = nr;\n                g = ng;\n                b = nb;\n                a = na;\n                r2 = nr2;\n                g2 = ng2;\n                b2 = nb2;\n              }\n\n              timelines.push(timeline);\n              break;\n            }\n\n          case SLOT_RGB2:\n            {\n              let bezierCount = input.readInt(true);\n              let timeline = new RGB2Timeline(frameCount, bezierCount, slotIndex);\n              let time = input.readFloat();\n              let r = input.readUnsignedByte() / 255.0;\n              let g = input.readUnsignedByte() / 255.0;\n              let b = input.readUnsignedByte() / 255.0;\n              let r2 = input.readUnsignedByte() / 255.0;\n              let g2 = input.readUnsignedByte() / 255.0;\n              let b2 = input.readUnsignedByte() / 255.0;\n\n              for (let frame = 0, bezier = 0;; frame++) {\n                timeline.setFrame(frame, time, r, g, b, r2, g2, b2);\n                if (frame == frameLast) break;\n                let time2 = input.readFloat();\n                let nr = input.readUnsignedByte() / 255.0;\n                let ng = input.readUnsignedByte() / 255.0;\n                let nb = input.readUnsignedByte() / 255.0;\n                let nr2 = input.readUnsignedByte() / 255.0;\n                let ng2 = input.readUnsignedByte() / 255.0;\n                let nb2 = input.readUnsignedByte() / 255.0;\n\n                switch (input.readByte()) {\n                  case CURVE_STEPPED:\n                    timeline.setStepped(frame);\n                    break;\n\n                  case CURVE_BEZIER:\n                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\n                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\n                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\n                    setBezier(input, timeline, bezier++, frame, 3, time, time2, r2, nr2, 1);\n                    setBezier(input, timeline, bezier++, frame, 4, time, time2, g2, ng2, 1);\n                    setBezier(input, timeline, bezier++, frame, 5, time, time2, b2, nb2, 1);\n                }\n\n                time = time2;\n                r = nr;\n                g = ng;\n                b = nb;\n                r2 = nr2;\n                g2 = ng2;\n                b2 = nb2;\n              }\n\n              timelines.push(timeline);\n              break;\n            }\n\n          case SLOT_ALPHA:\n            {\n              let timeline = new AlphaTimeline(frameCount, input.readInt(true), slotIndex);\n              let time = input.readFloat(),\n                  a = input.readUnsignedByte() / 255;\n\n              for (let frame = 0, bezier = 0;; frame++) {\n                timeline.setFrame(frame, time, a);\n                if (frame == frameLast) break;\n                let time2 = input.readFloat();\n                let a2 = input.readUnsignedByte() / 255;\n\n                switch (input.readByte()) {\n                  case CURVE_STEPPED:\n                    timeline.setStepped(frame);\n                    break;\n\n                  case CURVE_BEZIER:\n                    setBezier(input, timeline, bezier++, frame, 0, time, time2, a, a2, 1);\n                }\n\n                time = time2;\n                a = a2;\n              }\n\n              timelines.push(timeline);\n              break;\n            }\n        }\n      }\n    } // Bone timelines.\n\n\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      let boneIndex = input.readInt(true);\n\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        let type = input.readByte(),\n            frameCount = input.readInt(true),\n            bezierCount = input.readInt(true);\n\n        switch (type) {\n          case BONE_ROTATE:\n            timelines.push(readTimeline1(input, new RotateTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n\n          case BONE_TRANSLATE:\n            timelines.push(readTimeline2(input, new TranslateTimeline(frameCount, bezierCount, boneIndex), scale));\n            break;\n\n          case BONE_TRANSLATEX:\n            timelines.push(readTimeline1(input, new TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));\n            break;\n\n          case BONE_TRANSLATEY:\n            timelines.push(readTimeline1(input, new TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));\n            break;\n\n          case BONE_SCALE:\n            timelines.push(readTimeline2(input, new ScaleTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n\n          case BONE_SCALEX:\n            timelines.push(readTimeline1(input, new ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n\n          case BONE_SCALEY:\n            timelines.push(readTimeline1(input, new ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n\n          case BONE_SHEAR:\n            timelines.push(readTimeline2(input, new ShearTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n\n          case BONE_SHEARX:\n            timelines.push(readTimeline1(input, new ShearXTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n\n          case BONE_SHEARY:\n            timelines.push(readTimeline1(input, new ShearYTimeline(frameCount, bezierCount, boneIndex), 1));\n        }\n      }\n    } // IK constraint timelines.\n\n\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      let index = input.readInt(true),\n          frameCount = input.readInt(true),\n          frameLast = frameCount - 1;\n      let timeline = new IkConstraintTimeline(frameCount, input.readInt(true), index);\n      let time = input.readFloat(),\n          mix = input.readFloat(),\n          softness = input.readFloat() * scale;\n\n      for (let frame = 0, bezier = 0;; frame++) {\n        timeline.setFrame(frame, time, mix, softness, input.readByte(), input.readBoolean(), input.readBoolean());\n        if (frame == frameLast) break;\n        let time2 = input.readFloat(),\n            mix2 = input.readFloat(),\n            softness2 = input.readFloat() * scale;\n\n        switch (input.readByte()) {\n          case CURVE_STEPPED:\n            timeline.setStepped(frame);\n            break;\n\n          case CURVE_BEZIER:\n            setBezier(input, timeline, bezier++, frame, 0, time, time2, mix, mix2, 1);\n            setBezier(input, timeline, bezier++, frame, 1, time, time2, softness, softness2, scale);\n        }\n\n        time = time2;\n        mix = mix2;\n        softness = softness2;\n      }\n\n      timelines.push(timeline);\n    } // Transform constraint timelines.\n\n\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      let index = input.readInt(true),\n          frameCount = input.readInt(true),\n          frameLast = frameCount - 1;\n      let timeline = new TransformConstraintTimeline(frameCount, input.readInt(true), index);\n      let time = input.readFloat(),\n          mixRotate = input.readFloat(),\n          mixX = input.readFloat(),\n          mixY = input.readFloat(),\n          mixScaleX = input.readFloat(),\n          mixScaleY = input.readFloat(),\n          mixShearY = input.readFloat();\n\n      for (let frame = 0, bezier = 0;; frame++) {\n        timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\n        if (frame == frameLast) break;\n        let time2 = input.readFloat(),\n            mixRotate2 = input.readFloat(),\n            mixX2 = input.readFloat(),\n            mixY2 = input.readFloat(),\n            mixScaleX2 = input.readFloat(),\n            mixScaleY2 = input.readFloat(),\n            mixShearY2 = input.readFloat();\n\n        switch (input.readByte()) {\n          case CURVE_STEPPED:\n            timeline.setStepped(frame);\n            break;\n\n          case CURVE_BEZIER:\n            setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n            setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\n            setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\n            setBezier(input, timeline, bezier++, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\n            setBezier(input, timeline, bezier++, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\n            setBezier(input, timeline, bezier++, frame, 5, time, time2, mixShearY, mixShearY2, 1);\n        }\n\n        time = time2;\n        mixRotate = mixRotate2;\n        mixX = mixX2;\n        mixY = mixY2;\n        mixScaleX = mixScaleX2;\n        mixScaleY = mixScaleY2;\n        mixShearY = mixShearY2;\n      }\n\n      timelines.push(timeline);\n    } // Path constraint timelines.\n\n\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      let index = input.readInt(true);\n      let data = skeletonData.pathConstraints[index];\n\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        switch (input.readByte()) {\n          case PATH_POSITION:\n            timelines.push(readTimeline1(input, new PathConstraintPositionTimeline(input.readInt(true), input.readInt(true), index), data.positionMode == PositionMode.Fixed ? scale : 1));\n            break;\n\n          case PATH_SPACING:\n            timelines.push(readTimeline1(input, new PathConstraintSpacingTimeline(input.readInt(true), input.readInt(true), index), data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed ? scale : 1));\n            break;\n\n          case PATH_MIX:\n            let timeline = new PathConstraintMixTimeline(input.readInt(true), input.readInt(true), index);\n            let time = input.readFloat(),\n                mixRotate = input.readFloat(),\n                mixX = input.readFloat(),\n                mixY = input.readFloat();\n\n            for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1;; frame++) {\n              timeline.setFrame(frame, time, mixRotate, mixX, mixY);\n              if (frame == frameLast) break;\n              let time2 = input.readFloat(),\n                  mixRotate2 = input.readFloat(),\n                  mixX2 = input.readFloat(),\n                  mixY2 = input.readFloat();\n\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                  setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\n                  setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\n              }\n\n              time = time2;\n              mixRotate = mixRotate2;\n              mixX = mixX2;\n              mixY = mixY2;\n            }\n\n            timelines.push(timeline);\n        }\n      }\n    } // Deform timelines.\n\n\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      let skin = skeletonData.skins[input.readInt(true)];\n\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        let slotIndex = input.readInt(true);\n\n        for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\n          let attachmentName = input.readStringRef();\n          let attachment = skin.getAttachment(slotIndex, attachmentName);\n          let weighted = attachment.bones;\n          let vertices = attachment.vertices;\n          let deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n          let frameCount = input.readInt(true);\n          let frameLast = frameCount - 1;\n          let bezierCount = input.readInt(true);\n          let timeline = new DeformTimeline(frameCount, bezierCount, slotIndex, attachment);\n          let time = input.readFloat();\n\n          for (let frame = 0, bezier = 0;; frame++) {\n            let deform;\n            let end = input.readInt(true);\n            if (end == 0) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;else {\n              deform = Utils.newFloatArray(deformLength);\n              let start = input.readInt(true);\n              end += start;\n\n              if (scale == 1) {\n                for (let v = start; v < end; v++) deform[v] = input.readFloat();\n              } else {\n                for (let v = start; v < end; v++) deform[v] = input.readFloat() * scale;\n              }\n\n              if (!weighted) {\n                for (let v = 0, vn = deform.length; v < vn; v++) deform[v] += vertices[v];\n              }\n            }\n            timeline.setFrame(frame, time, deform);\n            if (frame == frameLast) break;\n            let time2 = input.readFloat();\n\n            switch (input.readByte()) {\n              case CURVE_STEPPED:\n                timeline.setStepped(frame);\n                break;\n\n              case CURVE_BEZIER:\n                setBezier(input, timeline, bezier++, frame, 0, time, time2, 0, 1, 1);\n            }\n\n            time = time2;\n          }\n\n          timelines.push(timeline);\n        }\n      }\n    } // Draw order timeline.\n\n\n    let drawOrderCount = input.readInt(true);\n\n    if (drawOrderCount > 0) {\n      let timeline = new DrawOrderTimeline(drawOrderCount);\n      let slotCount = skeletonData.slots.length;\n\n      for (let i = 0; i < drawOrderCount; i++) {\n        let time = input.readFloat();\n        let offsetCount = input.readInt(true);\n        let drawOrder = Utils.newArray(slotCount, 0);\n\n        for (let ii = slotCount - 1; ii >= 0; ii--) drawOrder[ii] = -1;\n\n        let unchanged = Utils.newArray(slotCount - offsetCount, 0);\n        let originalIndex = 0,\n            unchangedIndex = 0;\n\n        for (let ii = 0; ii < offsetCount; ii++) {\n          let slotIndex = input.readInt(true); // Collect unchanged items.\n\n          while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++; // Set changed items.\n\n\n          drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\n        } // Collect remaining unchanged items.\n\n\n        while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++; // Fill in unchanged items.\n\n\n        for (let ii = slotCount - 1; ii >= 0; ii--) if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n\n        timeline.setFrame(i, time, drawOrder);\n      }\n\n      timelines.push(timeline);\n    } // Event timeline.\n\n\n    let eventCount = input.readInt(true);\n\n    if (eventCount > 0) {\n      let timeline = new EventTimeline(eventCount);\n\n      for (let i = 0; i < eventCount; i++) {\n        let time = input.readFloat();\n        let eventData = skeletonData.events[input.readInt(true)];\n        let event = new Event(time, eventData);\n        event.intValue = input.readInt(false);\n        event.floatValue = input.readFloat();\n        event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\n\n        if (event.data.audioPath) {\n          event.volume = input.readFloat();\n          event.balance = input.readFloat();\n        }\n\n        timeline.setFrame(i, event);\n      }\n\n      timelines.push(timeline);\n    }\n\n    let duration = 0;\n\n    for (let i = 0, n = timelines.length; i < n; i++) duration = Math.max(duration, timelines[i].getDuration());\n\n    return new Animation(name, timelines, duration);\n  }\n\n}\n\nSkeletonBinary.__initStatic();\n\nclass LinkedMesh {\n  constructor(mesh, skin, slotIndex, parent, inheritDeform) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n    this.inheritDeform = inheritDeform;\n  }\n\n}\n\nclass Vertices {\n  constructor(bones = null, vertices = null) {\n    this.bones = bones;\n    this.vertices = vertices;\n  }\n\n}\n\nfunction readTimeline1(input, timeline, scale) {\n  let time = input.readFloat(),\n      value = input.readFloat() * scale;\n\n  for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1;; frame++) {\n    timeline.setFrame(frame, time, value);\n    if (frame == frameLast) break;\n    let time2 = input.readFloat(),\n        value2 = input.readFloat() * scale;\n\n    switch (input.readByte()) {\n      case CURVE_STEPPED:\n        timeline.setStepped(frame);\n        break;\n\n      case CURVE_BEZIER:\n        setBezier(input, timeline, bezier++, frame, 0, time, time2, value, value2, 1);\n    }\n\n    time = time2;\n    value = value2;\n  }\n\n  return timeline;\n}\n\nfunction readTimeline2(input, timeline, scale) {\n  let time = input.readFloat(),\n      value1 = input.readFloat() * scale,\n      value2 = input.readFloat() * scale;\n\n  for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1;; frame++) {\n    timeline.setFrame(frame, time, value1, value2);\n    if (frame == frameLast) break;\n    let time2 = input.readFloat(),\n        nvalue1 = input.readFloat() * scale,\n        nvalue2 = input.readFloat() * scale;\n\n    switch (input.readByte()) {\n      case CURVE_STEPPED:\n        timeline.setStepped(frame);\n        break;\n\n      case CURVE_BEZIER:\n        setBezier(input, timeline, bezier++, frame, 0, time, time2, value1, nvalue1, scale);\n        setBezier(input, timeline, bezier++, frame, 1, time, time2, value2, nvalue2, scale);\n    }\n\n    time = time2;\n    value1 = nvalue1;\n    value2 = nvalue2;\n  }\n\n  return timeline;\n}\n\nfunction setBezier(input, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {\n  timeline.setBezier(bezier, frame, value, time1, value1, input.readFloat(), input.readFloat() * scale, input.readFloat(), input.readFloat() * scale, time2, value2);\n}\n\nconst BONE_ROTATE = 0;\nconst BONE_TRANSLATE = 1;\nconst BONE_TRANSLATEX = 2;\nconst BONE_TRANSLATEY = 3;\nconst BONE_SCALE = 4;\nconst BONE_SCALEX = 5;\nconst BONE_SCALEY = 6;\nconst BONE_SHEAR = 7;\nconst BONE_SHEARX = 8;\nconst BONE_SHEARY = 9;\nconst SLOT_ATTACHMENT = 0;\nconst SLOT_RGBA = 1;\nconst SLOT_RGB = 2;\nconst SLOT_RGBA2 = 3;\nconst SLOT_RGB2 = 4;\nconst SLOT_ALPHA = 5;\nconst PATH_POSITION = 0;\nconst PATH_SPACING = 1;\nconst PATH_MIX = 2;\nconst CURVE_STEPPED = 1;\nconst CURVE_BEZIER = 2;\n/** Collects each visible {@link BoundingBoxAttachment} and computes the world vertices for its polygon. The polygon vertices are\r\n * provided along with convenience methods for doing hit detection.\r\n * @public\r\n * */\n\nclass SkeletonBounds {\n  constructor() {\n    SkeletonBounds.prototype.__init.call(this);\n\n    SkeletonBounds.prototype.__init2.call(this);\n\n    SkeletonBounds.prototype.__init3.call(this);\n\n    SkeletonBounds.prototype.__init4.call(this);\n\n    SkeletonBounds.prototype.__init5.call(this);\n\n    SkeletonBounds.prototype.__init6.call(this);\n\n    SkeletonBounds.prototype.__init7.call(this);\n  }\n  /** The left edge of the axis aligned bounding box. */\n\n\n  __init() {\n    this.minX = 0;\n  }\n  /** The bottom edge of the axis aligned bounding box. */\n\n\n  __init2() {\n    this.minY = 0;\n  }\n  /** The right edge of the axis aligned bounding box. */\n\n\n  __init3() {\n    this.maxX = 0;\n  }\n  /** The top edge of the axis aligned bounding box. */\n\n\n  __init4() {\n    this.maxY = 0;\n  }\n  /** The visible bounding boxes. */\n\n\n  __init5() {\n    this.boundingBoxes = new Array();\n  }\n  /** The world vertices for the bounding box polygons. */\n\n\n  __init6() {\n    this.polygons = new Array();\n  }\n\n  __init7() {\n    this.polygonPool = new Pool(() => {\n      return Utils.newFloatArray(16);\n    });\n  }\n  /** Clears any previous polygons, finds all visible bounding box attachments, and computes the world vertices for each bounding\r\n   * box's polygon.\r\n   * @param updateAabb If true, the axis aligned bounding box containing all the polygons is computed. If false, the\r\n   *           SkeletonBounds AABB methods will always return true. */\n\n\n  update(skeleton, updateAabb) {\n    if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n    let boundingBoxes = this.boundingBoxes;\n    let polygons = this.polygons;\n    let polygonPool = this.polygonPool;\n    let slots = skeleton.slots;\n    let slotCount = slots.length;\n    boundingBoxes.length = 0;\n    polygonPool.freeAll(polygons);\n    polygons.length = 0;\n\n    for (let i = 0; i < slotCount; i++) {\n      let slot = slots[i];\n      if (!slot.bone.active) continue;\n      let attachment = slot.getAttachment();\n\n      if (attachment instanceof BoundingBoxAttachment) {\n        let boundingBox = attachment;\n        boundingBoxes.push(boundingBox);\n        let polygon = polygonPool.obtain();\n\n        if (polygon.length != boundingBox.worldVerticesLength) {\n          polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\n        }\n\n        polygons.push(polygon);\n        boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\n      }\n    }\n\n    if (updateAabb) {\n      this.aabbCompute();\n    } else {\n      this.minX = Number.POSITIVE_INFINITY;\n      this.minY = Number.POSITIVE_INFINITY;\n      this.maxX = Number.NEGATIVE_INFINITY;\n      this.maxY = Number.NEGATIVE_INFINITY;\n    }\n  }\n\n  aabbCompute() {\n    let minX = Number.POSITIVE_INFINITY,\n        minY = Number.POSITIVE_INFINITY,\n        maxX = Number.NEGATIVE_INFINITY,\n        maxY = Number.NEGATIVE_INFINITY;\n    let polygons = this.polygons;\n\n    for (let i = 0, n = polygons.length; i < n; i++) {\n      let polygon = polygons[i];\n      let vertices = polygon;\n\n      for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\n        let x = vertices[ii];\n        let y = vertices[ii + 1];\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n        maxX = Math.max(maxX, x);\n        maxY = Math.max(maxY, y);\n      }\n    }\n\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /** Returns true if the axis aligned bounding box contains the point. */\n\n\n  aabbContainsPoint(x, y) {\n    return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n  }\n  /** Returns true if the axis aligned bounding box intersects the line segment. */\n\n\n  aabbIntersectsSegment(x1, y1, x2, y2) {\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY) return false;\n    let m = (y2 - y1) / (x2 - x1);\n    let y = m * (minX - x1) + y1;\n    if (y > minY && y < maxY) return true;\n    y = m * (maxX - x1) + y1;\n    if (y > minY && y < maxY) return true;\n    let x = (minY - y1) / m + x1;\n    if (x > minX && x < maxX) return true;\n    x = (maxY - y1) / m + x1;\n    if (x > minX && x < maxX) return true;\n    return false;\n  }\n  /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\n\n\n  aabbIntersectsSkeleton(bounds) {\n    return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n  }\n  /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\r\n   * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\n\n\n  containsPoint(x, y) {\n    let polygons = this.polygons;\n\n    for (let i = 0, n = polygons.length; i < n; i++) if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\n\n    return null;\n  }\n  /** Returns true if the polygon contains the point. */\n\n\n  containsPointPolygon(polygon, x, y) {\n    let vertices = polygon;\n    let nn = polygon.length;\n    let prevIndex = nn - 2;\n    let inside = false;\n\n    for (let ii = 0; ii < nn; ii += 2) {\n      let vertexY = vertices[ii + 1];\n      let prevY = vertices[prevIndex + 1];\n\n      if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {\n        let vertexX = vertices[ii];\n        if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\n      }\n\n      prevIndex = ii;\n    }\n\n    return inside;\n  }\n  /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\r\n   * is usually more efficient to only call this method if {@link #aabbIntersectsSegment()} returns\r\n   * true. */\n\n\n  intersectsSegment(x1, y1, x2, y2) {\n    let polygons = this.polygons;\n\n    for (let i = 0, n = polygons.length; i < n; i++) if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\n\n    return null;\n  }\n  /** Returns true if the polygon contains any part of the line segment. */\n\n\n  intersectsSegmentPolygon(polygon, x1, y1, x2, y2) {\n    let vertices = polygon;\n    let nn = polygon.length;\n    let width12 = x1 - x2,\n        height12 = y1 - y2;\n    let det1 = x1 * y2 - y1 * x2;\n    let x3 = vertices[nn - 2],\n        y3 = vertices[nn - 1];\n\n    for (let ii = 0; ii < nn; ii += 2) {\n      let x4 = vertices[ii],\n          y4 = vertices[ii + 1];\n      let det2 = x3 * y4 - y3 * x4;\n      let width34 = x3 - x4,\n          height34 = y3 - y4;\n      let det3 = width12 * height34 - height12 * width34;\n      let x = (det1 * width34 - width12 * det2) / det3;\n\n      if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {\n        let y = (det1 * height34 - height12 * det2) / det3;\n        if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1)) return true;\n      }\n\n      x3 = x4;\n      y3 = y4;\n    }\n\n    return false;\n  }\n  /** Returns the polygon for the specified bounding box, or null. */\n\n\n  getPolygon(boundingBox) {\n    if (boundingBox == null) throw new Error(\"boundingBox cannot be null.\");\n    let index = this.boundingBoxes.indexOf(boundingBox);\n    return index == -1 ? null : this.polygons[index];\n  }\n  /** The width of the axis aligned bounding box. */\n\n\n  getWidth() {\n    return this.maxX - this.minX;\n  }\n  /** The height of the axis aligned bounding box. */\n\n\n  getHeight() {\n    return this.maxY - this.minY;\n  }\n\n}\n/** Loads skeleton data in the Spine JSON format.\r\n *\r\n * See [Spine JSON format](http://esotericsoftware.com/spine-json-format) and\r\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\r\n * Runtimes Guide.\r\n * @public\r\n * */\n\n\nclass SkeletonJson {\n  /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\r\n   * runtime than were used in Spine.\r\n   *\r\n   * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n  __init() {\n    this.scale = 1;\n  }\n\n  __init2() {\n    this.linkedMeshes = new Array();\n  }\n\n  constructor(attachmentLoader) {\n    SkeletonJson.prototype.__init.call(this);\n\n    SkeletonJson.prototype.__init2.call(this);\n\n    this.attachmentLoader = attachmentLoader;\n  }\n\n  readSkeletonData(json) {\n    let scale = this.scale;\n    let skeletonData = new SkeletonData();\n    let root = typeof json === \"string\" ? JSON.parse(json) : json; // Skeleton\n\n    let skeletonMap = root.skeleton;\n\n    if (skeletonMap) {\n      skeletonData.hash = skeletonMap.hash;\n      skeletonData.version = skeletonMap.spine;\n\n      if (skeletonData.version.substr(0, 3) !== '4.0') {\n        let error = `Spine 4.0 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;\n        console.error(error);\n      }\n\n      skeletonData.x = skeletonMap.x;\n      skeletonData.y = skeletonMap.y;\n      skeletonData.width = skeletonMap.width;\n      skeletonData.height = skeletonMap.height;\n      skeletonData.fps = skeletonMap.fps;\n      skeletonData.imagesPath = skeletonMap.images;\n    } // Bones\n\n\n    if (root.bones) {\n      for (let i = 0; i < root.bones.length; i++) {\n        let boneMap = root.bones[i];\n        let parent = null;\n        let parentName = getValue(boneMap, \"parent\", null);\n\n        if (parentName != null) {\n          parent = skeletonData.findBone(parentName);\n          if (parent == null) throw new Error(\"Parent bone not found: \" + parentName);\n        }\n\n        let data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n        data.length = getValue(boneMap, \"length\", 0) * scale;\n        data.x = getValue(boneMap, \"x\", 0) * scale;\n        data.y = getValue(boneMap, \"y\", 0) * scale;\n        data.rotation = getValue(boneMap, \"rotation\", 0);\n        data.scaleX = getValue(boneMap, \"scaleX\", 1);\n        data.scaleY = getValue(boneMap, \"scaleY\", 1);\n        data.shearX = getValue(boneMap, \"shearX\", 0);\n        data.shearY = getValue(boneMap, \"shearY\", 0);\n        data.transformMode = Utils.enumValue(TransformMode, getValue(boneMap, \"transform\", \"Normal\"));\n        data.skinRequired = getValue(boneMap, \"skin\", false);\n        let color = getValue(boneMap, \"color\", null);\n        if (color) data.color.setFromString(color);\n        skeletonData.bones.push(data);\n      }\n    } // Slots.\n\n\n    if (root.slots) {\n      for (let i = 0; i < root.slots.length; i++) {\n        let slotMap = root.slots[i];\n        let slotName = slotMap.name;\n        let boneName = slotMap.bone;\n        let boneData = skeletonData.findBone(boneName);\n        if (boneData == null) throw new Error(\"Slot bone not found: \" + boneName);\n        let data = new SlotData(skeletonData.slots.length, slotName, boneData);\n        let color = getValue(slotMap, \"color\", null);\n        if (color) data.color.setFromString(color);\n        let dark = getValue(slotMap, \"dark\", null);\n        if (dark) data.darkColor = Color.fromString(dark);\n        data.attachmentName = getValue(slotMap, \"attachment\", null);\n        data.blendMode = SkeletonJson.blendModeFromString(getValue(slotMap, \"blend\", \"normal\"));\n        skeletonData.slots.push(data);\n      }\n    } // IK constraints\n\n\n    if (root.ik) {\n      for (let i = 0; i < root.ik.length; i++) {\n        let constraintMap = root.ik[i];\n        let data = new IkConstraintData(constraintMap.name);\n        data.order = getValue(constraintMap, \"order\", 0);\n        data.skinRequired = getValue(constraintMap, \"skin\", false);\n\n        for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n          let boneName = constraintMap.bones[ii];\n          let bone = skeletonData.findBone(boneName);\n          if (bone == null) throw new Error(\"IK bone not found: \" + boneName);\n          data.bones.push(bone);\n        }\n\n        data.target = skeletonData.findBone(constraintMap.target);\n        data.mix = getValue(constraintMap, \"mix\", 1);\n        data.softness = getValue(constraintMap, \"softness\", 0) * scale;\n        data.bendDirection = getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\n        data.compress = getValue(constraintMap, \"compress\", false);\n        data.stretch = getValue(constraintMap, \"stretch\", false);\n        data.uniform = getValue(constraintMap, \"uniform\", false);\n        skeletonData.ikConstraints.push(data);\n      }\n    } // Transform constraints.\n\n\n    if (root.transform) {\n      for (let i = 0; i < root.transform.length; i++) {\n        let constraintMap = root.transform[i];\n        let data = new TransformConstraintData(constraintMap.name);\n        data.order = getValue(constraintMap, \"order\", 0);\n        data.skinRequired = getValue(constraintMap, \"skin\", false);\n\n        for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n          let boneName = constraintMap.bones[ii];\n          let bone = skeletonData.findBone(boneName);\n          if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\n          data.bones.push(bone);\n        }\n\n        let targetName = constraintMap.target;\n        data.target = skeletonData.findBone(targetName);\n        if (data.target == null) throw new Error(\"Transform constraint target bone not found: \" + targetName);\n        data.local = getValue(constraintMap, \"local\", false);\n        data.relative = getValue(constraintMap, \"relative\", false);\n        data.offsetRotation = getValue(constraintMap, \"rotation\", 0);\n        data.offsetX = getValue(constraintMap, \"x\", 0) * scale;\n        data.offsetY = getValue(constraintMap, \"y\", 0) * scale;\n        data.offsetScaleX = getValue(constraintMap, \"scaleX\", 0);\n        data.offsetScaleY = getValue(constraintMap, \"scaleY\", 0);\n        data.offsetShearY = getValue(constraintMap, \"shearY\", 0);\n        data.mixRotate = getValue(constraintMap, \"mixRotate\", 1);\n        data.mixX = getValue(constraintMap, \"mixX\", 1);\n        data.mixY = getValue(constraintMap, \"mixY\", data.mixX);\n        data.mixScaleX = getValue(constraintMap, \"mixScaleX\", 1);\n        data.mixScaleY = getValue(constraintMap, \"mixScaleY\", data.mixScaleX);\n        data.mixShearY = getValue(constraintMap, \"mixShearY\", 1);\n        skeletonData.transformConstraints.push(data);\n      }\n    } // Path constraints.\n\n\n    if (root.path) {\n      for (let i = 0; i < root.path.length; i++) {\n        let constraintMap = root.path[i];\n        let data = new PathConstraintData(constraintMap.name);\n        data.order = getValue(constraintMap, \"order\", 0);\n        data.skinRequired = getValue(constraintMap, \"skin\", false);\n\n        for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n          let boneName = constraintMap.bones[ii];\n          let bone = skeletonData.findBone(boneName);\n          if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\n          data.bones.push(bone);\n        }\n\n        let targetName = constraintMap.target;\n        data.target = skeletonData.findSlot(targetName);\n        if (data.target == null) throw new Error(\"Path target slot not found: \" + targetName);\n        data.positionMode = Utils.enumValue(PositionMode, getValue(constraintMap, \"positionMode\", \"Percent\"));\n        data.spacingMode = Utils.enumValue(SpacingMode, getValue(constraintMap, \"spacingMode\", \"Length\"));\n        data.rotateMode = Utils.enumValue(RotateMode, getValue(constraintMap, \"rotateMode\", \"Tangent\"));\n        data.offsetRotation = getValue(constraintMap, \"rotation\", 0);\n        data.position = getValue(constraintMap, \"position\", 0);\n        if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n        data.spacing = getValue(constraintMap, \"spacing\", 0);\n        if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n        data.mixRotate = getValue(constraintMap, \"mixRotate\", 1);\n        data.mixX = getValue(constraintMap, \"mixX\", 1);\n        data.mixY = getValue(constraintMap, \"mixY\", data.mixX);\n        skeletonData.pathConstraints.push(data);\n      }\n    } // Skins.\n\n\n    if (root.skins) {\n      for (let i = 0; i < root.skins.length; i++) {\n        let skinMap = root.skins[i];\n        let skin = new Skin(skinMap.name);\n\n        if (skinMap.bones) {\n          for (let ii = 0; ii < skinMap.bones.length; ii++) {\n            let bone = skeletonData.findBone(skinMap.bones[ii]);\n            if (bone == null) throw new Error(\"Skin bone not found: \" + skinMap.bones[i]);\n            skin.bones.push(bone);\n          }\n        }\n\n        if (skinMap.ik) {\n          for (let ii = 0; ii < skinMap.ik.length; ii++) {\n            let constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);\n            if (constraint == null) throw new Error(\"Skin IK constraint not found: \" + skinMap.ik[i]);\n            skin.constraints.push(constraint);\n          }\n        }\n\n        if (skinMap.transform) {\n          for (let ii = 0; ii < skinMap.transform.length; ii++) {\n            let constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);\n            if (constraint == null) throw new Error(\"Skin transform constraint not found: \" + skinMap.transform[i]);\n            skin.constraints.push(constraint);\n          }\n        }\n\n        if (skinMap.path) {\n          for (let ii = 0; ii < skinMap.path.length; ii++) {\n            let constraint = skeletonData.findPathConstraint(skinMap.path[ii]);\n            if (constraint == null) throw new Error(\"Skin path constraint not found: \" + skinMap.path[i]);\n            skin.constraints.push(constraint);\n          }\n        }\n\n        for (let slotName in skinMap.attachments) {\n          let slot = skeletonData.findSlot(slotName);\n          if (slot == null) throw new Error(\"Slot not found: \" + slotName);\n          let slotMap = skinMap.attachments[slotName];\n\n          for (let entryName in slotMap) {\n            let attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\n            if (attachment) skin.setAttachment(slot.index, entryName, attachment);\n          }\n        }\n\n        skeletonData.skins.push(skin);\n        if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n      }\n    } // Linked meshes.\n\n\n    for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n      let linkedMesh = this.linkedMeshes[i];\n      let skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n      let parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n      linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent : linkedMesh.mesh;\n      linkedMesh.mesh.setParentMesh(parent); // linkedMesh.mesh.updateUVs();\n    }\n\n    this.linkedMeshes.length = 0; // Events.\n\n    if (root.events) {\n      for (let eventName in root.events) {\n        let eventMap = root.events[eventName];\n        let data = new EventData(eventName);\n        data.intValue = getValue(eventMap, \"int\", 0);\n        data.floatValue = getValue(eventMap, \"float\", 0);\n        data.stringValue = getValue(eventMap, \"string\", \"\");\n        data.audioPath = getValue(eventMap, \"audio\", null);\n\n        if (data.audioPath) {\n          data.volume = getValue(eventMap, \"volume\", 1);\n          data.balance = getValue(eventMap, \"balance\", 0);\n        }\n\n        skeletonData.events.push(data);\n      }\n    } // Animations.\n\n\n    if (root.animations) {\n      for (let animationName in root.animations) {\n        let animationMap = root.animations[animationName];\n        this.readAnimation(animationMap, animationName, skeletonData);\n      }\n    }\n\n    return skeletonData;\n  }\n\n  readAttachment(map, skin, slotIndex, name, skeletonData) {\n    let scale = this.scale;\n    name = getValue(map, \"name\", name);\n\n    switch (getValue(map, \"type\", \"region\")) {\n      case \"region\":\n        {\n          let path = getValue(map, \"path\", name);\n          let region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n          if (!region) return null;\n          region.path = path;\n          region.x = getValue(map, \"x\", 0) * scale;\n          region.y = getValue(map, \"y\", 0) * scale;\n          region.scaleX = getValue(map, \"scaleX\", 1);\n          region.scaleY = getValue(map, \"scaleY\", 1);\n          region.rotation = getValue(map, \"rotation\", 0);\n          region.width = map.width * scale;\n          region.height = map.height * scale;\n          let color = getValue(map, \"color\", null);\n          if (color) region.color.setFromString(color); // region.updateOffset();\n\n          return region;\n        }\n\n      case \"boundingbox\":\n        {\n          let box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n          if (!box) return null;\n          this.readVertices(map, box, map.vertexCount << 1);\n          let color = getValue(map, \"color\", null);\n          if (color) box.color.setFromString(color);\n          return box;\n        }\n\n      case \"mesh\":\n      case \"linkedmesh\":\n        {\n          let path = getValue(map, \"path\", name);\n          let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n          if (!mesh) return null;\n          mesh.path = path;\n          let color = getValue(map, \"color\", null);\n          if (color) mesh.color.setFromString(color);\n          mesh.width = getValue(map, \"width\", 0) * scale;\n          mesh.height = getValue(map, \"height\", 0) * scale;\n          let parent = getValue(map, \"parent\", null);\n\n          if (parent) {\n            this.linkedMeshes.push(new LinkedMesh$1(mesh, getValue(map, \"skin\", null), slotIndex, parent, getValue(map, \"deform\", true)));\n            return mesh;\n          }\n\n          let uvs = map.uvs;\n          this.readVertices(map, mesh, uvs.length);\n          mesh.triangles = map.triangles;\n          mesh.regionUVs = new Float32Array(uvs); // mesh.updateUVs();\n\n          mesh.edges = getValue(map, \"edges\", null);\n          mesh.hullLength = getValue(map, \"hull\", 0) * 2;\n          return mesh;\n        }\n\n      case \"path\":\n        {\n          let path = this.attachmentLoader.newPathAttachment(skin, name);\n          if (!path) return null;\n          path.closed = getValue(map, \"closed\", false);\n          path.constantSpeed = getValue(map, \"constantSpeed\", true);\n          let vertexCount = map.vertexCount;\n          this.readVertices(map, path, vertexCount << 1);\n          let lengths = Utils.newArray(vertexCount / 3, 0);\n\n          for (let i = 0; i < map.lengths.length; i++) lengths[i] = map.lengths[i] * scale;\n\n          path.lengths = lengths;\n          let color = getValue(map, \"color\", null);\n          if (color) path.color.setFromString(color);\n          return path;\n        }\n\n      case \"point\":\n        {\n          let point = this.attachmentLoader.newPointAttachment(skin, name);\n          if (!point) return null;\n          point.x = getValue(map, \"x\", 0) * scale;\n          point.y = getValue(map, \"y\", 0) * scale;\n          point.rotation = getValue(map, \"rotation\", 0);\n          let color = getValue(map, \"color\", null);\n          if (color) point.color.setFromString(color);\n          return point;\n        }\n\n      case \"clipping\":\n        {\n          let clip = this.attachmentLoader.newClippingAttachment(skin, name);\n          if (!clip) return null;\n          let end = getValue(map, \"end\", null);\n\n          if (end != null) {\n            let slot = skeletonData.findSlot(end);\n            if (slot == null) throw new Error(\"Clipping end slot not found: \" + end);\n            clip.endSlot = slot;\n          }\n\n          let vertexCount = map.vertexCount;\n          this.readVertices(map, clip, vertexCount << 1);\n          let color = getValue(map, \"color\", null);\n          if (color) clip.color.setFromString(color);\n          return clip;\n        }\n    }\n\n    return null;\n  }\n\n  readVertices(map, attachment, verticesLength) {\n    let scale = this.scale;\n    attachment.worldVerticesLength = verticesLength;\n    let vertices = map.vertices;\n\n    if (verticesLength == vertices.length) {\n      let scaledVertices = Utils.toFloatArray(vertices);\n\n      if (scale != 1) {\n        for (let i = 0, n = vertices.length; i < n; i++) scaledVertices[i] *= scale;\n      }\n\n      attachment.vertices = scaledVertices;\n      return;\n    }\n\n    let weights = new Array();\n    let bones = new Array();\n\n    for (let i = 0, n = vertices.length; i < n;) {\n      let boneCount = vertices[i++];\n      bones.push(boneCount);\n\n      for (let nn = i + boneCount * 4; i < nn; i += 4) {\n        bones.push(vertices[i]);\n        weights.push(vertices[i + 1] * scale);\n        weights.push(vertices[i + 2] * scale);\n        weights.push(vertices[i + 3]);\n      }\n    }\n\n    attachment.bones = bones;\n    attachment.vertices = Utils.toFloatArray(weights);\n  }\n\n  readAnimation(map, name, skeletonData) {\n    let scale = this.scale;\n    let timelines = new Array(); // Slot timelines.\n\n    if (map.slots) {\n      for (let slotName in map.slots) {\n        let slotMap = map.slots[slotName];\n        let slotIndex = skeletonData.findSlotIndex(slotName);\n        if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\n\n        for (let timelineName in slotMap) {\n          let timelineMap = slotMap[timelineName];\n          if (!timelineMap) continue;\n\n          if (timelineName == \"attachment\") {\n            let timeline = new AttachmentTimeline(timelineMap.length, slotIndex);\n\n            for (let frame = 0; frame < timelineMap.length; frame++) {\n              let keyMap = timelineMap[frame];\n              timeline.setFrame(frame, getValue(keyMap, \"time\", 0), keyMap.name);\n            }\n\n            timelines.push(timeline);\n          } else if (timelineName == \"rgba\") {\n            let timeline = new RGBATimeline(timelineMap.length, timelineMap.length << 2, slotIndex);\n            let keyMap = timelineMap[0];\n            let time = getValue(keyMap, \"time\", 0);\n            let color = Color.fromString(keyMap.color);\n\n            for (let frame = 0, bezier = 0;; frame++) {\n              timeline.setFrame(frame, time, color.r, color.g, color.b, color.a);\n              let nextMap = timelineMap[frame + 1];\n\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n\n              let time2 = getValue(nextMap, \"time\", 0);\n              let newColor = Color.fromString(nextMap.color);\n              let curve = keyMap.curve;\n\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\n              }\n\n              time = time2;\n              color = newColor;\n              keyMap = nextMap;\n            }\n\n            timelines.push(timeline);\n          } else if (timelineName == \"rgb\") {\n            let timeline = new RGBTimeline(timelineMap.length, timelineMap.length * 3, slotIndex);\n            let keyMap = timelineMap[0];\n            let time = getValue(keyMap, \"time\", 0);\n            let color = Color.fromString(keyMap.color);\n\n            for (let frame = 0, bezier = 0;; frame++) {\n              timeline.setFrame(frame, time, color.r, color.g, color.b);\n              let nextMap = timelineMap[frame + 1];\n\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n\n              let time2 = getValue(nextMap, \"time\", 0);\n              let newColor = Color.fromString(nextMap.color);\n              let curve = keyMap.curve;\n\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n              }\n\n              time = time2;\n              color = newColor;\n              keyMap = nextMap;\n            }\n\n            timelines.push(timeline);\n          } else if (timelineName == \"alpha\") {\n            timelines.push(readTimeline1$1(timelineMap, new AlphaTimeline(timelineMap.length, timelineMap.length, slotIndex), 0, 1));\n          } else if (timelineName == \"rgba2\") {\n            let timeline = new RGBA2Timeline(timelineMap.length, timelineMap.length * 7, slotIndex);\n            let keyMap = timelineMap[0];\n            let time = getValue(keyMap, \"time\", 0);\n            let color = Color.fromString(keyMap.light);\n            let color2 = Color.fromString(keyMap.dark);\n\n            for (let frame = 0, bezier = 0;; frame++) {\n              timeline.setFrame(frame, time, color.r, color.g, color.b, color.a, color2.r, color2.g, color2.b);\n              let nextMap = timelineMap[frame + 1];\n\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n\n              let time2 = getValue(nextMap, \"time\", 0);\n              let newColor = Color.fromString(nextMap.light);\n              let newColor2 = Color.fromString(nextMap.dark);\n              let curve = keyMap.curve;\n\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.r, newColor2.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.g, newColor2.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 6, time, time2, color2.b, newColor2.b, 1);\n              }\n\n              time = time2;\n              color = newColor;\n              color2 = newColor2;\n              keyMap = nextMap;\n            }\n\n            timelines.push(timeline);\n          } else if (timelineName == \"rgb2\") {\n            let timeline = new RGB2Timeline(timelineMap.length, timelineMap.length * 6, slotIndex);\n            let keyMap = timelineMap[0];\n            let time = getValue(keyMap, \"time\", 0);\n            let color = Color.fromString(keyMap.light);\n            let color2 = Color.fromString(keyMap.dark);\n\n            for (let frame = 0, bezier = 0;; frame++) {\n              timeline.setFrame(frame, time, color.r, color.g, color.b, color2.r, color2.g, color2.b);\n              let nextMap = timelineMap[frame + 1];\n\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n\n              let time2 = getValue(nextMap, \"time\", 0);\n              let newColor = Color.fromString(nextMap.light);\n              let newColor2 = Color.fromString(nextMap.dark);\n              let curve = keyMap.curve;\n\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color2.r, newColor2.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.g, newColor2.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.b, newColor2.b, 1);\n              }\n\n              time = time2;\n              color = newColor;\n              color2 = newColor2;\n              keyMap = nextMap;\n            }\n\n            timelines.push(timeline);\n          } else throw new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\n        }\n      }\n    } // Bone timelines.\n\n\n    if (map.bones) {\n      for (let boneName in map.bones) {\n        let boneMap = map.bones[boneName];\n        let boneIndex = skeletonData.findBoneIndex(boneName);\n        if (boneIndex == -1) throw new Error(\"Bone not found: \" + boneName);\n\n        for (let timelineName in boneMap) {\n          let timelineMap = boneMap[timelineName];\n          if (timelineMap.length == 0) continue;\n\n          if (timelineName === \"rotate\") {\n            timelines.push(readTimeline1$1(timelineMap, new RotateTimeline(timelineMap.length, timelineMap.length, boneIndex), 0, 1));\n          } else if (timelineName === \"translate\") {\n            let timeline = new TranslateTimeline(timelineMap.length, timelineMap.length << 1, boneIndex);\n            timelines.push(readTimeline2$1(timelineMap, timeline, \"x\", \"y\", 0, scale));\n          } else if (timelineName === \"translatex\") {\n            let timeline = new TranslateXTimeline(timelineMap.length, timelineMap.length, boneIndex);\n            timelines.push(readTimeline1$1(timelineMap, timeline, 0, scale));\n          } else if (timelineName === \"translatey\") {\n            let timeline = new TranslateYTimeline(timelineMap.length, timelineMap.length, boneIndex);\n            timelines.push(readTimeline1$1(timelineMap, timeline, 0, scale));\n          } else if (timelineName === \"scale\") {\n            let timeline = new ScaleTimeline(timelineMap.length, timelineMap.length << 1, boneIndex);\n            timelines.push(readTimeline2$1(timelineMap, timeline, \"x\", \"y\", 1, 1));\n          } else if (timelineName === \"scalex\") {\n            let timeline = new ScaleXTimeline(timelineMap.length, timelineMap.length, boneIndex);\n            timelines.push(readTimeline1$1(timelineMap, timeline, 1, 1));\n          } else if (timelineName === \"scaley\") {\n            let timeline = new ScaleYTimeline(timelineMap.length, timelineMap.length, boneIndex);\n            timelines.push(readTimeline1$1(timelineMap, timeline, 1, 1));\n          } else if (timelineName === \"shear\") {\n            let timeline = new ShearTimeline(timelineMap.length, timelineMap.length << 1, boneIndex);\n            timelines.push(readTimeline2$1(timelineMap, timeline, \"x\", \"y\", 0, 1));\n          } else if (timelineName === \"shearx\") {\n            let timeline = new ShearXTimeline(timelineMap.length, timelineMap.length, boneIndex);\n            timelines.push(readTimeline1$1(timelineMap, timeline, 0, 1));\n          } else if (timelineName === \"sheary\") {\n            let timeline = new ShearYTimeline(timelineMap.length, timelineMap.length, boneIndex);\n            timelines.push(readTimeline1$1(timelineMap, timeline, 0, 1));\n          }\n        }\n      }\n    } // IK constraint timelines.\n\n\n    if (map.ik) {\n      for (let constraintName in map.ik) {\n        let constraintMap = map.ik[constraintName];\n        let keyMap = constraintMap[0];\n        if (!keyMap) continue;\n        let constraint = skeletonData.findIkConstraint(constraintName);\n        let constraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n        let timeline = new IkConstraintTimeline(constraintMap.length, constraintMap.length << 1, constraintIndex);\n        let time = getValue(keyMap, \"time\", 0);\n        let mix = getValue(keyMap, \"mix\", 1);\n        let softness = getValue(keyMap, \"softness\", 0) * scale;\n\n        for (let frame = 0, bezier = 0;; frame++) {\n          timeline.setFrame(frame, time, mix, softness, getValue(keyMap, \"bendPositive\", true) ? 1 : -1, getValue(keyMap, \"compress\", false), getValue(keyMap, \"stretch\", false));\n          let nextMap = constraintMap[frame + 1];\n\n          if (!nextMap) {\n            timeline.shrink(bezier);\n            break;\n          }\n\n          let time2 = getValue(nextMap, \"time\", 0);\n          let mix2 = getValue(nextMap, \"mix\", 1);\n          let softness2 = getValue(nextMap, \"softness\", 0) * scale;\n          let curve = keyMap.curve;\n\n          if (curve) {\n            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mix, mix2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, softness, softness2, scale);\n          }\n\n          time = time2;\n          mix = mix2;\n          softness = softness2;\n          keyMap = nextMap;\n        }\n\n        timelines.push(timeline);\n      }\n    } // Transform constraint timelines.\n\n\n    if (map.transform) {\n      for (let constraintName in map.transform) {\n        let timelineMap = map.transform[constraintName];\n        let keyMap = timelineMap[0];\n        if (!keyMap) continue;\n        let constraint = skeletonData.findTransformConstraint(constraintName);\n        let constraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n        let timeline = new TransformConstraintTimeline(timelineMap.length, timelineMap.length << 2, constraintIndex);\n        let time = getValue(keyMap, \"time\", 0);\n        let mixRotate = getValue(keyMap, \"mixRotate\", 1);\n        let mixX = getValue(keyMap, \"mixX\", 1);\n        let mixY = getValue(keyMap, \"mixY\", mixX);\n        let mixScaleX = getValue(keyMap, \"mixScaleX\", 1);\n        let mixScaleY = getValue(keyMap, \"mixScaleY\", mixScaleX);\n        let mixShearY = getValue(keyMap, \"mixShearY\", 1);\n\n        for (let frame = 0, bezier = 0;; frame++) {\n          timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\n          let nextMap = timelineMap[frame + 1];\n\n          if (!nextMap) {\n            timeline.shrink(bezier);\n            break;\n          }\n\n          let time2 = getValue(nextMap, \"time\", 0);\n          let mixRotate2 = getValue(nextMap, \"mixRotate\", 1);\n          let mixX2 = getValue(nextMap, \"mixX\", 1);\n          let mixY2 = getValue(nextMap, \"mixY\", mixX2);\n          let mixScaleX2 = getValue(nextMap, \"mixScaleX\", 1);\n          let mixScaleY2 = getValue(nextMap, \"mixScaleY\", mixScaleX2);\n          let mixShearY2 = getValue(nextMap, \"mixShearY\", 1);\n          let curve = keyMap.curve;\n\n          if (curve) {\n            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, mixShearY, mixShearY2, 1);\n          }\n\n          time = time2;\n          mixRotate = mixRotate2;\n          mixX = mixX2;\n          mixY = mixY2;\n          mixScaleX = mixScaleX2;\n          mixScaleY = mixScaleY2;\n          mixScaleX = mixScaleX2;\n          keyMap = nextMap;\n        }\n\n        timelines.push(timeline);\n      }\n    } // Path constraint timelines.\n\n\n    if (map.path) {\n      for (let constraintName in map.path) {\n        let constraintMap = map.path[constraintName];\n        let constraintIndex = skeletonData.findPathConstraintIndex(constraintName);\n        if (constraintIndex == -1) throw new Error(\"Path constraint not found: \" + constraintName);\n        let constraint = skeletonData.pathConstraints[constraintIndex];\n\n        for (let timelineName in constraintMap) {\n          let timelineMap = constraintMap[timelineName];\n          let keyMap = timelineMap[0];\n          if (!keyMap) continue;\n\n          if (timelineName === \"position\") {\n            let timeline = new PathConstraintPositionTimeline(timelineMap.length, timelineMap.length, constraintIndex);\n            timelines.push(readTimeline1$1(timelineMap, timeline, 0, constraint.positionMode == PositionMode.Fixed ? scale : 1));\n          } else if (timelineName === \"spacing\") {\n            let timeline = new PathConstraintSpacingTimeline(timelineMap.length, timelineMap.length, constraintIndex);\n            timelines.push(readTimeline1$1(timelineMap, timeline, 0, constraint.spacingMode == SpacingMode.Length || constraint.spacingMode == SpacingMode.Fixed ? scale : 1));\n          } else if (timelineName === \"mix\") {\n            let timeline = new PathConstraintMixTimeline(timelineMap.size, timelineMap.size * 3, constraintIndex);\n            let time = getValue(keyMap, \"time\", 0);\n            let mixRotate = getValue(keyMap, \"mixRotate\", 1);\n            let mixX = getValue(keyMap, \"mixX\", 1);\n            let mixY = getValue(keyMap, \"mixY\", mixX);\n\n            for (let frame = 0, bezier = 0;; frame++) {\n              timeline.setFrame(frame, time, mixRotate, mixX, mixY);\n              let nextMap = timelineMap[frame + 1];\n\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n\n              let time2 = getValue(nextMap, \"time\", 0);\n              let mixRotate2 = getValue(nextMap, \"mixRotate\", 1);\n              let mixX2 = getValue(nextMap, \"mixX\", 1);\n              let mixY2 = getValue(nextMap, \"mixY\", mixX2);\n              let curve = keyMap.curve;\n\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\n              }\n\n              time = time2;\n              mixRotate = mixRotate2;\n              mixX = mixX2;\n              mixY = mixY2;\n              keyMap = nextMap;\n            }\n\n            timelines.push(timeline);\n          }\n        }\n      }\n    } // Deform timelines.\n\n\n    if (map.deform) {\n      for (let deformName in map.deform) {\n        let deformMap = map.deform[deformName];\n        let skin = skeletonData.findSkin(deformName);\n\n        if (skin == null) {\n          if (settings.FAIL_ON_NON_EXISTING_SKIN) {\n            throw new Error(\"Skin not found: \" + deformName);\n          } else {\n            continue;\n          }\n        }\n\n        for (let slotName in deformMap) {\n          let slotMap = deformMap[slotName];\n          let slotIndex = skeletonData.findSlotIndex(slotName);\n          if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotMap.name);\n\n          for (let timelineName in slotMap) {\n            let timelineMap = slotMap[timelineName];\n            let keyMap = timelineMap[0];\n            if (!keyMap) continue;\n            let attachment = skin.getAttachment(slotIndex, timelineName);\n            if (attachment == null) throw new Error(\"Deform attachment not found: \" + timelineMap.name);\n            let weighted = attachment.bones != null;\n            let vertices = attachment.vertices;\n            let deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n            let timeline = new DeformTimeline(timelineMap.length, timelineMap.length, slotIndex, attachment);\n            let time = getValue(keyMap, \"time\", 0);\n\n            for (let frame = 0, bezier = 0;; frame++) {\n              let deform;\n              let verticesValue = getValue(keyMap, \"vertices\", null);\n              if (!verticesValue) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;else {\n                deform = Utils.newFloatArray(deformLength);\n                let start = getValue(keyMap, \"offset\", 0);\n                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n\n                if (scale != 1) {\n                  for (let i = start, n = i + verticesValue.length; i < n; i++) deform[i] *= scale;\n                }\n\n                if (!weighted) {\n                  for (let i = 0; i < deformLength; i++) deform[i] += vertices[i];\n                }\n              }\n              timeline.setFrame(frame, time, deform);\n              let nextMap = timelineMap[frame + 1];\n\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n\n              let time2 = getValue(nextMap, \"time\", 0);\n              let curve = keyMap.curve;\n              if (curve) bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, 0, 1, 1);\n              time = time2;\n              keyMap = nextMap;\n            }\n\n            timelines.push(timeline);\n          }\n        }\n      }\n    } // Draw order timelines.\n\n\n    if (map.drawOrder) {\n      let timeline = new DrawOrderTimeline(map.drawOrder.length);\n      let slotCount = skeletonData.slots.length;\n      let frame = 0;\n\n      for (let i = 0; i < map.drawOrder.length; i++, frame++) {\n        let drawOrderMap = map.drawOrder[i];\n        let drawOrder = null;\n        let offsets = getValue(drawOrderMap, \"offsets\", null);\n\n        if (offsets) {\n          drawOrder = Utils.newArray(slotCount, -1);\n          let unchanged = Utils.newArray(slotCount - offsets.length, 0);\n          let originalIndex = 0,\n              unchangedIndex = 0;\n\n          for (let ii = 0; ii < offsets.length; ii++) {\n            let offsetMap = offsets[ii];\n            let slotIndex = skeletonData.findSlotIndex(offsetMap.slot); // Collect unchanged items.\n\n            while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++; // Set changed items.\n\n\n            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n          } // Collect remaining unchanged items.\n\n\n          while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++; // Fill in unchanged items.\n\n\n          for (let ii = slotCount - 1; ii >= 0; ii--) if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n        }\n\n        timeline.setFrame(frame, getValue(drawOrderMap, \"time\", 0), drawOrder);\n      }\n\n      timelines.push(timeline);\n    } // Event timelines.\n\n\n    if (map.events) {\n      let timeline = new EventTimeline(map.events.length);\n      let frame = 0;\n\n      for (let i = 0; i < map.events.length; i++, frame++) {\n        let eventMap = map.events[i];\n        let eventData = skeletonData.findEvent(eventMap.name);\n        let event = new Event(Utils.toSinglePrecision(getValue(eventMap, \"time\", 0)), eventData);\n        event.intValue = getValue(eventMap, \"int\", eventData.intValue);\n        event.floatValue = getValue(eventMap, \"float\", eventData.floatValue);\n        event.stringValue = getValue(eventMap, \"string\", eventData.stringValue);\n\n        if (event.data.audioPath) {\n          event.volume = getValue(eventMap, \"volume\", 1);\n          event.balance = getValue(eventMap, \"balance\", 0);\n        }\n\n        timeline.setFrame(frame, event);\n      }\n\n      timelines.push(timeline);\n    }\n\n    let duration = 0;\n\n    for (let i = 0, n = timelines.length; i < n; i++) duration = Math.max(duration, timelines[i].getDuration());\n\n    if (isNaN(duration)) {\n      throw new Error(\"Error while parsing animation, duration is NaN\");\n    }\n\n    skeletonData.animations.push(new Animation(name, timelines, duration));\n  }\n\n  static blendModeFromString(str) {\n    str = str.toLowerCase();\n    if (str == \"normal\") return BLEND_MODES.NORMAL;\n    if (str == \"additive\") return BLEND_MODES.ADD;\n    if (str == \"multiply\") return BLEND_MODES.MULTIPLY;\n    if (str == \"screen\") return BLEND_MODES.SCREEN;\n    throw new Error(`Unknown blend mode: ${str}`);\n  }\n\n}\n\nclass LinkedMesh$1 {\n  constructor(mesh, skin, slotIndex, parent, inheritDeform) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n    this.inheritDeform = inheritDeform;\n  }\n\n}\n\nfunction readTimeline1$1(keys, timeline, defaultValue, scale) {\n  let keyMap = keys[0];\n  let time = getValue(keyMap, \"time\", 0);\n  let value = getValue(keyMap, \"value\", defaultValue) * scale;\n  let bezier = 0;\n\n  for (let frame = 0;; frame++) {\n    timeline.setFrame(frame, time, value);\n    let nextMap = keys[frame + 1];\n\n    if (!nextMap) {\n      timeline.shrink(bezier);\n      return timeline;\n    }\n\n    let time2 = getValue(nextMap, \"time\", 0);\n    let value2 = getValue(nextMap, \"value\", defaultValue) * scale;\n    if (keyMap.curve) bezier = readCurve(keyMap.curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);\n    time = time2;\n    value = value2;\n    keyMap = nextMap;\n  }\n}\n\nfunction readTimeline2$1(keys, timeline, name1, name2, defaultValue, scale) {\n  let keyMap = keys[0];\n  let time = getValue(keyMap, \"time\", 0);\n  let value1 = getValue(keyMap, name1, defaultValue) * scale;\n  let value2 = getValue(keyMap, name2, defaultValue) * scale;\n  let bezier = 0;\n\n  for (let frame = 0;; frame++) {\n    timeline.setFrame(frame, time, value1, value2);\n    let nextMap = keys[frame + 1];\n\n    if (!nextMap) {\n      timeline.shrink(bezier);\n      return timeline;\n    }\n\n    let time2 = getValue(nextMap, \"time\", 0);\n    let nvalue1 = getValue(nextMap, name1, defaultValue) * scale;\n    let nvalue2 = getValue(nextMap, name2, defaultValue) * scale;\n    let curve = keyMap.curve;\n\n    if (curve) {\n      bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);\n      bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);\n    }\n\n    time = time2;\n    value1 = nvalue1;\n    value2 = nvalue2;\n    keyMap = nextMap;\n  }\n}\n\nfunction readCurve(curve, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {\n  if (curve == \"stepped\") {\n    timeline.setStepped(frame);\n    return bezier;\n  }\n\n  let i = value << 2;\n  let cx1 = curve[i];\n  let cy1 = curve[i + 1] * scale;\n  let cx2 = curve[i + 2];\n  let cy2 = curve[i + 3] * scale;\n  timeline.setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);\n  return bezier + 1;\n}\n\nfunction getValue(map, property, defaultValue) {\n  return map[property] !== undefined ? map[property] : defaultValue;\n}\n/**\r\n * @public\r\n */\n\n\nclass Spine extends SpineBase {\n  createSkeleton(spineData) {\n    this.skeleton = new Skeleton(spineData);\n    this.skeleton.updateWorldTransform();\n    this.stateData = new AnimationStateData(spineData);\n    this.state = new AnimationState(this.stateData);\n  }\n\n}\n\nexport { AlphaTimeline, Animation, AnimationState, AnimationStateAdapter, AnimationStateData, AtlasAttachmentLoader, Attachment, AttachmentTimeline, Bone, BoneData, BoundingBoxAttachment, ClippingAttachment, ConstraintData, CurveTimeline, CurveTimeline1, CurveTimeline2, DeformTimeline, DrawOrderTimeline, Event, EventData, EventQueue, EventTimeline, EventType, IkConstraint, IkConstraintData, IkConstraintTimeline, JitterEffect, MeshAttachment, MixBlend, MixDirection, PathAttachment, PathConstraint, PathConstraintData, PathConstraintMixTimeline, PathConstraintPositionTimeline, PathConstraintSpacingTimeline, PointAttachment, PositionMode, RGB2Timeline, RGBA2Timeline, RGBATimeline, RGBTimeline, RegionAttachment, RotateMode, RotateTimeline, ScaleTimeline, ScaleXTimeline, ScaleYTimeline, ShearTimeline, ShearXTimeline, ShearYTimeline, Skeleton, SkeletonBinary, SkeletonBounds, SkeletonData, SkeletonJson, Skin, SkinEntry, Slot, SlotData, SpacingMode, Spine, SwirlEffect, Timeline, TrackEntry, TransformConstraint, TransformConstraintData, TransformConstraintTimeline, TransformMode, TranslateTimeline, TranslateXTimeline, TranslateYTimeline, VertexAttachment };","map":{"version":3,"sources":["../src/core/attachments/Attachment.ts","../src/core/attachments/BoundingBoxAttachment.ts","../src/core/attachments/ClippingAttachment.ts","../src/core/attachments/MeshAttachment.ts","../src/core/attachments/PathAttachment.ts","../src/core/attachments/PointAttachment.ts","../src/core/attachments/RegionAttachment.ts","../src/core/vertexeffects/JitterEffect.ts","../src/core/vertexeffects/SwirlEffect.ts","../src/core/Animation.ts","../src/core/AnimationState.ts","../src/core/AnimationStateData.ts","../src/core/AtlasAttachmentLoader.ts","../src/core/BoneData.ts","../src/core/Bone.ts","../src/core/ConstraintData.ts","../src/core/Event.ts","../src/core/EventData.ts","../src/core/IkConstraint.ts","../src/core/IkConstraintData.ts","../src/core/PathConstraintData.ts","../src/core/PathConstraint.ts","../src/core/Slot.ts","../src/core/TransformConstraint.ts","../src/core/Skeleton.ts","../src/core/SkeletonData.ts","../src/core/SlotData.ts","../src/core/TransformConstraintData.ts","../src/core/Skin.ts","../src/core/SkeletonBinary.ts","../src/core/SkeletonBounds.ts","../src/core/SkeletonJson.ts","../src/Spine.ts"],"names":[],"mappings":"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AAA,GAAA,CAAA;AAAA;;AAEA,SAAA,aAAA,GAAA;AAAA,SAAA,EAAA,GAAA,CAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,EAAA,GAAA,CAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,GAAA,GAAA,CAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,GAAA,GAAA,CAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,GAAA,GAAA,CAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,GAAA,GAAA,CAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,EAAA,GAAA,CAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,EAAA,GAAA,CAAA;AAAA;;AAEA,SAAA,cAAA,GAAA;AAAA,SAAA,EAAA,GAAA,CAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,EAAA,GAAA,CAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,GAAA,GAAA,EAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,GAAA,GAAA,EAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,GAAA,GAAA,EAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,GAAA,GAAA,EAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,EAAA,GAAA,EAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,EAAA,GAAA,EAAA;AAAA;;AAEA,SAAA,cAAA,GAAA;AAAA,SAAA,EAAA,GAAA,EAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,EAAA,GAAA,EAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,GAAA,GAAA,EAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,GAAA,GAAA,EAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,GAAA,GAAA,EAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,GAAA,GAAA,EAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,EAAA,GAAA,EAAA;AAAA;;AACA,SA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","sourcesContent":["import {AttachmentType, Utils} from '@pixi-spine/base';\r\nimport type {IAttachment, ArrayLike} from '@pixi-spine/base';\r\n\r\nimport type {Slot} from '../Slot';\r\n\r\n/**\r\n * The base class for all attachments.\r\n * @public\r\n */\r\nexport abstract class Attachment implements IAttachment {\r\n    name: string;\r\n    type: AttachmentType;\r\n\r\n    constructor (name: string) {\r\n        if (!name) throw new Error(\"name cannot be null.\");\r\n        this.name = name;\r\n    }\r\n\r\n    abstract copy (): Attachment;\r\n}\r\n\r\n/**\r\n * Base class for an attachment with vertices that are transformed by one or more bones and can be deformed by a slot's\r\n * {@link Slot#deform}.\r\n * @public\r\n */\r\nexport abstract class VertexAttachment extends Attachment {\r\n    private static nextID = 0;\r\n\r\n    /** The unique ID for this attachment. */\r\n    id = VertexAttachment.nextID++;\r\n\r\n    /** The bones which affect the {@link #getVertices()}. The array entries are, for each vertex, the number of bones affecting\r\n     * the vertex followed by that many bone indices, which is the index of the bone in {@link Skeleton#bones}. Will be null\r\n     * if this attachment has no weights. */\r\n    bones: Array<number>;\r\n\r\n    /** The vertex positions in the bone's coordinate system. For a non-weighted attachment, the values are `x,y`\r\n     * entries for each vertex. For a weighted attachment, the values are `x,y,weight` entries for each bone affecting\r\n     * each vertex. */\r\n    vertices: ArrayLike<number>;\r\n\r\n    /** The maximum number of world vertex values that can be output by\r\n     * {@link #computeWorldVertices()} using the `count` parameter. */\r\n    worldVerticesLength = 0;\r\n\r\n    /** Deform keys for the deform attachment are also applied to this attachment. May be null if no deform keys should be applied. */\r\n    deformAttachment: VertexAttachment = this;\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n\r\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>) {\r\n        this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\r\n    }\r\n    /** Transforms the attachment's local {@link #vertices} to world coordinates. If the slot's {@link Slot#deform} is\r\n     * not empty, it is used to deform the vertices.\r\n     *\r\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\r\n     * Runtimes Guide.\r\n     * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.\r\n     * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.\r\n     * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *\r\n     *           `stride` / 2.\r\n     * @param offset The `worldVertices` index to begin writing values.\r\n     * @param stride The number of `worldVertices` entries between the value pairs written. */\r\n    computeWorldVertices (slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number, stride: number) {\r\n        count = offset + (count >> 1) * stride;\r\n        let skeleton = slot.bone.skeleton;\r\n        let deformArray = slot.deform;\r\n        let vertices = this.vertices;\r\n        let bones = this.bones;\r\n        if (!bones) {\r\n            if (deformArray.length > 0) vertices = deformArray;\r\n            let mat = slot.bone.matrix;\r\n            let x = mat.tx;\r\n            let y = mat.ty;\r\n            let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n            for (let v = start, w = offset; w < count; v += 2, w += stride) {\r\n                let vx = vertices[v], vy = vertices[v + 1];\r\n                worldVertices[w] = vx * a + vy * b + x;\r\n                worldVertices[w + 1] = vx * c + vy * d + y;\r\n            }\r\n            return;\r\n        }\r\n        let v = 0, skip = 0;\r\n        for (let i = 0; i < start; i += 2) {\r\n            let n = bones[v];\r\n            v += n + 1;\r\n            skip += n;\r\n        }\r\n        let skeletonBones = skeleton.bones;\r\n        if (deformArray.length == 0) {\r\n            for (let w = offset, b = skip * 3; w < count; w += stride) {\r\n                let wx = 0, wy = 0;\r\n                let n = bones[v++];\r\n                n += v;\r\n                for (; v < n; v++, b += 3) {\r\n                    let mat = skeletonBones[bones[v]].matrix;\r\n                    let vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\r\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx;\r\n                worldVertices[w + 1] = wy;\r\n            }\r\n        } else {\r\n            let deform = deformArray;\r\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\r\n                let wx = 0, wy = 0;\r\n                let n = bones[v++];\r\n                n += v;\r\n                for (; v < n; v++, b += 3, f += 2) {\r\n                    let mat = skeletonBones[bones[v]].matrix;\r\n                    let vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];\r\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx;\r\n                worldVertices[w + 1] = wy;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Does not copy id (generated) or name (set on construction). **/\r\n    copyTo (attachment: VertexAttachment) {\r\n        if (this.bones) {\r\n            attachment.bones = new Array<number>(this.bones.length);\r\n            Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\r\n        } else\r\n            attachment.bones = null;\r\n\r\n        if (this.vertices) {\r\n            attachment.vertices = Utils.newFloatArray(this.vertices.length);\r\n            Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\r\n        } else\r\n            attachment.vertices = null;\r\n\r\n        attachment.worldVerticesLength = this.worldVerticesLength;\r\n        attachment.deformAttachment = this.deformAttachment;\r\n    }\r\n}\r\n","import {Attachment, VertexAttachment} from './Attachment';\r\nimport {AttachmentType, Color} from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class BoundingBoxAttachment extends VertexAttachment {\r\n    type = AttachmentType.BoundingBox;\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n\r\n    copy (): Attachment {\r\n        let copy = new BoundingBoxAttachment(this.name);\r\n        this.copyTo(copy);\r\n        copy.color.setFromColor(this.color);\r\n        return copy;\r\n    }\r\n}\r\n","import {Attachment, VertexAttachment} from './Attachment';\r\nimport {AttachmentType, Color, IClippingAttachment} from '@pixi-spine/base';\r\nimport type {SlotData} from '../SlotData';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class ClippingAttachment extends VertexAttachment implements IClippingAttachment {\r\n    type = AttachmentType.Clipping;\r\n    endSlot: SlotData;\r\n\r\n    // Nonessential.\r\n    /** The color of the clipping polygon as it was in Spine. Available only when nonessential data was exported. Clipping polygons\r\n     * are not usually rendered at runtime. */\r\n    color = new Color(0.2275, 0.2275, 0.8078, 1); // ce3a3aff\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n\r\n    copy (): Attachment {\r\n        let copy = new ClippingAttachment(this.name);\r\n        this.copyTo(copy);\r\n        copy.endSlot = this.endSlot;\r\n        copy.color.setFromColor(this.color);\r\n        return copy;\r\n    }\r\n}\r\n","import {Attachment, VertexAttachment} from './Attachment';\r\nimport {AttachmentType, Color, IMeshAttachment, TextureRegion, Utils} from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class MeshAttachment extends VertexAttachment implements IMeshAttachment {\r\n    type = AttachmentType.Mesh;\r\n\r\n    region: TextureRegion;\r\n\r\n    /** The name of the texture region for this attachment. */\r\n    path: string;\r\n\r\n    /** The UV pair for each vertex, normalized within the texture region. */\r\n    regionUVs: Float32Array;\r\n\r\n    /** Triplets of vertex indices which describe the mesh's triangulation. */\r\n    triangles: Array<number>;\r\n\r\n    /** The color to tint the mesh. */\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    /** The width of the mesh's image. Available only when nonessential data was exported. */\r\n    width: number;\r\n\r\n    /** The height of the mesh's image. Available only when nonessential data was exported. */\r\n    height: number;\r\n\r\n    /** The number of entries at the beginning of {@link #vertices} that make up the mesh hull. */\r\n    hullLength: number;\r\n\r\n    /** Vertex index pairs describing edges for controling triangulation. Mesh triangles will never cross edges. Only available if\r\n     * nonessential data was exported. Triangulation is not performed at runtime. */\r\n    edges: Array<number>;\r\n\r\n    private parentMesh: MeshAttachment;\r\n    tempColor = new Color(0, 0, 0, 0);\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n\r\n    /** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},\r\n     * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the\r\n     * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */\r\n    getParentMesh () {\r\n        return this.parentMesh;\r\n    }\r\n\r\n    /** @param parentMesh May be null. */\r\n    setParentMesh (parentMesh: MeshAttachment) {\r\n        this.parentMesh = parentMesh;\r\n        if (parentMesh) {\r\n            this.bones = parentMesh.bones;\r\n            this.vertices = parentMesh.vertices;\r\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\r\n            this.regionUVs = parentMesh.regionUVs;\r\n            this.triangles = parentMesh.triangles;\r\n            this.hullLength = parentMesh.hullLength;\r\n            this.worldVerticesLength = parentMesh.worldVerticesLength\r\n        }\r\n    }\r\n\r\n    copy (): Attachment {\r\n        if (this.parentMesh) return this.newLinkedMesh();\r\n\r\n        let copy = new MeshAttachment(this.name);\r\n        copy.region = this.region;\r\n        copy.path = this.path;\r\n        copy.color.setFromColor(this.color);\r\n\r\n        this.copyTo(copy);\r\n        copy.regionUVs = new Float32Array(this.regionUVs.length);\r\n        Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\r\n        copy.triangles = new Array<number>(this.triangles.length);\r\n        Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\r\n        copy.hullLength = this.hullLength;\r\n\r\n        // Nonessential.\r\n        if (this.edges) {\r\n            copy.edges = new Array<number>(this.edges.length);\r\n            Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\r\n        }\r\n        copy.width = this.width;\r\n        copy.height = this.height;\r\n\r\n        return copy;\r\n    }\r\n\r\n    /** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/\r\n    newLinkedMesh (): MeshAttachment {\r\n        let copy = new MeshAttachment(this.name);\r\n        copy.region = this.region;\r\n        copy.path = this.path;\r\n        copy.color.setFromColor(this.color);\r\n        copy.deformAttachment = this.deformAttachment;\r\n        copy.setParentMesh(this.parentMesh ? this.parentMesh : this);\r\n        // copy.updateUVs();\r\n        return copy;\r\n    }\r\n}\r\n","import {Attachment, VertexAttachment} from \"./Attachment\";\r\nimport {AttachmentType, Color, Utils} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PathAttachment extends VertexAttachment {\r\n    type = AttachmentType.Path;\r\n\r\n    /** The lengths along the path in the setup pose from the start of the path to the end of each Bezier curve. */\r\n    lengths: Array<number>;\r\n\r\n    /** If true, the start and end knots are connected. */\r\n    closed = false;\r\n\r\n    /** If true, additional calculations are performed to make calculating positions along the path more accurate. If false, fewer\r\n     * calculations are performed but calculating positions along the path is less accurate. */\r\n    constantSpeed = false;\r\n\r\n    /** The color of the path as it was in Spine. Available only when nonessential data was exported. Paths are not usually\r\n     * rendered at runtime. */\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n\r\n    copy (): Attachment {\r\n        let copy = new PathAttachment(this.name);\r\n        this.copyTo(copy);\r\n        copy.lengths = new Array<number>(this.lengths.length);\r\n        Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\r\n        copy.closed = closed;\r\n        copy.constantSpeed = this.constantSpeed;\r\n        copy.color.setFromColor(this.color);\r\n        return copy;\r\n    }\r\n}\r\n","import {Attachment, VertexAttachment} from './Attachment';\r\nimport {AttachmentType, Color, MathUtils, Vector2} from \"@pixi-spine/base\";\r\nimport type {Bone} from '../Bone';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PointAttachment extends VertexAttachment {\r\n    type = AttachmentType.Point;\r\n\r\n    x: number; y: number; rotation: number;\r\n\r\n    /** The color of the point attachment as it was in Spine. Available only when nonessential data was exported. Point attachments\r\n     * are not usually rendered at runtime. */\r\n    color = new Color(0.38, 0.94, 0, 1);\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n\r\n    computeWorldPosition (bone: Bone, point: Vector2) {\r\n        const mat = bone.matrix;\r\n        point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\r\n        point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\r\n        return point;\r\n    }\r\n\r\n    computeWorldRotation (bone: Bone) {\r\n        const mat = bone.matrix;\r\n        let cos = MathUtils.cosDeg(this.rotation), sin = MathUtils.sinDeg(this.rotation);\r\n        let x = cos * mat.a + sin * mat.c;\r\n        let y = cos * mat.b + sin * mat.d;\r\n        return Math.atan2(y, x) * MathUtils.radDeg;\r\n    }\r\n\r\n    copy (): Attachment {\r\n        let copy = new PointAttachment(this.name);\r\n        copy.x = this.x;\r\n        copy.y = this.y;\r\n        copy.rotation = this.rotation;\r\n        copy.color.setFromColor(this.color);\r\n        return copy;\r\n    }\r\n}\r\n","import {Attachment} from './Attachment';\r\nimport {AttachmentType, ArrayLike, Color, TextureRegion, Utils, IRegionAttachment} from \"@pixi-spine/base\";\r\n\r\nimport type {Bone} from '../Bone';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class RegionAttachment extends Attachment implements IRegionAttachment {\r\n    type = AttachmentType.Region;\r\n\r\n    static OX1 = 0;\r\n    static OY1 = 1;\r\n    static OX2 = 2;\r\n    static OY2 = 3;\r\n    static OX3 = 4;\r\n    static OY3 = 5;\r\n    static OX4 = 6;\r\n    static OY4 = 7;\r\n\r\n    static X1 = 0;\r\n    static Y1 = 1;\r\n    static C1R = 2;\r\n    static C1G = 3;\r\n    static C1B = 4;\r\n    static C1A = 5;\r\n    static U1 = 6;\r\n    static V1 = 7;\r\n\r\n    static X2 = 8;\r\n    static Y2 = 9;\r\n    static C2R = 10;\r\n    static C2G = 11;\r\n    static C2B = 12;\r\n    static C2A = 13;\r\n    static U2 = 14;\r\n    static V2 = 15;\r\n\r\n    static X3 = 16;\r\n    static Y3 = 17;\r\n    static C3R = 18;\r\n    static C3G = 19;\r\n    static C3B = 20;\r\n    static C3A = 21;\r\n    static U3 = 22;\r\n    static V3 = 23;\r\n\r\n    static X4 = 24;\r\n    static Y4 = 25;\r\n    static C4R = 26;\r\n    static C4G = 27;\r\n    static C4B = 28;\r\n    static C4A = 29;\r\n    static U4 = 30;\r\n    static V4 = 31;\r\n\r\n    /** The local x translation. */\r\n    x = 0;\r\n\r\n    /** The local y translation. */\r\n    y = 0;\r\n\r\n    /** The local scaleX. */\r\n    scaleX = 1;\r\n\r\n    /** The local scaleY. */\r\n    scaleY = 1;\r\n\r\n    /** The local rotation. */\r\n    rotation = 0;\r\n\r\n    /** The width of the region attachment in Spine. */\r\n    width = 0;\r\n\r\n    /** The height of the region attachment in Spine. */\r\n    height = 0;\r\n\r\n    /** The color to tint the region attachment. */\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    /** The name of the texture region for this attachment. */\r\n    path: string;\r\n\r\n    rendererObject: any;\r\n    region: TextureRegion;\r\n\r\n    /** For each of the 4 vertices, a pair of <code>x,y</code> values that is the local position of the vertex.\r\n     *\r\n     * See {@link #updateOffset()}. */\r\n    offset = Utils.newFloatArray(8);\r\n\r\n\r\n    uvs = Utils.newFloatArray(8);\r\n\r\n    tempColor = new Color(1, 1, 1, 1);\r\n\r\n    constructor (name:string) {\r\n        super(name);\r\n    }\r\n\r\n    /** Calculates the {@link #offset} using the region settings. Must be called after changing region settings. */\r\n    updateOffset () : void {\r\n        let regionScaleX = this.width / this.region.originalWidth * this.scaleX;\r\n        let regionScaleY = this.height / this.region.originalHeight * this.scaleY;\r\n        let localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\r\n        let localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\r\n        let localX2 = localX + this.region.width * regionScaleX;\r\n        let localY2 = localY + this.region.height * regionScaleY;\r\n        let radians = this.rotation * Math.PI / 180;\r\n        let cos = Math.cos(radians);\r\n        let sin = Math.sin(radians);\r\n        let localXCos = localX * cos + this.x;\r\n        let localXSin = localX * sin;\r\n        let localYCos = localY * cos + this.y;\r\n        let localYSin = localY * sin;\r\n        let localX2Cos = localX2 * cos + this.x;\r\n        let localX2Sin = localX2 * sin;\r\n        let localY2Cos = localY2 * cos + this.y;\r\n        let localY2Sin = localY2 * sin;\r\n        let offset = this.offset;\r\n        offset[RegionAttachment.OX1] = localXCos - localYSin;\r\n        offset[RegionAttachment.OY1] = localYCos + localXSin;\r\n        offset[RegionAttachment.OX2] = localXCos - localY2Sin;\r\n        offset[RegionAttachment.OY2] = localY2Cos + localXSin;\r\n        offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\r\n        offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\r\n        offset[RegionAttachment.OX4] = localX2Cos - localYSin;\r\n        offset[RegionAttachment.OY4] = localYCos + localX2Sin;\r\n    }\r\n\r\n    setRegion (region: TextureRegion) : void {\r\n        this.region = region;\r\n        let uvs = this.uvs;\r\n        if (region.degrees == 90) {\r\n            uvs[2] = region.u;\r\n            uvs[3] = region.v2;\r\n            uvs[4] = region.u;\r\n            uvs[5] = region.v;\r\n            uvs[6] = region.u2;\r\n            uvs[7] = region.v;\r\n            uvs[0] = region.u2;\r\n            uvs[1] = region.v2;\r\n        } else {\r\n            uvs[0] = region.u;\r\n            uvs[1] = region.v2;\r\n            uvs[2] = region.u;\r\n            uvs[3] = region.v;\r\n            uvs[4] = region.u2;\r\n            uvs[5] = region.v;\r\n            uvs[6] = region.u2;\r\n            uvs[7] = region.v2;\r\n        }\r\n    }\r\n\r\n    /** Transforms the attachment's four vertices to world coordinates.\r\n     *\r\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\r\n     * Runtimes Guide.\r\n     * @param worldVertices The output world vertices. Must have a length >= `offset` + 8.\r\n     * @param offset The `worldVertices` index to begin writing values.\r\n     * @param stride The number of `worldVertices` entries between the value pairs written. */\r\n    computeWorldVertices (bone: Bone, worldVertices: ArrayLike<number>, offset: number, stride: number) {\r\n        let vertexOffset = this.offset;\r\n        let mat = bone.matrix;\r\n        let x = mat.tx, y = mat.ty;\r\n        let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n        let offsetX = 0, offsetY = 0;\r\n\r\n        offsetX = vertexOffset[RegionAttachment.OX1];\r\n        offsetY = vertexOffset[RegionAttachment.OY1];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // br\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        offset += stride;\r\n\r\n        offsetX = vertexOffset[RegionAttachment.OX2];\r\n        offsetY = vertexOffset[RegionAttachment.OY2];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // bl\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        offset += stride;\r\n\r\n        offsetX = vertexOffset[RegionAttachment.OX3];\r\n        offsetY = vertexOffset[RegionAttachment.OY3];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ul\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        offset += stride;\r\n\r\n        offsetX = vertexOffset[RegionAttachment.OX4];\r\n        offsetY = vertexOffset[RegionAttachment.OY4];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ur\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n    }\r\n\r\n    copy (): Attachment {\r\n        let copy = new RegionAttachment(this.name);\r\n        copy.region = this.region;\r\n        copy.rendererObject = this.rendererObject;\r\n        copy.path = this.path;\r\n        copy.x = this.x;\r\n        copy.y = this.y;\r\n        copy.scaleX = this.scaleX;\r\n        copy.scaleY = this.scaleY;\r\n        copy.rotation = this.rotation;\r\n        copy.width = this.width;\r\n        copy.height = this.height;\r\n        Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\r\n        Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\r\n        copy.color.setFromColor(this.color);\r\n        return copy;\r\n    }\r\n}\r\n","import {VertexEffect} from \"../VertexEffect\";\r\nimport type {Skeleton} from \"../Skeleton\";\r\nimport {Color, MathUtils, Vector2} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class JitterEffect implements VertexEffect {\r\n    jitterX = 0;\r\n    jitterY = 0;\r\n\r\n    constructor (jitterX: number, jitterY: number) {\r\n        this.jitterX = jitterX;\r\n        this.jitterY = jitterY;\r\n    }\r\n\r\n    //@ts-ignore\r\n    begin(skeleton: Skeleton): void {\r\n    }\r\n\r\n    //@ts-ignore\r\n    transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\r\n        position.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n        position.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n    }\r\n\r\n    end(): void {\r\n    }\r\n}\r\n","import {VertexEffect} from \"../VertexEffect\";\r\nimport type {Skeleton} from \"../Skeleton\";\r\nimport {Color, MathUtils, PowOut, Vector2} from \"@pixi-spine/base\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SwirlEffect implements VertexEffect {\r\n    static interpolation = new PowOut(2);\r\n    centerX = 0;\r\n    centerY = 0;\r\n    radius = 0;\r\n    angle = 0;\r\n    private worldX = 0;\r\n    private worldY = 0;\r\n\r\n    constructor (radius: number) {\r\n        this.radius = radius;\r\n    }\r\n\r\n    begin(skeleton: Skeleton): void {\r\n        this.worldX = skeleton.x + this.centerX;\r\n        this.worldY = skeleton.y + this.centerY;\r\n    }\r\n\r\n    //@ts-ignore\r\n    transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\r\n        let radAngle = this.angle * MathUtils.degreesToRadians;\r\n        let x = position.x - this.worldX;\r\n        let y = position.y - this.worldY;\r\n        let dist = Math.sqrt(x * x + y * y);\r\n        if (dist < this.radius) {\r\n            let theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\r\n            let cos = Math.cos(theta);\r\n            let sin = Math.sin(theta);\r\n            position.x = cos * x - sin * y + this.worldX;\r\n            position.y = sin * x + cos * y + this.worldY;\r\n        }\r\n    }\r\n\r\n    end(): void {\r\n    }\r\n}\r\n","import {Event} from './Event';\r\nimport type {Skeleton} from \"./Skeleton\";\r\nimport {Attachment, VertexAttachment} from \"./attachments\";\r\nimport {ArrayLike, MathUtils, StringSet, Utils} from '@pixi-spine/base';\r\nimport {Slot} from \"./Slot\";\r\nimport {IkConstraint} from \"./IkConstraint\";\r\nimport {TransformConstraint} from \"./TransformConstraint\";\r\nimport {PathConstraint} from \"./PathConstraint\";\r\n/**\r\n * A simple container for a list of timelines and a name.\r\n * @public\r\n * */\r\nexport class Animation {\r\n    /** The animation's name, which is unique across all animations in the skeleton. */\r\n    name: string;\r\n    timelines: Array<Timeline>;\r\n    timelineIds: StringSet;\r\n\r\n    /** The duration of the animation in seconds, which is the highest time of all keys in the timeline. */\r\n    duration: number;\r\n\r\n    constructor (name: string, timelines: Array<Timeline>, duration: number) {\r\n        if (!name) throw new Error(\"name cannot be null.\");\r\n        this.name = name;\r\n        this.setTimelines(timelines);\r\n        this.duration = duration;\r\n    }\r\n\r\n    setTimelines(timelines: Array<Timeline>) {\r\n        if (!timelines) throw new Error(\"timelines cannot be null.\");\r\n        this.timelines = timelines;\r\n        this.timelineIds = new StringSet();\r\n        for (var i = 0; i < timelines.length; i++)\r\n            this.timelineIds.addAll(timelines[i].getPropertyIds());\r\n    }\r\n\r\n    hasTimeline(ids: string[]) : boolean {\r\n        for (let i = 0; i < ids.length; i++)\r\n            if (this.timelineIds.contains(ids[i])) return true;\r\n        return false;\r\n    }\r\n\r\n    /** Applies all the animation's timelines to the specified skeleton.\r\n     *\r\n     * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\r\n     * @param loop If true, the animation repeats after {@link #getDuration()}.\r\n     * @param events May be null to ignore fired events. */\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (!skeleton) throw new Error(\"skeleton cannot be null.\");\r\n\r\n        if (loop && this.duration != 0) {\r\n            time %= this.duration;\r\n            if (lastTime > 0) lastTime %= this.duration;\r\n        }\r\n\r\n        let timelines = this.timelines;\r\n        for (let i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\r\n    }\r\n}\r\n\r\n/** Controls how a timeline value is mixed with the setup pose value or current pose value when a timeline's `alpha`\r\n * < 1.\r\n *\r\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\r\n * @public\r\n * */\r\nexport enum MixBlend {\r\n    /** Transitions from the setup value to the timeline value (the current value is not used). Before the first key, the setup\r\n     * value is set. */\r\n    setup,\r\n    /** Transitions from the current value to the timeline value. Before the first key, transitions from the current value to\r\n     * the setup value. Timelines which perform instant transitions, such as {@link DrawOrderTimeline} or\r\n     * {@link AttachmentTimeline}, use the setup value before the first key.\r\n     *\r\n     * `first` is intended for the first animations applied, not for animations layered on top of those. */\r\n    first,\r\n    /** Transitions from the current value to the timeline value. No change is made before the first key (the current value is\r\n     * kept until the first key).\r\n     *\r\n     * `replace` is intended for animations layered on top of others, not for the first animations applied. */\r\n    replace,\r\n    /** Transitions from the current value to the current value plus the timeline value. No change is made before the first key\r\n     * (the current value is kept until the first key).\r\n     *\r\n     * `add` is intended for animations layered on top of others, not for the first animations applied. Properties\r\n     * keyed by additive animations must be set manually or by another animation before applying the additive animations, else\r\n     * the property values will increase continually. */\r\n    add\r\n}\r\n\r\n/** Indicates whether a timeline's `alpha` is mixing out over time toward 0 (the setup or current pose value) or\r\n * mixing in toward 1 (the timeline's value).\r\n *\r\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\r\n * @public\r\n * */\r\nexport enum MixDirection {\r\n    mixIn, mixOut\r\n}\r\n\r\nconst Property = {\r\n    rotate: 0,\r\n    x: 1,\r\n    y: 2,\r\n    scaleX: 3,\r\n    scaleY: 4,\r\n    shearX: 5,\r\n    shearY: 6,\r\n\r\n    rgb: 7,\r\n    alpha: 8,\r\n    rgb2: 9,\r\n\r\n    attachment: 10,\r\n    deform: 11,\r\n\r\n    event: 12,\r\n    drawOrder: 13,\r\n\r\n    ikConstraint: 14,\r\n    transformConstraint: 15,\r\n\r\n    pathConstraintPosition: 16,\r\n    pathConstraintSpacing: 17,\r\n    pathConstraintMix: 18\r\n}\r\n\r\n/** The interface for all timelines.\r\n * @public\r\n * */\r\nexport abstract class Timeline {\r\n    propertyIds: string[];\r\n    frames: ArrayLike<number>;\r\n\r\n    constructor(frameCount: number, propertyIds: string[]) {\r\n        this.propertyIds = propertyIds;\r\n        this.frames = Utils.newFloatArray(frameCount * this.getFrameEntries());\r\n    }\r\n\r\n    getPropertyIds () {\r\n        return this.propertyIds;\r\n    }\r\n\r\n    getFrameEntries (): number {\r\n        return 1;\r\n    }\r\n\r\n    getFrameCount () {\r\n        return this.frames.length / this.getFrameEntries();\r\n    }\r\n\r\n    getDuration (): number {\r\n        return this.frames[this.frames.length - this.getFrameEntries()];\r\n    }\r\n\r\n    abstract apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\r\n\r\n    static search1 (frames: ArrayLike<number>, time: number) {\r\n        let n = frames.length;\r\n        for (let i = 1; i < n; i++)\r\n            if (frames[i] > time) return i - 1;\r\n        return n - 1;\r\n    }\r\n\r\n    static search (frames: ArrayLike<number>, time: number, step: number) {\r\n        let n = frames.length;\r\n        for (let i = step; i < n; i += step)\r\n            if (frames[i] > time) return i - step;\r\n        return n - step;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface BoneTimeline {\r\n    /** The index of the bone in {@link Skeleton#bones} that will be changed. */\r\n    boneIndex: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface SlotTimeline {\r\n    /** The index of the slot in {@link Skeleton#slots} that will be changed. */\r\n    slotIndex: number;\r\n}\r\n\r\n/** The base class for timelines that use interpolation between key frame values.\r\n * @public\r\n * */\r\nexport abstract class CurveTimeline extends Timeline {\r\n    protected curves: ArrayLike<number>; // type, x, y, ...\r\n\r\n    constructor (frameCount: number, bezierCount: number, propertyIds: string[]) {\r\n        super(frameCount, propertyIds);\r\n        this.curves = Utils.newFloatArray(frameCount + bezierCount * 18/*BEZIER_SIZE*/);\r\n        this.curves[frameCount - 1] = 1/*STEPPED*/;\r\n    }\r\n\r\n    /** Sets the specified key frame to linear interpolation. */\r\n    setLinear (frame: number) {\r\n        this.curves[frame] = 0/*LINEAR*/;\r\n    }\r\n\r\n    /** Sets the specified key frame to stepped interpolation. */\r\n    setStepped (frame: number) {\r\n        this.curves[frame] = 1/*STEPPED*/;\r\n    }\r\n\r\n    /** Shrinks the storage for Bezier curves, for use when <code>bezierCount</code> (specified in the constructor) was larger\r\n     * than the actual number of Bezier curves. */\r\n    shrink (bezierCount: number) {\r\n        let size = this.getFrameCount() + bezierCount * 18/*BEZIER_SIZE*/;\r\n        if (this.curves.length > size) {\r\n            let newCurves = Utils.newFloatArray(size);\r\n            Utils.arrayCopy(this.curves, 0, newCurves, 0, size);\r\n            this.curves = newCurves;\r\n        }\r\n    }\r\n\r\n    /** Stores the segments for the specified Bezier curve. For timelines that modify multiple values, there may be more than\r\n     * one curve per frame.\r\n     * @param bezier The ordinal of this Bezier curve for this timeline, between 0 and <code>bezierCount - 1</code> (specified\r\n     *           in the constructor), inclusive.\r\n     * @param frame Between 0 and <code>frameCount - 1</code>, inclusive.\r\n     * @param value The index of the value for this frame that this curve is used for.\r\n     * @param time1 The time for the first key.\r\n     * @param value1 The value for the first key.\r\n     * @param cx1 The time for the first Bezier handle.\r\n     * @param cy1 The value for the first Bezier handle.\r\n     * @param cx2 The time of the second Bezier handle.\r\n     * @param cy2 The value for the second Bezier handle.\r\n     * @param time2 The time for the second key.\r\n     * @param value2 The value for the second key. */\r\n    setBezier (bezier: number, frame: number, value: number, time1: number, value1: number, cx1: number, cy1: number, cx2: number,\r\n               cy2: number, time2: number, value2: number) {\r\n        let curves = this.curves;\r\n        let i = this.getFrameCount() + bezier * 18/*BEZIER_SIZE*/;\r\n        if (value == 0) curves[frame] = 2/*BEZIER*/ + i;\r\n        let tmpx = (time1 - cx1 * 2 + cx2) * 0.03, tmpy = (value1 - cy1 * 2 + cy2) * 0.03;\r\n        let dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006, dddy = ((cy1 - cy2) * 3 - value1 + value2) * 0.006;\r\n        let ddx = tmpx * 2 + dddx, ddy = tmpy * 2 + dddy;\r\n        let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667, dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.16666667;\r\n        let x = time1 + dx, y = value1 + dy;\r\n        for (let n = i + 18/*BEZIER_SIZE*/; i < n; i += 2) {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dx += ddx;\r\n            dy += ddy;\r\n            ddx += dddx;\r\n            ddy += dddy;\r\n            x += dx;\r\n            y += dy;\r\n        }\r\n    }\r\n\r\n    /** Returns the Bezier interpolated value for the specified time.\r\n     * @param frameIndex The index into {@link #getFrames()} for the values of the frame before <code>time</code>.\r\n     * @param valueOffset The offset from <code>frameIndex</code> to the value this curve is used for.\r\n     * @param i The index of the Bezier segments. See {@link #getCurveType(int)}. */\r\n    getBezierValue (time: number, frameIndex: number, valueOffset: number, i: number) {\r\n        let curves = this.curves;\r\n        if (curves[i] > time) {\r\n            let x = this.frames[frameIndex], y = this.frames[frameIndex + valueOffset];\r\n            return y + (time - x) / (curves[i] - x) * (curves[i + 1] - y);\r\n        }\r\n        let n = i + 18/*BEZIER_SIZE*/;\r\n        for (i += 2; i < n; i += 2) {\r\n            if (curves[i] >= time) {\r\n                let x = curves[i - 2], y = curves[i - 1];\r\n                return y + (time - x) / (curves[i] - x) * (curves[i + 1] - y);\r\n            }\r\n        }\r\n        frameIndex += this.getFrameEntries();\r\n        let x = curves[n - 2], y = curves[n - 1];\r\n        return y + (time - x) / (this.frames[frameIndex] - x) * (this.frames[frameIndex + valueOffset] - y);\r\n    }\r\n}\r\n/**\r\n * @public\r\n */\r\nexport abstract class CurveTimeline1 extends CurveTimeline {\r\n    constructor(frameCount: number, bezierCount: number, propertyId: string) {\r\n        super(frameCount, bezierCount, [ propertyId ]);\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return 2/*ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time and value for the specified frame.\r\n     * @param frame Between 0 and <code>frameCount</code>, inclusive.\r\n     * @param time The frame time in seconds. */\r\n    setFrame (frame: number, time: number, value: number) {\r\n        frame <<= 1;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1/*VALUE*/] = value;\r\n    }\r\n\r\n    /** Returns the interpolated value for the specified time. */\r\n    getCurveValue (time: number) {\r\n        let frames = this.frames;\r\n        let i = frames.length - 2;\r\n        for (let ii = 2; ii <= i; ii += 2) {\r\n            if (frames[ii] > time) {\r\n                i = ii - 2;\r\n                break;\r\n            }\r\n        }\r\n\r\n        let curveType = this.curves[i >> 1];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i], value = frames[i + 1/*VALUE*/];\r\n                return value + (time - before) / (frames[i + 2/*ENTRIES*/] - before) * (frames[i + 2/*ENTRIES*/ + 1/*VALUE*/] - value);\r\n            case 1/*STEPPED*/:\r\n                return frames[i + 1/*VALUE*/];\r\n        }\r\n        return this.getBezierValue(time, i, 1/*VALUE*/, curveType - 2/*BEZIER*/);\r\n    }\r\n}\r\n\r\n/** The base class for a {@link CurveTimeline} which sets two properties.\r\n * @public\r\n * */\r\nexport abstract class CurveTimeline2 extends CurveTimeline {\r\n    /** @param bezierCount The maximum number of Bezier curves. See {@link #shrink(int)}.\r\n     * @param propertyIds Unique identifiers for the properties the timeline modifies. */\r\n    constructor (frameCount: number, bezierCount: number, propertyId1: string, propertyId2: string) {\r\n        super(frameCount, bezierCount, [ propertyId1, propertyId2 ]);\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return 3/*ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time and values for the specified frame.\r\n     * @param frame Between 0 and <code>frameCount</code>, inclusive.\r\n     * @param time The frame time in seconds. */\r\n    setFrame (frame: number, time: number, value1: number, value2: number) {\r\n        frame *= 3/*ENTRIES*/;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1/*VALUE1*/] = value1;\r\n        this.frames[frame + 2/*VALUE2*/] = value2;\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#rotation}.\r\n * @public\r\n * */\r\nexport class RotateTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, Property.rotate + \"|\" + boneIndex);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.rotation += (bone.data.rotation - bone.rotation) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let r = this.getCurveValue(time);\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.rotation = bone.data.rotation + r * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                r += bone.data.rotation - bone.rotation;\r\n            case MixBlend.add:\r\n                bone.rotation += r * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#x} and {@link Bone#y}.\r\n * @public\r\n * */\r\nexport class TranslateTimeline extends CurveTimeline2 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount,\r\n            Property.x + \"|\" + boneIndex,\r\n            Property.y + \"|\" + boneIndex,\r\n        );\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.x = bone.data.x;\r\n                    bone.y = bone.data.y;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.x += (bone.data.x - bone.x) * alpha;\r\n                    bone.y += (bone.data.y - bone.y) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let x = 0, y = 0;\r\n        let i = Timeline.search(frames, time, 3/*ENTRIES*/);\r\n        let curveType = this.curves[i / 3/*ENTRIES*/];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                x = frames[i + 1/*VALUE1*/];\r\n                y = frames[i + 2/*VALUE2*/];\r\n                let t = (time - before) / (frames[i + 3/*ENTRIES*/] - before);\r\n                x += (frames[i + 3/*ENTRIES*/ + 1/*VALUE1*/] - x) * t;\r\n                y += (frames[i + 3/*ENTRIES*/ + 2/*VALUE2*/] - y) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                x = frames[i + 1/*VALUE1*/];\r\n                y = frames[i + 2/*VALUE2*/];\r\n                break;\r\n            default:\r\n                x = this.getBezierValue(time, i, 1/*VALUE1*/, curveType - 2/*BEZIER*/);\r\n                y = this.getBezierValue(time, i, 2/*VALUE2*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n        }\r\n\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.x = bone.data.x + x * alpha;\r\n                bone.y = bone.data.y + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.x += (bone.data.x + x - bone.x) * alpha;\r\n                bone.y += (bone.data.y + y - bone.y) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.x += x * alpha;\r\n                bone.y += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#x}.\r\n * @public\r\n * */\r\nexport class TranslateXTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, Property.x + \"|\" + boneIndex);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.x = bone.data.x;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.x += (bone.data.x - bone.x) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let x = this.getCurveValue(time);\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.x = bone.data.x + x * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.x += (bone.data.x + x - bone.x) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.x += x * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#x}.\r\n * @public\r\n * */\r\nexport class TranslateYTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, Property.y + \"|\" + boneIndex);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.y = bone.data.y;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.y += (bone.data.y - bone.y) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let y = this.getCurveValue(time);\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.y = bone.data.y + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.y += (bone.data.y + y - bone.y) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.y += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\r\n * @public\r\n * */\r\nexport class ScaleTimeline extends CurveTimeline2 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount,\r\n            Property.scaleX + \"|\" + boneIndex,\r\n            Property.scaleY + \"|\" + boneIndex\r\n        );\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.scaleX = bone.data.scaleX;\r\n                    bone.scaleY = bone.data.scaleY;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\r\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let x, y;\r\n        let i = Timeline.search(frames, time, 3/*ENTRIES*/);\r\n        let curveType = this.curves[i / 3/*ENTRIES*/];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                x = frames[i + 1/*VALUE1*/];\r\n                y = frames[i + 2/*VALUE2*/];\r\n                let t = (time - before) / (frames[i + 3/*ENTRIES*/] - before);\r\n                x += (frames[i + 3/*ENTRIES*/ + 1/*VALUE1*/] - x) * t;\r\n                y += (frames[i + 3/*ENTRIES*/ + 2/*VALUE2*/] - y) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                x = frames[i + 1/*VALUE1*/];\r\n                y = frames[i + 2/*VALUE2*/];\r\n                break;\r\n            default:\r\n                x = this.getBezierValue(time, i, 1/*VALUE1*/, curveType - 2/*BEZIER*/);\r\n                y = this.getBezierValue(time, i, 2/*VALUE2*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n        }\r\n        x *= bone.data.scaleX;\r\n        y *= bone.data.scaleY;\r\n\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add) {\r\n                bone.scaleX += x - bone.data.scaleX;\r\n                bone.scaleY += y - bone.data.scaleY;\r\n            } else {\r\n                bone.scaleX = x;\r\n                bone.scaleY = y;\r\n            }\r\n        } else {\r\n            let bx = 0, by = 0;\r\n            if (direction == MixDirection.mixOut) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = bone.data.scaleX;\r\n                        by = bone.data.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = bone.scaleX;\r\n                        by = bone.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bx = bone.scaleX;\r\n                        by = bone.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\r\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\r\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bx = MathUtils.signum(x);\r\n                        by = MathUtils.signum(y);\r\n                        bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\r\n                        bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\r\n * @public\r\n * */\r\nexport class ScaleXTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, Property.scaleX + \"|\" + boneIndex);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.scaleX = bone.data.scaleX;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let x = this.getCurveValue(time) * bone.data.scaleX;\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add)\r\n                bone.scaleX += x - bone.data.scaleX;\r\n            else\r\n                bone.scaleX = x;\r\n        } else {\r\n            // Mixing out uses sign of setup or current pose, else use sign of key.\r\n            let bx = 0;\r\n            if (direction == MixDirection.mixOut) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = bone.data.scaleX;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = bone.scaleX;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bx = bone.scaleX;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bx = MathUtils.signum(x);\r\n                        bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\r\n * @public\r\n * */\r\nexport class ScaleYTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, Property.scaleY + \"|\" + boneIndex);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.scaleY = bone.data.scaleY;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let y = this.getCurveValue(time) * bone.data.scaleY;\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add)\r\n                bone.scaleY += y - bone.data.scaleY;\r\n            else\r\n                bone.scaleY = y;\r\n        } else {\r\n            // Mixing out uses sign of setup or current pose, else use sign of key.\r\n            let by = 0;\r\n            if (direction == MixDirection.mixOut) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        by = bone.data.scaleY;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        by = bone.scaleY;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        by = bone.scaleY;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        by = MathUtils.signum(y);\r\n                        bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\r\n * @public\r\n * */\r\nexport class ShearTimeline extends CurveTimeline2 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount,\r\n            Property.shearX + \"|\" + boneIndex,\r\n            Property.shearY + \"|\" + boneIndex\r\n        );\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.shearX = bone.data.shearX;\r\n                    bone.shearY = bone.data.shearY;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\r\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let x = 0, y = 0;\r\n        let i = Timeline.search(frames, time, 3/*ENTRIES*/);\r\n        let curveType = this.curves[i / 3/*ENTRIES*/];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                x = frames[i + 1/*VALUE1*/];\r\n                y = frames[i + 2/*VALUE2*/];\r\n                let t = (time - before) / (frames[i + 3/*ENTRIES*/] - before);\r\n                x += (frames[i + 3/*ENTRIES*/ + 1/*VALUE1*/] - x) * t;\r\n                y += (frames[i + 3/*ENTRIES*/ + 2/*VALUE2*/] - y) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                x = frames[i + 1/*VALUE1*/];\r\n                y = frames[i + 2/*VALUE2*/];\r\n                break;\r\n            default:\r\n                x = this.getBezierValue(time, i, 1/*VALUE1*/, curveType - 2/*BEZIER*/);\r\n                y = this.getBezierValue(time, i, 2/*VALUE2*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n        }\r\n\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.shearX = bone.data.shearX + x * alpha;\r\n                bone.shearY = bone.data.shearY + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\r\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.shearX += x * alpha;\r\n                bone.shearY += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\r\n * @public\r\n * */\r\nexport class ShearXTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, Property.shearX + \"|\" + boneIndex);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.shearX = bone.data.shearX;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let x = this.getCurveValue(time);\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.shearX = bone.data.shearX + x * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.shearX += x * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\r\n * @public\r\n * */\r\nexport class ShearYTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, Property.shearY + \"|\" + boneIndex);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (!bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.shearY = bone.data.shearY;\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let y = this.getCurveValue(time);\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.shearY = bone.data.shearY + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.shearY += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color}.\r\n * @public\r\n * */\r\nexport class RGBATimeline extends CurveTimeline implements SlotTimeline {\r\n    slotIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, slotIndex: number) {\r\n        super(frameCount, bezierCount, [\r\n            Property.rgb + \"|\" + slotIndex,\r\n            Property.alpha + \"|\" + slotIndex\r\n        ]);\r\n        this.slotIndex = slotIndex;\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return 5/*ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\r\n    setFrame (frame: number, time: number, r: number, g: number, b: number, a: number) {\r\n        frame *= 5/*ENTRIES*/;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1/*R*/] = r;\r\n        this.frames[frame + 2/*G*/] = g;\r\n        this.frames[frame + 3/*B*/] = b;\r\n        this.frames[frame + 4/*A*/] = a;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        let color = slot.color;\r\n        if (time < frames[0]) {\r\n            let setup = slot.data.color;\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    color.setFromColor(setup);\r\n                    return;\r\n                case MixBlend.first:\r\n                    color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha,\r\n                        (setup.a - color.a) * alpha);\r\n            }\r\n            return;\r\n        }\r\n\r\n        let r = 0, g = 0, b = 0, a = 0;\r\n        let i = Timeline.search(frames, time, 5/*ENTRIES*/);\r\n        let curveType = this.curves[i / 5/*ENTRIES*/];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                r = frames[i + 1/*R*/];\r\n                g = frames[i + 2/*G*/];\r\n                b = frames[i + 3/*B*/];\r\n                a = frames[i + 4/*A*/];\r\n                let t = (time - before) / (frames[i + 5/*ENTRIES*/] - before);\r\n                r += (frames[i + 5/*ENTRIES*/ + 1/*R*/] - r) * t;\r\n                g += (frames[i + 5/*ENTRIES*/ + 2/*G*/] - g) * t;\r\n                b += (frames[i + 5/*ENTRIES*/ + 3/*B*/] - b) * t;\r\n                a += (frames[i + 5/*ENTRIES*/ + 4/*A*/] - a) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                r = frames[i + 1/*R*/];\r\n                g = frames[i + 2/*G*/];\r\n                b = frames[i + 3/*B*/];\r\n                a = frames[i + 4/*A*/];\r\n                break;\r\n            default:\r\n                r = this.getBezierValue(time, i, 1/*R*/, curveType - 2/*BEZIER*/);\r\n                g = this.getBezierValue(time, i, 2/*G*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n                b = this.getBezierValue(time, i, 3/*B*/, curveType + 18/*BEZIER_SIZE*/ * 2 - 2/*BEZIER*/);\r\n                a = this.getBezierValue(time, i, 4/*A*/, curveType + 18/*BEZIER_SIZE*/ * 3 - 2/*BEZIER*/);\r\n        }\r\n        if (alpha == 1)\r\n            color.set(r, g, b, a);\r\n        else {\r\n            if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\r\n            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color}.\r\n * @public\r\n * */\r\nexport class RGBTimeline extends CurveTimeline implements SlotTimeline {\r\n    slotIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, slotIndex: number) {\r\n        super(frameCount, bezierCount, [\r\n            Property.rgb + \"|\" + slotIndex\r\n        ]);\r\n        this.slotIndex = slotIndex;\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return 4/*ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\r\n    setFrame (frame: number, time: number, r: number, g: number, b: number) {\r\n        frame <<= 2;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1/*R*/] = r;\r\n        this.frames[frame + 2/*G*/] = g;\r\n        this.frames[frame + 3/*B*/] = b;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        let color = slot.color;\r\n        if (time < frames[0]) {\r\n            let setup = slot.data.color;\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    color.r = setup.r;\r\n                    color.g = setup.g;\r\n                    color.b = setup.b;\r\n                    return;\r\n                case MixBlend.first:\r\n                    color.r += (setup.r - color.r) * alpha;\r\n                    color.g += (setup.g - color.g) * alpha;\r\n                    color.b += (setup.b - color.b) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let r = 0, g = 0, b = 0;\r\n        let i = Timeline.search(frames, time, 4/*ENTRIES*/);\r\n        let curveType = this.curves[i >> 2];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                r = frames[i + 1/*R*/];\r\n                g = frames[i + 2/*G*/];\r\n                b = frames[i + 3/*B*/];\r\n                let t = (time - before) / (frames[i + 4/*ENTRIES*/] - before);\r\n                r += (frames[i + 4/*ENTRIES*/ + 1/*R*/] - r) * t;\r\n                g += (frames[i + 4/*ENTRIES*/ + 2/*G*/] - g) * t;\r\n                b += (frames[i + 4/*ENTRIES*/ + 3/*B*/] - b) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                r = frames[i + 1/*R*/];\r\n                g = frames[i + 2/*G*/];\r\n                b = frames[i + 3/*B*/];\r\n                break;\r\n            default:\r\n                r = this.getBezierValue(time, i, 1/*R*/, curveType - 2/*BEZIER*/);\r\n                g = this.getBezierValue(time, i, 2/*G*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n                b = this.getBezierValue(time, i, 3/*B*/, curveType + 18/*BEZIER_SIZE*/ * 2 - 2/*BEZIER*/);\r\n        }\r\n        if (alpha == 1) {\r\n            color.r = r;\r\n            color.g = g;\r\n            color.b = b;\r\n        }else {\r\n            if (blend == MixBlend.setup) {\r\n                let setup = slot.data.color;\r\n                color.r = setup.r;\r\n                color.g = setup.g;\r\n                color.b = setup.b;\r\n            }\r\n            color.r += (r - color.r) * alpha;\r\n            color.g += (g - color.g) * alpha;\r\n            color.b += (b - color.b) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\r\n * @public\r\n * */\r\nexport class AlphaTimeline extends CurveTimeline1 implements SlotTimeline {\r\n    slotIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, slotIndex: number) {\r\n        super(frameCount, bezierCount, Property.alpha + \"|\" + slotIndex);\r\n        this.slotIndex = slotIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n\r\n        let color = slot.color;\r\n        if (time < this.frames[0]) { // Time is before first frame.\r\n            let setup = slot.data.color;\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    color.a = setup.a;\r\n                    return;\r\n                case MixBlend.first:\r\n                    color.a += (setup.a - color.a) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let a = this.getCurveValue(time);\r\n        if (alpha == 1)\r\n            color.a = a;\r\n        else {\r\n            if (blend == MixBlend.setup) color.a = slot.data.color.a;\r\n            color.a += (a - color.a) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting.\r\n * @public\r\n * */\r\nexport class RGBA2Timeline extends CurveTimeline implements SlotTimeline{\r\n    slotIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, slotIndex: number) {\r\n        super(frameCount, bezierCount, [\r\n            Property.rgb + \"|\" + slotIndex,\r\n            Property.alpha + \"|\" + slotIndex,\r\n            Property.rgb2 + \"|\" + slotIndex\r\n        ]);\r\n        this.slotIndex = slotIndex;\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return 8/*ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time in seconds, light, and dark colors for the specified key frame. */\r\n    setFrame (frame: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\r\n        frame <<= 3;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1/*R*/] = r;\r\n        this.frames[frame + 2/*G*/] = g;\r\n        this.frames[frame + 3/*B*/] = b;\r\n        this.frames[frame + 4/*A*/] = a;\r\n        this.frames[frame + 5/*R2*/] = r2;\r\n        this.frames[frame + 6/*G2*/] = g2;\r\n        this.frames[frame + 7/*B2*/] = b2;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        let light = slot.color, dark = slot.darkColor;\r\n        if (time < frames[0]) {\r\n            let setupLight = slot.data.color, setupDark = slot.data.darkColor;\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    light.setFromColor(setupLight);\r\n                    dark.r = setupDark.r;\r\n                    dark.g = setupDark.g;\r\n                    dark.b = setupDark.b;\r\n                    return;\r\n                case MixBlend.first:\r\n                    light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha,\r\n                        (setupLight.a - light.a) * alpha);\r\n                    dark.r += (setupDark.r - dark.r) * alpha;\r\n                    dark.g += (setupDark.g - dark.g) * alpha;\r\n                    dark.b += (setupDark.b - dark.b) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;\r\n        let i = Timeline.search(frames, time, 8/*ENTRIES*/);\r\n        let curveType = this.curves[i >> 3];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                r = frames[i + 1/*R*/];\r\n                g = frames[i + 2/*G*/];\r\n                b = frames[i + 3/*B*/];\r\n                a = frames[i + 4/*A*/];\r\n                r2 = frames[i + 5/*R2*/];\r\n                g2 = frames[i + 6/*G2*/];\r\n                b2 = frames[i + 7/*B2*/];\r\n                let t = (time - before) / (frames[i + 8/*ENTRIES*/] - before);\r\n                r += (frames[i + 8/*ENTRIES*/ + 1/*R*/] - r) * t;\r\n                g += (frames[i + 8/*ENTRIES*/ + 2/*G*/] - g) * t;\r\n                b += (frames[i + 8/*ENTRIES*/ + 3/*B*/] - b) * t;\r\n                a += (frames[i + 8/*ENTRIES*/ + 4/*A*/] - a) * t;\r\n                r2 += (frames[i + 8/*ENTRIES*/ + 5/*R2*/] - r2) * t;\r\n                g2 += (frames[i + 8/*ENTRIES*/ + 6/*G2*/] - g2) * t;\r\n                b2 += (frames[i + 8/*ENTRIES*/ + 7/*B2*/] - b2) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                r = frames[i + 1/*R*/];\r\n                g = frames[i + 2/*G*/];\r\n                b = frames[i + 3/*B*/];\r\n                a = frames[i + 4/*A*/];\r\n                r2 = frames[i + 5/*R2*/];\r\n                g2 = frames[i + 6/*G2*/];\r\n                b2 = frames[i + 7/*B2*/];\r\n                break;\r\n            default:\r\n                r = this.getBezierValue(time, i, 1/*R*/, curveType - 2/*BEZIER*/);\r\n                g = this.getBezierValue(time, i, 2/*G*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n                b = this.getBezierValue(time, i, 3/*B*/, curveType + 18/*BEZIER_SIZE*/ * 2 - 2/*BEZIER*/);\r\n                a = this.getBezierValue(time, i, 4/*A*/, curveType + 18/*BEZIER_SIZE*/ * 3 - 2/*BEZIER*/);\r\n                r2 = this.getBezierValue(time, i, 5/*R2*/, curveType + 18/*BEZIER_SIZE*/ * 4 - 2/*BEZIER*/);\r\n                g2 = this.getBezierValue(time, i, 6/*G2*/, curveType + 18/*BEZIER_SIZE*/ * 5 - 2/*BEZIER*/);\r\n                b2 = this.getBezierValue(time, i, 7/*B2*/, curveType + 18/*BEZIER_SIZE*/ * 6 - 2/*BEZIER*/);\r\n        }\r\n\r\n        if (alpha == 1) {\r\n            light.set(r, g, b, a);\r\n            dark.r = r2;\r\n            dark.g = g2;\r\n            dark.b = b2;\r\n        } else {\r\n            if (blend == MixBlend.setup) {\r\n                light.setFromColor(slot.data.color);\r\n                let setupDark = slot.data.darkColor;\r\n                dark.r = setupDark.r;\r\n                dark.g = setupDark.g;\r\n                dark.b = setupDark.b;\r\n            }\r\n            light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\r\n            dark.r += (r2 - dark.r) * alpha;\r\n            dark.g += (g2 - dark.g) * alpha;\r\n            dark.b += (b2 - dark.b) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting.\r\n * @public\r\n * */\r\nexport class RGB2Timeline extends CurveTimeline implements SlotTimeline{\r\n    slotIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, slotIndex: number) {\r\n        super(frameCount, bezierCount, [\r\n            Property.rgb + \"|\" + slotIndex,\r\n            Property.rgb2 + \"|\" + slotIndex\r\n        ]);\r\n        this.slotIndex = slotIndex;\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return 7/*ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time in seconds, light, and dark colors for the specified key frame. */\r\n    setFrame (frame: number, time: number, r: number, g: number, b: number, r2: number, g2: number, b2: number) {\r\n        frame *= 7/*ENTRIES*/;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1/*R*/] = r;\r\n        this.frames[frame + 2/*G*/] = g;\r\n        this.frames[frame + 3/*B*/] = b;\r\n        this.frames[frame + 4/*R2*/] = r2;\r\n        this.frames[frame + 5/*G2*/] = g2;\r\n        this.frames[frame + 6/*B2*/] = b2;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n\r\n        let frames = this.frames;\r\n        let light = slot.color, dark = slot.darkColor;\r\n        if (time < frames[0]) {\r\n            let setupLight = slot.data.color, setupDark = slot.data.darkColor;\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    light.r = setupLight.r;\r\n                    light.g = setupLight.g;\r\n                    light.b = setupLight.b;\r\n                    dark.r = setupDark.r;\r\n                    dark.g = setupDark.g;\r\n                    dark.b = setupDark.b;\r\n                    return;\r\n                case MixBlend.first:\r\n                    light.r += (setupLight.r - light.r) * alpha;\r\n                    light.g += (setupLight.g - light.g) * alpha;\r\n                    light.b += (setupLight.b - light.b) * alpha;\r\n                    dark.r += (setupDark.r - dark.r) * alpha;\r\n                    dark.g += (setupDark.g - dark.g) * alpha;\r\n                    dark.b += (setupDark.b - dark.b) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let r = 0, g = 0, b = 0, r2 = 0, g2 = 0, b2 = 0;\r\n        let i = Timeline.search(frames, time, 7/*ENTRIES*/);\r\n        let curveType = this.curves[i / 7/*ENTRIES*/];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                r = frames[i + 1/*R*/];\r\n                g = frames[i + 2/*G*/];\r\n                b = frames[i + 3/*B*/];\r\n                r2 = frames[i + 4/*R2*/];\r\n                g2 = frames[i + 5/*G2*/];\r\n                b2 = frames[i + 6/*B2*/];\r\n                let t = (time - before) / (frames[i + 7/*ENTRIES*/] - before);\r\n                r += (frames[i + 7/*ENTRIES*/ + 1/*R*/] - r) * t;\r\n                g += (frames[i + 7/*ENTRIES*/ + 2/*G*/] - g) * t;\r\n                b += (frames[i + 7/*ENTRIES*/ + 3/*B*/] - b) * t;\r\n                r2 += (frames[i + 7/*ENTRIES*/ + 4/*R2*/] - r2) * t;\r\n                g2 += (frames[i + 7/*ENTRIES*/ + 5/*G2*/] - g2) * t;\r\n                b2 += (frames[i + 7/*ENTRIES*/ + 6/*B2*/] - b2) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                r = frames[i + 1/*R*/];\r\n                g = frames[i + 2/*G*/];\r\n                b = frames[i + 3/*B*/];\r\n                r2 = frames[i + 4/*R2*/];\r\n                g2 = frames[i + 5/*G2*/];\r\n                b2 = frames[i + 6/*B2*/];\r\n                break;\r\n            default:\r\n                r = this.getBezierValue(time, i, 1/*R*/, curveType - 2/*BEZIER*/);\r\n                g = this.getBezierValue(time, i, 2/*G*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n                b = this.getBezierValue(time, i, 3/*B*/, curveType + 18/*BEZIER_SIZE*/ * 2 - 2/*BEZIER*/);\r\n                r2 = this.getBezierValue(time, i, 4/*R2*/, curveType + 18/*BEZIER_SIZE*/ * 3 - 2/*BEZIER*/);\r\n                g2 = this.getBezierValue(time, i, 5/*G2*/, curveType + 18/*BEZIER_SIZE*/ * 4 - 2/*BEZIER*/);\r\n                b2 = this.getBezierValue(time, i, 6/*B2*/, curveType + 18/*BEZIER_SIZE*/ * 5 - 2/*BEZIER*/);\r\n        }\r\n\r\n        if (alpha == 1) {\r\n            light.r = r;\r\n            light.g = g;\r\n            light.b = b;\r\n            dark.r = r2;\r\n            dark.g = g2;\r\n            dark.b = b2;\r\n        } else {\r\n            if (blend == MixBlend.setup) {\r\n                let setupLight = slot.data.color, setupDark = slot.data.darkColor;\r\n                light.r = setupLight.r;\r\n                light.g = setupLight.g;\r\n                light.b = setupLight.b;\r\n                dark.r = setupDark.r;\r\n                dark.g = setupDark.g;\r\n                dark.b = setupDark.b;\r\n            }\r\n            light.r += (r - light.r) * alpha;\r\n            light.g += (g - light.g) * alpha;\r\n            light.b += (b - light.b) * alpha;\r\n            dark.r += (r2 - dark.r) * alpha;\r\n            dark.g += (g2 - dark.g) * alpha;\r\n            dark.b += (b2 - dark.b) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#attachment}.\r\n * @public\r\n * */\r\nexport class AttachmentTimeline extends Timeline implements SlotTimeline {\r\n    slotIndex = 0;\r\n\r\n    /** The attachment name for each key frame. May contain null values to clear the attachment. */\r\n    attachmentNames: Array<string>;\r\n\r\n    constructor (frameCount: number, slotIndex: number) {\r\n        super(frameCount, [\r\n            Property.attachment + \"|\" + slotIndex\r\n        ]);\r\n        this.slotIndex = slotIndex;\r\n        this.attachmentNames = new Array<string>(frameCount);\r\n    }\r\n\r\n    getFrameCount () {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the attachment name for the specified key frame. */\r\n    setFrame (frame: number, time: number, attachmentName: string) {\r\n        this.frames[frame] = time;\r\n        this.attachmentNames[frame] = attachmentName;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n\r\n        if (direction == MixDirection.mixOut) {\r\n            if (blend == MixBlend.setup) this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n            return;\r\n        }\r\n\r\n        if (time < this.frames[0]) {\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n            return;\r\n        }\r\n\r\n        this.setAttachment(skeleton, slot, this.attachmentNames[Timeline.search1(this.frames, time)]);\r\n    }\r\n\r\n    setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string) {\r\n        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#deform} to deform a {@link VertexAttachment}.\r\n * @public\r\n * */\r\nexport class DeformTimeline extends CurveTimeline implements SlotTimeline {\r\n    slotIndex = 0;\r\n\r\n    /** The attachment that will be deformed. */\r\n    attachment: VertexAttachment;\r\n\r\n    /** The vertices for each key frame. */\r\n    vertices: Array<ArrayLike<number>>;\r\n\r\n    constructor (frameCount: number, bezierCount: number, slotIndex: number, attachment: VertexAttachment) {\r\n        super(frameCount, bezierCount, [\r\n            Property.deform + \"|\" + slotIndex + \"|\" + attachment.id\r\n        ]);\r\n        this.slotIndex = slotIndex;\r\n        this.attachment = attachment;\r\n        this.vertices = new Array<ArrayLike<number>>(frameCount);\r\n    }\r\n\r\n    getFrameCount () {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the vertices for the specified key frame.\r\n     * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\r\n    setFrame (frame: number, time: number, vertices: ArrayLike<number>) {\r\n        this.frames[frame] = time;\r\n        this.vertices[frame] = vertices;\r\n    }\r\n\r\n    /** @param value1 Ignored (0 is used for a deform timeline).\r\n     * @param value2 Ignored (1 is used for a deform timeline). */\r\n    setBezier (bezier: number, frame: number, value: number, time1: number, value1: number, cx1: number, cy1: number, cx2: number,\r\n               cy2: number, time2: number, value2: number) {\r\n        let curves = this.curves;\r\n        let i = this.getFrameCount() + bezier * 18/*BEZIER_SIZE*/;\r\n        if (value == 0) curves[frame] = 2/*BEZIER*/ + i;\r\n        let tmpx = (time1 - cx1 * 2 + cx2) * 0.03, tmpy = cy2 * 0.03 - cy1 * 0.06;\r\n        let dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006, dddy = (cy1 - cy2 + 0.33333333) * 0.018;\r\n        let ddx = tmpx * 2 + dddx, ddy = tmpy * 2 + dddy;\r\n        let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667, dy = cy1 * 0.3 + tmpy + dddy * 0.16666667;\r\n        let x = time1 + dx, y = dy;\r\n        for (let n = i + 18/*BEZIER_SIZE*/; i < n; i += 2) {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dx += ddx;\r\n            dy += ddy;\r\n            ddx += dddx;\r\n            ddy += dddy;\r\n            x += dx;\r\n            y += dy;\r\n        }\r\n    }\r\n\r\n    getCurvePercent (time: number, frame: number) {\r\n        let curves = this.curves;\r\n        let i = curves[frame];\r\n        switch (i) {\r\n            case 0/*LINEAR*/:\r\n                let x = this.frames[frame];\r\n                return (time - x) / (this.frames[frame + this.getFrameEntries()] - x);\r\n            case 1/*STEPPED*/:\r\n                return 0;\r\n        }\r\n        i -= 2/*BEZIER*/;\r\n        if (curves[i] > time) {\r\n            let x = this.frames[frame];\r\n            return curves[i + 1] * (time - x) / (curves[i] - x);\r\n        }\r\n        let n = i + 18/*BEZIER_SIZE*/;\r\n        for (i += 2; i < n; i += 2) {\r\n            if (curves[i] >= time) {\r\n                let x = curves[i - 2], y = curves[i - 1];\r\n                return y + (time - x) / (curves[i] - x) * (curves[i + 1] - y);\r\n            }\r\n        }\r\n        let x = curves[n - 2], y = curves[n - 1];\r\n        return y + (1 - y) * (time - x) / (this.frames[frame + this.getFrameEntries()] - x);\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let slot: Slot = skeleton.slots[this.slotIndex];\r\n        if (!slot.bone.active) return;\r\n        let slotAttachment: Attachment = slot.getAttachment();\r\n        if (!(slotAttachment instanceof VertexAttachment) || (<VertexAttachment>slotAttachment).deformAttachment != this.attachment) return;\r\n\r\n        let deform: Array<number> = slot.deform;\r\n        if (deform.length == 0) blend = MixBlend.setup;\r\n\r\n        let vertices = this.vertices;\r\n        let vertexCount = vertices[0].length;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            let vertexAttachment = <VertexAttachment>slotAttachment;\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    deform.length = 0;\r\n                    return;\r\n                case MixBlend.first:\r\n                    if (alpha == 1) {\r\n                        deform.length = 0;\r\n                        return;\r\n                    }\r\n                    deform.length = vertexCount;\r\n                    if (!vertexAttachment.bones) {\r\n                        // Unweighted vertex positions.\r\n                        let setupVertices = vertexAttachment.vertices;\r\n                        for (var i = 0; i < vertexCount; i++)\r\n                            deform[i] += (setupVertices[i] - deform[i]) * alpha;\r\n                    } else {\r\n                        // Weighted deform offsets.\r\n                        alpha = 1 - alpha;\r\n                        for (var i = 0; i < vertexCount; i++)\r\n                            deform[i] *= alpha;\r\n                    }\r\n            }\r\n            return;\r\n        }\r\n\r\n        deform.length = vertexCount;\r\n        if (time >= frames[frames.length - 1]) { // Time is after last frame.\r\n            let lastVertices = vertices[frames.length - 1];\r\n            if (alpha == 1) {\r\n                if (blend == MixBlend.add) {\r\n                    let vertexAttachment = slotAttachment as VertexAttachment;\r\n                    if (!vertexAttachment.bones) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        let setupVertices = vertexAttachment.vertices;\r\n                        for (let i = 0; i < vertexCount; i++)\r\n                            deform[i] += lastVertices[i] - setupVertices[i];\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++)\r\n                            deform[i] += lastVertices[i];\r\n                    }\r\n                } else\r\n                    Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\r\n            }else {\r\n                switch (blend) {\r\n                    case MixBlend.setup: {\r\n                        let vertexAttachment = slotAttachment as VertexAttachment;\r\n                        if (!vertexAttachment.bones) {\r\n                            // Unweighted vertex positions, with alpha.\r\n                            let setupVertices = vertexAttachment.vertices;\r\n                            for (let i = 0; i < vertexCount; i++) {\r\n                                let setup = setupVertices[i];\r\n                                deform[i] = setup + (lastVertices[i] - setup) * alpha;\r\n                            }\r\n                        } else {\r\n                            // Weighted deform offsets, with alpha.\r\n                            for (let i = 0; i < vertexCount; i++)\r\n                                deform[i] = lastVertices[i] * alpha;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        for (let i = 0; i < vertexCount; i++)\r\n                            deform[i] += (lastVertices[i] - deform[i]) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        let vertexAttachment = slotAttachment as VertexAttachment;\r\n                        if (!vertexAttachment.bones) {\r\n                            // Unweighted vertex positions, with alpha.\r\n                            let setupVertices = vertexAttachment.vertices;\r\n                            for (let i = 0; i < vertexCount; i++)\r\n                                deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\r\n                        } else {\r\n                            // Weighted deform offsets, with alpha.\r\n                            for (let i = 0; i < vertexCount; i++)\r\n                                deform[i] += lastVertices[i] * alpha;\r\n                        }\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        let frame = Timeline.search1(frames, time);\r\n        let percent = this.getCurvePercent(time, frame);\r\n        let prevVertices = vertices[frame];\r\n        let nextVertices = vertices[frame + 1];\r\n\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add) {\r\n                let vertexAttachment = slotAttachment as VertexAttachment;\r\n                if (!vertexAttachment.bones) {\r\n                    // Unweighted vertex positions, with alpha.\r\n                    let setupVertices = vertexAttachment.vertices;\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        let prev = prevVertices[i];\r\n                        deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\r\n                    }\r\n                } else {\r\n                    // Weighted deform offsets, with alpha.\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        let prev = prevVertices[i];\r\n                        deform[i] += prev + (nextVertices[i] - prev) * percent;\r\n                    }\r\n                }\r\n            } else {\r\n                for (let i = 0; i < vertexCount; i++) {\r\n                    let prev = prevVertices[i];\r\n                    deform[i] = prev + (nextVertices[i] - prev) * percent;\r\n                }\r\n            }\r\n        } else {\r\n            switch (blend) {\r\n                case MixBlend.setup: {\r\n                    let vertexAttachment = slotAttachment as VertexAttachment;\r\n                    if (!vertexAttachment.bones) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        let setupVertices = vertexAttachment.vertices;\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            let prev = prevVertices[i], setup = setupVertices[i];\r\n                            deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            let prev = prevVertices[i];\r\n                            deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case MixBlend.first:\r\n                case MixBlend.replace:\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        let prev = prevVertices[i];\r\n                        deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\r\n                    }\r\n                    break;\r\n                case MixBlend.add:\r\n                    let vertexAttachment = slotAttachment as VertexAttachment;\r\n                    if (!vertexAttachment.bones) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        let setupVertices = vertexAttachment.vertices;\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            let prev = prevVertices[i];\r\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            let prev = prevVertices[i];\r\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\r\n                        }\r\n                    }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Fires an {@link Event} when specific animation times are reached.\r\n * @public\r\n * */\r\nexport class EventTimeline extends Timeline {\r\n    static propertyIds = [ \"\" + Property.event ];\r\n\r\n    /** The event for each key frame. */\r\n    events: Array<Event>;\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount, EventTimeline.propertyIds);\r\n\r\n        this.events = new Array<Event>(frameCount);\r\n    }\r\n\r\n    getFrameCount () {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the event for the specified key frame. */\r\n    setFrame (frame: number, event: Event) {\r\n        this.frames[frame] = event.time;\r\n        this.events[frame] = event;\r\n    }\r\n\r\n    /** Fires events for frames > `lastTime` and <= `time`. */\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (!firedEvents) return;\r\n\r\n        let frames = this.frames;\r\n        let frameCount = this.frames.length;\r\n\r\n        if (lastTime > time) { // Fire events after last time for looped animations.\r\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\r\n            lastTime = -1;\r\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\r\n            return;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let i = 0;\r\n        if (lastTime < frames[0])\r\n            i = 0;\r\n        else {\r\n            i = Timeline.search1(frames, lastTime) + 1;\r\n            let frameTime = frames[i];\r\n            while (i > 0) { // Fire multiple events with the same frame.\r\n                if (frames[i - 1] != frameTime) break;\r\n                i--;\r\n            }\r\n        }\r\n        for (; i < frameCount && time >= frames[i]; i++)\r\n            firedEvents.push(this.events[i]);\r\n    }\r\n}\r\n\r\n/** Changes a skeleton's {@link Skeleton#drawOrder}.\r\n * @public\r\n * */\r\nexport class DrawOrderTimeline extends Timeline {\r\n    static propertyIds = [ \"\" + Property.drawOrder ];\r\n\r\n    /** The draw order for each key frame. See {@link #setFrame(int, float, int[])}. */\r\n    drawOrders: Array<Array<number>>;\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount, DrawOrderTimeline.propertyIds);\r\n        this.drawOrders = new Array<Array<number>>(frameCount);\r\n    }\r\n\r\n    getFrameCount () {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the draw order for the specified key frame.\r\n     * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\r\n     *           draw order. */\r\n    setFrame (frame: number, time: number, drawOrder: Array<number>) {\r\n        this.frames[frame] = time;\r\n        this.drawOrders[frame] = drawOrder;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (direction == MixDirection.mixOut) {\r\n            if (blend == MixBlend.setup) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n            return;\r\n        }\r\n\r\n        if (time < this.frames[0]) {\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n            return;\r\n        }\r\n\r\n        let drawOrderToSetupIndex = this.drawOrders[Timeline.search1(this.frames, time)];\r\n        if (!drawOrderToSetupIndex)\r\n            Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n        else {\r\n            let drawOrder: Array<Slot> = skeleton.drawOrder;\r\n            let slots: Array<Slot> = skeleton.slots;\r\n            for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n                drawOrder[i] = slots[drawOrderToSetupIndex[i]];\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes an IK constraint's {@link IkConstraint#mix}, {@link IkConstraint#softness},\r\n * {@link IkConstraint#bendDirection}, {@link IkConstraint#stretch}, and {@link IkConstraint#compress}.\r\n * @public\r\n * */\r\nexport class IkConstraintTimeline extends CurveTimeline {\r\n    /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */\r\n    ikConstraintIndex: number;\r\n\r\n    constructor (frameCount: number, bezierCount: number, ikConstraintIndex: number) {\r\n        super(frameCount, bezierCount, [\r\n            Property.ikConstraint + \"|\" + ikConstraintIndex\r\n        ]);\r\n        this.ikConstraintIndex = ikConstraintIndex;\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return 6/*ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */\r\n    setFrame (frame: number, time: number, mix: number, softness: number, bendDirection: number, compress: boolean, stretch: boolean) {\r\n        frame *= 6/*ENTRIES*/;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1/*MIX*/] = mix;\r\n        this.frames[frame + 2/*SOFTNESS*/] = softness;\r\n        this.frames[frame + 3/*BEND_DIRECTION*/] = bendDirection;\r\n        this.frames[frame + 4/*COMPRESS*/] = compress ? 1 : 0;\r\n        this.frames[frame + 5/*STRETCH*/] = stretch ? 1 : 0;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n        if (!constraint.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.mix = constraint.data.mix;\r\n                    constraint.softness = constraint.data.softness;\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\r\n                    constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let mix = 0, softness = 0;\r\n        let i = Timeline.search(frames, time, 6/*ENTRIES*/)\r\n        let curveType = this.curves[i / 6/*ENTRIES*/];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                mix = frames[i + 1/*MIX*/];\r\n                softness = frames[i + 2/*SOFTNESS*/];\r\n                let t = (time - before) / (frames[i + 6/*ENTRIES*/] - before);\r\n                mix += (frames[i + 6/*ENTRIES*/ + 1/*MIX*/] - mix) * t;\r\n                softness += (frames[i + 6/*ENTRIES*/ + 2/*SOFTNESS*/] - softness) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                mix = frames[i + 1/*MIX*/];\r\n                softness = frames[i + 2/*SOFTNESS*/];\r\n                break;\r\n            default:\r\n                mix = this.getBezierValue(time, i, 1/*MIX*/, curveType - 2/*BEZIER*/);\r\n                softness = this.getBezierValue(time, i, 2/*SOFTNESS*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n        }\r\n\r\n        if (blend == MixBlend.setup) {\r\n            constraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;\r\n            constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;\r\n\r\n            if (direction == MixDirection.mixOut) {\r\n                constraint.bendDirection = constraint.data.bendDirection;\r\n                constraint.compress = constraint.data.compress;\r\n                constraint.stretch = constraint.data.stretch;\r\n            } else {\r\n                constraint.bendDirection = frames[i + 3/*BEND_DIRECTION*/];\r\n                constraint.compress = frames[i + 4/*COMPRESS*/] != 0;\r\n                constraint.stretch = frames[i + 5/*STRETCH*/] != 0;\r\n            }\r\n        } else {\r\n            constraint.mix += (mix - constraint.mix) * alpha;\r\n            constraint.softness += (softness - constraint.softness) * alpha;\r\n            if (direction == MixDirection.mixIn) {\r\n                constraint.bendDirection = frames[i + 3/*BEND_DIRECTION*/];\r\n                constraint.compress = frames[i + 4/*COMPRESS*/] != 0;\r\n                constraint.stretch = frames[i + 5/*STRETCH*/] != 0;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a transform constraint's {@link TransformConstraint#rotateMix}, {@link TransformConstraint#translateMix},\r\n * {@link TransformConstraint#scaleMix}, and {@link TransformConstraint#shearMix}.\r\n * @public\r\n * */\r\nexport class TransformConstraintTimeline extends CurveTimeline {\r\n    /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */\r\n    transformConstraintIndex: number;\r\n\r\n    constructor (frameCount: number, bezierCount: number, transformConstraintIndex: number) {\r\n        super(frameCount, bezierCount, [\r\n            Property.transformConstraint + \"|\" + transformConstraintIndex\r\n        ]);\r\n        this.transformConstraintIndex = transformConstraintIndex;\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return 7/*ENTRIES*/;\r\n    }\r\n\r\n    /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\r\n    setFrame (frame: number, time: number, mixRotate: number, mixX: number, mixY: number, mixScaleX: number, mixScaleY: number,\r\n              mixShearY: number) {\r\n        let frames = this.frames;\r\n        frame *= 7/*ENTRIES*/;\r\n        frames[frame] = time;\r\n        frames[frame + 1/*ROTATE*/] = mixRotate;\r\n        frames[frame + 2/*X*/] = mixX;\r\n        frames[frame + 3/*Y*/] = mixY;\r\n        frames[frame + 4/*SCALEX*/] = mixScaleX;\r\n        frames[frame + 5/*SCALEY*/] = mixScaleY;\r\n        frames[frame + 6/*SHEARY*/] = mixShearY;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\r\n        if (!constraint.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            let data = constraint.data;\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.mixRotate = data.mixRotate;\r\n                    constraint.mixX = data.mixX;\r\n                    constraint.mixY = data.mixY;\r\n                    constraint.mixScaleX = data.mixScaleX;\r\n                    constraint.mixScaleY = data.mixScaleY;\r\n                    constraint.mixShearY = data.mixShearY;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.mixRotate += (data.mixRotate - constraint.mixRotate) * alpha;\r\n                    constraint.mixX += (data.mixX - constraint.mixX) * alpha;\r\n                    constraint.mixY += (data.mixY - constraint.mixY) * alpha;\r\n                    constraint.mixScaleX += (data.mixScaleX - constraint.mixScaleX) * alpha;\r\n                    constraint.mixScaleY += (data.mixScaleY - constraint.mixScaleY) * alpha;\r\n                    constraint.mixShearY += (data.mixShearY - constraint.mixShearY) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let rotate, x, y, scaleX, scaleY, shearY;\r\n        let i = Timeline.search(frames, time, 7/*ENTRIES*/);\r\n        let curveType = this.curves[i / 7/*ENTRIES*/];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                rotate = frames[i + 1/*ROTATE*/];\r\n                x = frames[i + 2/*X*/];\r\n                y = frames[i + 3/*Y*/];\r\n                scaleX = frames[i + 4/*SCALEX*/];\r\n                scaleY = frames[i + 5/*SCALEY*/];\r\n                shearY = frames[i + 6/*SHEARY*/];\r\n                let t = (time - before) / (frames[i + 7/*ENTRIES*/] - before);\r\n                rotate += (frames[i + 7/*ENTRIES*/ + 1/*ROTATE*/] - rotate) * t;\r\n                x += (frames[i + 7/*ENTRIES*/ + 2/*X*/] - x) * t;\r\n                y += (frames[i + 7/*ENTRIES*/ + 3/*Y*/] - y) * t;\r\n                scaleX += (frames[i + 7/*ENTRIES*/ + 4/*SCALEX*/] - scaleX) * t;\r\n                scaleY += (frames[i + 7/*ENTRIES*/ + 5/*SCALEY*/] - scaleY) * t;\r\n                shearY += (frames[i + 7/*ENTRIES*/ + 6/*SHEARY*/] - shearY) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                rotate = frames[i + 1/*ROTATE*/];\r\n                x = frames[i + 2/*X*/];\r\n                y = frames[i + 3/*Y*/];\r\n                scaleX = frames[i + 4/*SCALEX*/];\r\n                scaleY = frames[i + 5/*SCALEY*/];\r\n                shearY = frames[i + 6/*SHEARY*/];\r\n                break;\r\n            default:\r\n                rotate = this.getBezierValue(time, i, 1/*ROTATE*/, curveType - 2/*BEZIER*/);\r\n                x = this.getBezierValue(time, i, 2/*X*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n                y = this.getBezierValue(time, i, 3/*Y*/, curveType + 18/*BEZIER_SIZE*/ * 2 - 2/*BEZIER*/);\r\n                scaleX = this.getBezierValue(time, i, 4/*SCALEX*/, curveType + 18/*BEZIER_SIZE*/ * 3 - 2/*BEZIER*/);\r\n                scaleY = this.getBezierValue(time, i, 5/*SCALEY*/, curveType + 18/*BEZIER_SIZE*/ * 4 - 2/*BEZIER*/);\r\n                shearY = this.getBezierValue(time, i, 6/*SHEARY*/, curveType + 18/*BEZIER_SIZE*/ * 5 - 2/*BEZIER*/);\r\n        }\r\n\r\n        if (blend == MixBlend.setup) {\r\n            let data = constraint.data;\r\n            constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\r\n            constraint.mixX = data.mixX + (x - data.mixX) * alpha;\r\n            constraint.mixY = data.mixY + (y - data.mixY) * alpha;\r\n            constraint.mixScaleX = data.mixScaleX + (scaleX - data.mixScaleX) * alpha;\r\n            constraint.mixScaleY = data.mixScaleY + (scaleY - data.mixScaleY) * alpha;\r\n            constraint.mixShearY = data.mixShearY + (shearY - data.mixShearY) * alpha;\r\n        } else {\r\n            constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\r\n            constraint.mixX += (x - constraint.mixX) * alpha;\r\n            constraint.mixY += (y - constraint.mixY) * alpha;\r\n            constraint.mixScaleX += (scaleX - constraint.mixScaleX) * alpha;\r\n            constraint.mixScaleY += (scaleY - constraint.mixScaleY) * alpha;\r\n            constraint.mixShearY += (shearY - constraint.mixShearY) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a path constraint's {@link PathConstraint#position}.\r\n * @public\r\n * */\r\nexport class PathConstraintPositionTimeline extends CurveTimeline1 {\r\n    /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */\r\n    pathConstraintIndex: number;\r\n\r\n    constructor (frameCount: number, bezierCount: number, pathConstraintIndex: number) {\r\n        super(frameCount, bezierCount, Property.pathConstraintPosition + \"|\" + pathConstraintIndex);\r\n        this.pathConstraintIndex = pathConstraintIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n        if (!constraint.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.position = constraint.data.position;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.position += (constraint.data.position - constraint.position) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let position = this.getCurveValue(time);\r\n\r\n        if (blend == MixBlend.setup)\r\n            constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\r\n        else\r\n            constraint.position += (position - constraint.position) * alpha;\r\n    }\r\n}\r\n\r\n/** Changes a path constraint's {@link PathConstraint#spacing}.\r\n * @public\r\n * */\r\nexport class PathConstraintSpacingTimeline extends CurveTimeline1 {\r\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\r\n    pathConstraintIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, pathConstraintIndex: number) {\r\n        super(frameCount, bezierCount, Property.pathConstraintSpacing + \"|\" + pathConstraintIndex);\r\n        this.pathConstraintIndex = pathConstraintIndex;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n        if (!constraint.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.spacing = constraint.data.spacing;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let spacing = this.getCurveValue(time);\r\n\r\n        if (blend == MixBlend.setup)\r\n            constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\r\n        else\r\n            constraint.spacing += (spacing - constraint.spacing) * alpha;\r\n    }\r\n}\r\n\r\n/** Changes a transform constraint's {@link PathConstraint#getMixRotate()}, {@link PathConstraint#getMixX()}, and\r\n * {@link PathConstraint#getMixY()}.\r\n * @public\r\n * */\r\nexport class PathConstraintMixTimeline extends CurveTimeline {\r\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\r\n    pathConstraintIndex = 0;\r\n\r\n    constructor (frameCount: number, bezierCount: number, pathConstraintIndex: number) {\r\n        super(frameCount, bezierCount, [\r\n            Property.pathConstraintMix + \"|\" + pathConstraintIndex\r\n        ]);\r\n        this.pathConstraintIndex = pathConstraintIndex;\r\n    }\r\n\r\n    getFrameEntries () {\r\n        return 4/*ENTRIES*/;\r\n    }\r\n\r\n    setFrame (frame: number, time: number, mixRotate: number, mixX: number, mixY: number) {\r\n        let frames = this.frames;\r\n        frame <<= 2;\r\n        frames[frame] = time;\r\n        frames[frame + 1/*ROTATE*/] = mixRotate;\r\n        frames[frame + 2/*X*/] = mixX;\r\n        frames[frame + 3/*Y*/] = mixY;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n        if (!constraint.active) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.mixRotate = constraint.data.mixRotate;\r\n                    constraint.mixX = constraint.data.mixX;\r\n                    constraint.mixY = constraint.data.mixY;\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;\r\n                    constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;\r\n                    constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;\r\n            }\r\n            return;\r\n        }\r\n\r\n        let rotate, x, y;\r\n        let i = Timeline.search(frames, time, 4/*ENTRIES*/);\r\n        let curveType = this.curves[i >> 2];\r\n        switch (curveType) {\r\n            case 0/*LINEAR*/:\r\n                let before = frames[i];\r\n                rotate = frames[i + 1/*ROTATE*/];\r\n                x = frames[i + 2/*X*/];\r\n                y = frames[i + 3/*Y*/];\r\n                let t = (time - before) / (frames[i + 4/*ENTRIES*/] - before);\r\n                rotate += (frames[i + 4/*ENTRIES*/ + 1/*ROTATE*/] - rotate) * t;\r\n                x += (frames[i + 4/*ENTRIES*/ + 2/*X*/] - x) * t;\r\n                y += (frames[i + 4/*ENTRIES*/ + 3/*Y*/] - y) * t;\r\n                break;\r\n            case 1/*STEPPED*/:\r\n                rotate = frames[i + 1/*ROTATE*/];\r\n                x = frames[i + 2/*X*/];\r\n                y = frames[i + 3/*Y*/];\r\n                break;\r\n            default:\r\n                rotate = this.getBezierValue(time, i, 1/*ROTATE*/, curveType - 2/*BEZIER*/);\r\n                x = this.getBezierValue(time, i, 2/*X*/, curveType + 18/*BEZIER_SIZE*/ - 2/*BEZIER*/);\r\n                y = this.getBezierValue(time, i, 3/*Y*/, curveType + 18/*BEZIER_SIZE*/ * 2 - 2/*BEZIER*/);\r\n        }\r\n\r\n        if (blend == MixBlend.setup) {\r\n            let data = constraint.data;\r\n            constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\r\n            constraint.mixX = data.mixX + (x - data.mixX) * alpha;\r\n            constraint.mixY = data.mixY + (y - data.mixY) * alpha;\r\n        } else {\r\n            constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\r\n            constraint.mixX += (x - constraint.mixX) * alpha;\r\n            constraint.mixY += (y - constraint.mixY) * alpha;\r\n        }\r\n    }\r\n}\r\n","import {IAnimationState, ITrackEntry, MathUtils, Pool, StringSet, Utils} from \"@pixi-spine/base\";\r\nimport {\r\n    Animation,\r\n    AttachmentTimeline,\r\n    DrawOrderTimeline,\r\n    EventTimeline,\r\n    MixBlend,\r\n    MixDirection,\r\n    RotateTimeline, Timeline\r\n} from './Animation';\r\nimport {AnimationStateData} from \"./AnimationStateData\";\r\nimport {Event} from './Event';\r\nimport type {Skeleton} from \"./Skeleton\";\r\nimport type {Slot} from \"./Slot\";\r\n\r\n/** Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies\r\n * multiple animations on top of each other (layering).\r\n *\r\n * See [Applying Animations](http://esotericsoftware.com/spine-applying-animations/) in the Spine Runtimes Guide.\r\n * @public\r\n * */\r\nexport class AnimationState implements IAnimationState {\r\n    private static emptyAnimation (): Animation {\r\n        if (!_emptyAnimation) _emptyAnimation = new Animation(\"<empty>\", [], 0);\r\n        return _emptyAnimation;\r\n    }\r\n\r\n    /** The AnimationStateData to look up mix durations. */\r\n    data: AnimationStateData;\r\n\r\n    /** The list of tracks that currently have animations, which may contain null entries. */\r\n    tracks = new Array<TrackEntry>();\r\n\r\n    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\r\n     * or faster. Defaults to 1.\r\n     *\r\n     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\r\n    timeScale = 1;\r\n    unkeyedState = 0;\r\n\r\n    events = new Array<Event>();\r\n    listeners = new Array<AnimationStateListener>();\r\n    queue = new EventQueue(this);\r\n    propertyIDs = new StringSet();\r\n    animationsChanged = false;\r\n\r\n    trackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\r\n\r\n    constructor (data: AnimationStateData) {\r\n        this.data = data;\r\n    }\r\n\r\n    /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\r\n    update (delta: number) {\r\n        delta *= this.timeScale;\r\n        let tracks = this.tracks;\r\n        for (let i = 0, n = tracks.length; i < n; i++) {\r\n            let current = tracks[i];\r\n            if (!current) continue;\r\n\r\n            current.animationLast = current.nextAnimationLast;\r\n            current.trackLast = current.nextTrackLast;\r\n\r\n            let currentDelta = delta * current.timeScale;\r\n\r\n            if (current.delay > 0) {\r\n                current.delay -= currentDelta;\r\n                if (current.delay > 0) continue;\r\n                currentDelta = -current.delay;\r\n                current.delay = 0;\r\n            }\r\n\r\n            let next = current.next;\r\n            if (next) {\r\n                // When the next entry's delay is passed, change to the next entry, preserving leftover time.\r\n                let nextTime = current.trackLast - next.delay;\r\n                if (nextTime >= 0) {\r\n                    next.delay = 0;\r\n                    next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\r\n                    current.trackTime += currentDelta;\r\n                    this.setCurrent(i, next, true);\r\n                    while (next.mixingFrom) {\r\n                        next.mixTime += delta;\r\n                        next = next.mixingFrom;\r\n                    }\r\n                    continue;\r\n                }\r\n            } else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {\r\n                tracks[i] = null;\r\n                this.queue.end(current);\r\n                this.clearNext(current);\r\n                continue;\r\n            }\r\n            if (current.mixingFrom && this.updateMixingFrom(current, delta)) {\r\n                // End mixing from entries once all have completed.\r\n                let from = current.mixingFrom;\r\n                current.mixingFrom = null;\r\n                if (from) from.mixingTo = null;\r\n                while (from) {\r\n                    this.queue.end(from);\r\n                    from = from.mixingFrom;\r\n                }\r\n            }\r\n\r\n            current.trackTime += currentDelta;\r\n        }\r\n\r\n        this.queue.drain();\r\n    }\r\n\r\n    /** Returns true when all mixing from entries are complete. */\r\n    updateMixingFrom (to: TrackEntry, delta: number): boolean {\r\n        let from = to.mixingFrom;\r\n        if (!from) return true;\r\n\r\n        let finished = this.updateMixingFrom(from, delta);\r\n\r\n        from.animationLast = from.nextAnimationLast;\r\n        from.trackLast = from.nextTrackLast;\r\n\r\n        // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\r\n        if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\r\n            // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).\r\n            if (from.totalAlpha == 0 || to.mixDuration == 0) {\r\n                to.mixingFrom = from.mixingFrom;\r\n                if (from.mixingFrom) from.mixingFrom.mixingTo = to;\r\n                to.interruptAlpha = from.interruptAlpha;\r\n                this.queue.end(from);\r\n            }\r\n            return finished;\r\n        }\r\n\r\n        from.trackTime += delta * from.timeScale;\r\n        to.mixTime += delta;\r\n        return false;\r\n    }\r\n\r\n    /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\r\n     * animation state can be applied to multiple skeletons to pose them identically.\r\n     * @returns True if any animations were applied. */\r\n    apply (skeleton: Skeleton) : boolean {\r\n        if (!skeleton) throw new Error(\"skeleton cannot be null.\");\r\n        if (this.animationsChanged) this._animationsChanged();\r\n\r\n        let events = this.events;\r\n        let tracks = this.tracks;\r\n        let applied = false;\r\n\r\n        for (let i = 0, n = tracks.length; i < n; i++) {\r\n            let current = tracks[i];\r\n            if (!current || current.delay > 0) continue;\r\n            applied = true;\r\n            let blend: MixBlend = i == 0 ? MixBlend.first : current.mixBlend;\r\n\r\n            // Apply mixing from entries first.\r\n            let mix = current.alpha;\r\n            if (current.mixingFrom)\r\n                mix *= this.applyMixingFrom(current, skeleton, blend);\r\n            else if (current.trackTime >= current.trackEnd && !current.next)\r\n                mix = 0;\r\n\r\n            // Apply current entry.\r\n            let animationLast = current.animationLast, animationTime = current.getAnimationTime(), applyTime = animationTime;\r\n            let applyEvents = events;\r\n            if (current.reverse) {\r\n                applyTime = current.animation.duration - applyTime;\r\n                applyEvents = null;\r\n            }\r\n            let timelines = current.animation.timelines;\r\n            let timelineCount = timelines.length;\r\n            if ((i == 0 && mix == 1) || blend == MixBlend.add) {\r\n                for (let ii = 0; ii < timelineCount; ii++) {\r\n                    // Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\r\n                    // to sometimes stop rendering when using color correction, as their RGBA values become NaN.\r\n                    // (https://github.com/pixijs/pixi-spine/issues/302)\r\n                    Utils.webkit602BugfixHelper(mix, blend);\r\n                    var timeline = timelines[ii];\r\n                    if (timeline instanceof AttachmentTimeline)\r\n                        this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\r\n                    else\r\n                        timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, blend, MixDirection.mixIn);\r\n                }\r\n            } else {\r\n                let timelineMode = current.timelineMode;\r\n\r\n                let firstFrame = current.timelinesRotation.length != timelineCount << 1;\r\n                if (firstFrame) current.timelinesRotation.length = timelineCount << 1;\r\n\r\n                for (let ii = 0; ii < timelineCount; ii++) {\r\n                    let timeline = timelines[ii];\r\n                    let timelineBlend = timelineMode[ii] == SUBSEQUENT ? blend : MixBlend.setup;\r\n                    if (timeline instanceof RotateTimeline) {\r\n                        this.applyRotateTimeline(timeline, skeleton, applyTime, mix, timelineBlend, current.timelinesRotation, ii << 1, firstFrame);\r\n                    } else if (timeline instanceof AttachmentTimeline) {\r\n                        this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\r\n                    } else {\r\n                        // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n                        Utils.webkit602BugfixHelper(mix, blend);\r\n                        timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, timelineBlend, MixDirection.mixIn);\r\n                    }\r\n                }\r\n            }\r\n            this.queueEvents(current, animationTime);\r\n            events.length = 0;\r\n            current.nextAnimationLast = animationTime;\r\n            current.nextTrackLast = current.trackTime;\r\n        }\r\n\r\n        // Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so\r\n        // subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or\r\n        // the time is before the first key).\r\n        var setupState = this.unkeyedState + SETUP;\r\n        var slots = skeleton.slots;\r\n        for (var i = 0, n = skeleton.slots.length; i < n; i++) {\r\n            var slot = slots[i];\r\n            if (slot.attachmentState == setupState) {\r\n                var attachmentName = slot.data.attachmentName;\r\n                slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\r\n            }\r\n        }\r\n        this.unkeyedState += 2; // Increasing after each use avoids the need to reset attachmentState for every slot.\r\n\r\n        this.queue.drain();\r\n        return applied;\r\n    }\r\n\r\n    applyMixingFrom (to: TrackEntry, skeleton: Skeleton, blend: MixBlend) {\r\n        let from = to.mixingFrom;\r\n        if (from.mixingFrom) this.applyMixingFrom(from, skeleton, blend);\r\n\r\n        let mix = 0;\r\n        if (to.mixDuration == 0) { // Single frame mix to undo mixingFrom changes.\r\n            mix = 1;\r\n            if (blend == MixBlend.first) blend = MixBlend.setup;\r\n        } else {\r\n            mix = to.mixTime / to.mixDuration;\r\n            if (mix > 1) mix = 1;\r\n            if (blend != MixBlend.first) blend = from.mixBlend;\r\n        }\r\n\r\n        let attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;\r\n        let timelines = from.animation.timelines;\r\n        let timelineCount = timelines.length;\r\n        let alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);\r\n        let animationLast = from.animationLast, animationTime = from.getAnimationTime(), applyTime = animationTime;\r\n        let events = null;\r\n        if (from.reverse)\r\n            applyTime = from.animation.duration - applyTime;\r\n        else if (mix < from.eventThreshold)\r\n            events = this.events;\r\n\r\n        if (blend == MixBlend.add) {\r\n            for (let i = 0; i < timelineCount; i++)\r\n                timelines[i].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, MixDirection.mixOut);\r\n        } else {\r\n            let timelineMode = from.timelineMode;\r\n            let timelineHoldMix = from.timelineHoldMix;\r\n\r\n            let firstFrame = from.timelinesRotation.length != timelineCount << 1;\r\n            if (firstFrame) from.timelinesRotation.length = timelineCount << 1;\r\n\r\n            from.totalAlpha = 0;\r\n            for (let i = 0; i < timelineCount; i++) {\r\n                let timeline = timelines[i];\r\n                let direction = MixDirection.mixOut;\r\n                let timelineBlend: MixBlend;\r\n                let alpha = 0;\r\n                switch (timelineMode[i]) {\r\n                    case SUBSEQUENT:\r\n                        if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\r\n                        timelineBlend = blend;\r\n                        alpha = alphaMix;\r\n                        break;\r\n                    case FIRST:\r\n                        timelineBlend = MixBlend.setup;\r\n                        alpha = alphaMix;\r\n                        break;\r\n                    case HOLD_SUBSEQUENT:\r\n                        timelineBlend = blend;\r\n                        alpha = alphaHold;\r\n                        break;\r\n                    case HOLD_FIRST:\r\n                        timelineBlend = MixBlend.setup;\r\n                        alpha = alphaHold;\r\n                        break;\r\n                    default:\r\n                        timelineBlend = MixBlend.setup;\r\n                        let holdMix = timelineHoldMix[i];\r\n                        alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\r\n                        break;\r\n                }\r\n                from.totalAlpha += alpha;\r\n\r\n                if (timeline instanceof RotateTimeline)\r\n                    this.applyRotateTimeline(timeline, skeleton, applyTime, alpha, timelineBlend, from.timelinesRotation, i << 1, firstFrame);\r\n                else if (timeline instanceof AttachmentTimeline)\r\n                    this.applyAttachmentTimeline(timeline, skeleton, applyTime, timelineBlend, attachments);\r\n                else {\r\n                    // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n                    Utils.webkit602BugfixHelper(alpha, blend);\r\n                    if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup)\r\n                        direction = MixDirection.mixIn;\r\n                    timeline.apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (to.mixDuration > 0) this.queueEvents(from, animationTime);\r\n        this.events.length = 0;\r\n        from.nextAnimationLast = animationTime;\r\n        from.nextTrackLast = from.trackTime;\r\n\r\n        return mix;\r\n    }\r\n\r\n    applyAttachmentTimeline (timeline: AttachmentTimeline, skeleton: Skeleton, time: number, blend: MixBlend, attachments: boolean) {\r\n        var slot = skeleton.slots[timeline.slotIndex];\r\n        if (!slot.bone.active) return;\r\n\r\n        if (time < timeline.frames[0]) { // Time is before first frame.\r\n            if (blend == MixBlend.setup || blend == MixBlend.first)\r\n                this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\r\n        } else\r\n            this.setAttachment(skeleton, slot, timeline.attachmentNames[Timeline.search1(timeline.frames, time)], attachments);\r\n\r\n        // If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.\r\n        if (slot.attachmentState <= this.unkeyedState) slot.attachmentState = this.unkeyedState + SETUP;\r\n    }\r\n\r\n    setAttachment (skeleton: Skeleton, slot: Slot, attachmentName: string, attachments: boolean) {\r\n        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\r\n        if (attachments) slot.attachmentState = this.unkeyedState + CURRENT;\r\n    }\r\n\r\n    applyRotateTimeline (timeline: RotateTimeline, skeleton: Skeleton, time: number, alpha: number, blend: MixBlend,\r\n                         timelinesRotation: Array<number>, i: number, firstFrame: boolean) {\r\n\r\n        if (firstFrame) timelinesRotation[i] = 0;\r\n\r\n        if (alpha == 1) {\r\n            timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\r\n            return;\r\n        }\r\n\r\n        let bone = skeleton.bones[timeline.boneIndex];\r\n        if (!bone.active) return;\r\n        let frames = timeline.frames;\r\n        let r1 = 0, r2 = 0;\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation;\r\n                default:\r\n                    return;\r\n                case MixBlend.first:\r\n                    r1 = bone.rotation;\r\n                    r2 = bone.data.rotation;\r\n            }\r\n        } else {\r\n            r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\r\n            r2 = bone.data.rotation + timeline.getCurveValue(time);\r\n        }\r\n\r\n        // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\r\n        let total = 0, diff = r2 - r1;\r\n        diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\r\n        if (diff == 0) {\r\n            total = timelinesRotation[i];\r\n        } else {\r\n            let lastTotal = 0, lastDiff = 0;\r\n            if (firstFrame) {\r\n                lastTotal = 0;\r\n                lastDiff = diff;\r\n            } else {\r\n                lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\r\n                lastDiff = timelinesRotation[i + 1]; // Difference between bones.\r\n            }\r\n            let current = diff > 0, dir = lastTotal >= 0;\r\n            // Detect cross at 0 (not 180).\r\n            if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\r\n                // A cross after a 360 rotation is a loop.\r\n                if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\r\n                dir = current;\r\n            }\r\n            total = diff + lastTotal - lastTotal % 360; // Store loops as part of lastTotal.\r\n            if (dir != current) total += 360 * MathUtils.signum(lastTotal);\r\n            timelinesRotation[i] = total;\r\n        }\r\n        timelinesRotation[i + 1] = diff;\r\n        bone.rotation = r1 + total * alpha;\r\n    }\r\n\r\n    queueEvents (entry: TrackEntry, animationTime: number) {\r\n        let animationStart = entry.animationStart, animationEnd = entry.animationEnd;\r\n        let duration = animationEnd - animationStart;\r\n        let trackLastWrapped = entry.trackLast % duration;\r\n\r\n        // Queue events before complete.\r\n        let events = this.events;\r\n        let i = 0, n = events.length;\r\n        for (; i < n; i++) {\r\n            let event = events[i];\r\n            if (event.time < trackLastWrapped) break;\r\n            if (event.time > animationEnd) continue; // Discard events outside animation start/end.\r\n            this.queue.event(entry, event);\r\n        }\r\n\r\n        // Queue complete if completed a loop iteration or the animation.\r\n        let complete = false;\r\n        if (entry.loop)\r\n            complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\r\n        else\r\n            complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\r\n        if (complete) this.queue.complete(entry);\r\n\r\n        // Queue events after complete.\r\n        for (; i < n; i++) {\r\n            let event = events[i];\r\n            if (event.time < animationStart) continue; // Discard events outside animation start/end.\r\n            this.queue.event(entry, event);\r\n        }\r\n    }\r\n\r\n    /** Removes all animations from all tracks, leaving skeletons in their current pose.\r\n     *\r\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\r\n     * rather than leaving them in their current pose. */\r\n    clearTracks () {\r\n        let oldDrainDisabled = this.queue.drainDisabled;\r\n        this.queue.drainDisabled = true;\r\n        for (let i = 0, n = this.tracks.length; i < n; i++)\r\n            this.clearTrack(i);\r\n        this.tracks.length = 0;\r\n        this.queue.drainDisabled = oldDrainDisabled;\r\n        this.queue.drain();\r\n    }\r\n\r\n    /** Removes all animations from the track, leaving skeletons in their current pose.\r\n     *\r\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\r\n     * rather than leaving them in their current pose. */\r\n    clearTrack (trackIndex: number) {\r\n        if (trackIndex >= this.tracks.length) return;\r\n        let current = this.tracks[trackIndex];\r\n        if (!current) return;\r\n\r\n        this.queue.end(current);\r\n\r\n        this.clearNext(current);\r\n\r\n        let entry = current;\r\n        while (true) {\r\n            let from = entry.mixingFrom;\r\n            if (!from) break;\r\n            this.queue.end(from);\r\n            entry.mixingFrom = null;\r\n            entry.mixingTo = null;\r\n            entry = from;\r\n        }\r\n\r\n        this.tracks[current.trackIndex] = null;\r\n\r\n        this.queue.drain();\r\n    }\r\n\r\n    setCurrent (index: number, current: TrackEntry, interrupt: boolean) {\r\n        let from = this.expandToIndex(index);\r\n        this.tracks[index] = current;\r\n        current.previous = null;\r\n\r\n        if (from) {\r\n            if (interrupt) this.queue.interrupt(from);\r\n            current.mixingFrom = from;\r\n            from.mixingTo = current;\r\n            current.mixTime = 0;\r\n\r\n            // Store the interrupted mix percentage.\r\n            if (from.mixingFrom && from.mixDuration > 0)\r\n                current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\r\n\r\n            from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\r\n        }\r\n\r\n        this.queue.start(current);\r\n    }\r\n\r\n    /** Sets an animation by name.\r\n     *\r\n     * See {@link #setAnimationWith()}. */\r\n    setAnimation (trackIndex: number, animationName: string, loop: boolean = false) {\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (!animation) throw new Error(\"Animation not found: \" + animationName);\r\n        return this.setAnimationWith(trackIndex, animation, loop);\r\n    }\r\n\r\n    /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\r\n     * applied to a skeleton, it is replaced (not mixed from).\r\n     * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\r\n     *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\r\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n    setAnimationWith (trackIndex: number, animation: Animation, loop: boolean = false) {\r\n        if (!animation) throw new Error(\"animation cannot be null.\");\r\n        let interrupt = true;\r\n        let current = this.expandToIndex(trackIndex);\r\n        if (current) {\r\n            if (current.nextTrackLast == -1) {\r\n                // Don't mix from an entry that was never applied.\r\n                this.tracks[trackIndex] = current.mixingFrom;\r\n                this.queue.interrupt(current);\r\n                this.queue.end(current);\r\n                this.clearNext(current);\r\n                current = current.mixingFrom;\r\n                interrupt = false;\r\n            } else\r\n                this.clearNext(current);\r\n        }\r\n        let entry = this.trackEntry(trackIndex, animation, loop, current);\r\n        this.setCurrent(trackIndex, entry, interrupt);\r\n        this.queue.drain();\r\n        return entry;\r\n    }\r\n\r\n    /** Queues an animation by name.\r\n     *\r\n     * See {@link #addAnimationWith()}. */\r\n    addAnimation (trackIndex: number, animationName: string, loop: boolean = false, delay: number = 0) {\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (!animation) throw new Error(\"Animation not found: \" + animationName);\r\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\r\n    }\r\n\r\n    /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\r\n     * equivalent to calling {@link #setAnimationWith()}.\r\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\r\n     *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\r\n     *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\r\n     *           previous entry is looping, its next loop completion is used instead of its duration.\r\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n    addAnimationWith (trackIndex: number, animation: Animation, loop: boolean = false, delay: number = 0) {\r\n        if (!animation) throw new Error(\"animation cannot be null.\");\r\n\r\n        let last = this.expandToIndex(trackIndex);\r\n        if (last) {\r\n            while (last.next)\r\n                last = last.next;\r\n        }\r\n\r\n        let entry = this.trackEntry(trackIndex, animation, loop, last);\r\n\r\n        if (!last) {\r\n            this.setCurrent(trackIndex, entry, true);\r\n            this.queue.drain();\r\n        } else {\r\n            last.next = entry;\r\n            entry.previous = last;\r\n            if (delay <= 0) delay += last.getTrackComplete() - entry.mixDuration;\r\n        }\r\n\r\n        entry.delay = delay;\r\n        return entry;\r\n    }\r\n\r\n    /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\r\n     * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\r\n     *\r\n     * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\r\n     * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\r\n     * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\r\n     * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\r\n     * 0 still mixes out over one frame.\r\n     *\r\n     * Mixing in is done by first setting an empty animation, then adding an animation using\r\n     * {@link #addAnimation()} and on the returned track entry, set the\r\n     * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\r\n     * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\r\n     * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\r\n    setEmptyAnimation (trackIndex: number, mixDuration: number = 0) {\r\n        let entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation(), false);\r\n        entry.mixDuration = mixDuration;\r\n        entry.trackEnd = mixDuration;\r\n        return entry;\r\n    }\r\n\r\n    /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\r\n     * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\r\n     * {@link #setEmptyAnimation()}.\r\n     *\r\n     * See {@link #setEmptyAnimation()}.\r\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\r\n     *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\r\n     *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\r\n     *           loop completion is used instead of its duration.\r\n     * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n    addEmptyAnimation (trackIndex: number, mixDuration: number = 0, delay: number = 0) {\r\n        let entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation(), false, delay <= 0 ? 1 : delay);\r\n        entry.mixDuration = mixDuration;\r\n        entry.trackEnd = mixDuration;\r\n        if (delay <= 0 && entry.previous) entry.delay = entry.previous.getTrackComplete() - entry.mixDuration + delay;\r\n        return entry;\r\n    }\r\n\r\n    /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\r\n     * duration. */\r\n    setEmptyAnimations (mixDuration: number = 0) {\r\n        let oldDrainDisabled = this.queue.drainDisabled;\r\n        this.queue.drainDisabled = true;\r\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\r\n            let current = this.tracks[i];\r\n            if (current) this.setEmptyAnimation(current.trackIndex, mixDuration);\r\n        }\r\n        this.queue.drainDisabled = oldDrainDisabled;\r\n        this.queue.drain();\r\n    }\r\n\r\n    expandToIndex (index: number) {\r\n        if (index < this.tracks.length) return this.tracks[index];\r\n        Utils.ensureArrayCapacity(this.tracks, index + 1, null);\r\n        this.tracks.length = index + 1;\r\n        return null;\r\n    }\r\n\r\n    /** @param last May be null. */\r\n    trackEntry (trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry) {\r\n        let entry = this.trackEntryPool.obtain();\r\n        entry.trackIndex = trackIndex;\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.holdPrevious = false;\r\n\r\n        entry.eventThreshold = 0;\r\n        entry.attachmentThreshold = 0;\r\n        entry.drawOrderThreshold = 0;\r\n\r\n        entry.animationStart = 0;\r\n        entry.animationEnd = animation.duration;\r\n        entry.animationLast = -1;\r\n        entry.nextAnimationLast = -1;\r\n\r\n        entry.delay = 0;\r\n        entry.trackTime = 0;\r\n        entry.trackLast = -1;\r\n        entry.nextTrackLast = -1;\r\n        entry.trackEnd = Number.MAX_VALUE;\r\n        entry.timeScale = 1;\r\n\r\n        entry.alpha = 1;\r\n        entry.interruptAlpha = 1;\r\n        entry.mixTime = 0;\r\n        entry.mixDuration = !last ? 0 : this.data.getMix(last.animation, animation);\r\n        entry.mixBlend = MixBlend.replace;\r\n        return entry;\r\n    }\r\n\r\n    /** Removes the {@link TrackEntry#getNext() next entry} and all entries after it for the specified entry. */\r\n    clearNext (entry: TrackEntry) {\r\n        let next = entry.next;\r\n        while (next) {\r\n            this.queue.dispose(next);\r\n            next = next.next;\r\n        }\r\n        entry.next = null;\r\n    }\r\n\r\n    _animationsChanged () {\r\n        this.animationsChanged = false;\r\n\r\n        this.propertyIDs.clear();\r\n        let tracks = this.tracks;\r\n        for (let i = 0, n = tracks.length; i < n; i++) {\r\n            let entry = tracks[i];\r\n            if (!entry) continue;\r\n            while (entry.mixingFrom)\r\n                entry = entry.mixingFrom;\r\n            do {\r\n                if (!entry.mixingTo || entry.mixBlend != MixBlend.add) this.computeHold(entry);\r\n                entry = entry.mixingTo;\r\n            } while (entry);\r\n        }\r\n    }\r\n\r\n    computeHold (entry: TrackEntry) {\r\n        let to = entry.mixingTo;\r\n        let timelines = entry.animation.timelines;\r\n        let timelinesCount = entry.animation.timelines.length;\r\n        let timelineMode = entry.timelineMode;\r\n        timelineMode.length = timelinesCount;\r\n        let timelineHoldMix = entry.timelineHoldMix;\r\n        timelineHoldMix.length = 0;\r\n        let propertyIDs = this.propertyIDs;\r\n\r\n        if (to && to.holdPrevious) {\r\n            for (let i = 0; i < timelinesCount; i++)\r\n                timelineMode[i] = propertyIDs.addAll(timelines[i].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;\r\n            return;\r\n        }\r\n\r\n        outer:\r\n            for (let i = 0; i < timelinesCount; i++) {\r\n                let timeline = timelines[i];\r\n                let ids = timeline.getPropertyIds();\r\n                if (!propertyIDs.addAll(ids))\r\n                    timelineMode[i] = SUBSEQUENT;\r\n                else if (!to || timeline instanceof AttachmentTimeline || timeline instanceof DrawOrderTimeline\r\n                    || timeline instanceof EventTimeline || !to.animation.hasTimeline(ids)) {\r\n                    timelineMode[i] = FIRST;\r\n                }else {\r\n                    for (let next = to.mixingTo; next; next = next.mixingTo) {\r\n                        if (next.animation.hasTimeline(ids)) continue;\r\n                        if (entry.mixDuration > 0) {\r\n                            timelineMode[i] = HOLD_MIX;\r\n                            timelineHoldMix[i] = next;\r\n                            continue outer;\r\n                        }\r\n                        break;\r\n                    }\r\n                    timelineMode[i] = HOLD_FIRST;\r\n                }\r\n            }\r\n    }\r\n\r\n    /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\r\n    getCurrent (trackIndex: number) {\r\n        if (trackIndex >= this.tracks.length) return null;\r\n        return this.tracks[trackIndex];\r\n    }\r\n\r\n    /** Adds a listener to receive events for all track entries. */\r\n    addListener (listener: AnimationStateListener) {\r\n        if (!listener) throw new Error(\"listener cannot be null.\");\r\n        this.listeners.push(listener);\r\n    }\r\n\r\n    /** Removes the listener added with {@link #addListener()}. */\r\n    removeListener (listener: AnimationStateListener) {\r\n        let index = this.listeners.indexOf(listener);\r\n        if (index >= 0) this.listeners.splice(index, 1);\r\n    }\r\n\r\n    /** Removes all listeners added with {@link #addListener()}. */\r\n    clearListeners () {\r\n        this.listeners.length = 0;\r\n    }\r\n\r\n    /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\r\n     * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\r\n     * are not wanted because new animations are being set. */\r\n    clearListenerNotifications () {\r\n        this.queue.clear();\r\n    }\r\n\r\n    //deprecated stuff\r\n    onComplete: (trackIndex: number, loopCount: number) => any;\r\n    onEvent: (trackIndex: number, event: Event) => any;\r\n    onStart: (trackIndex: number) => any;\r\n    onEnd: (trackIndex: number) => any;\r\n\r\n    private static deprecatedWarning1: boolean = false;\r\n\r\n    setAnimationByName(trackIndex: number, animationName: string, loop: boolean) {\r\n        if (!AnimationState.deprecatedWarning1) {\r\n            AnimationState.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\r\n        }\r\n        this.setAnimation(trackIndex, animationName, loop);\r\n    }\r\n\r\n    private static deprecatedWarning2: boolean = false;\r\n\r\n    addAnimationByName(trackIndex: number, animationName: string, loop: boolean, delay: number) {\r\n        if (!AnimationState.deprecatedWarning2) {\r\n            AnimationState.deprecatedWarning2 = true;\r\n            console.warn(\"Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\r\n        }\r\n        this.addAnimation(trackIndex, animationName, loop, delay);\r\n    }\r\n\r\n    private static deprecatedWarning3: boolean = false;\r\n\r\n    hasAnimation(animationName: string): boolean {\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        return animation !== null;\r\n    }\r\n\r\n    hasAnimationByName(animationName: string): boolean {\r\n        if (!AnimationState.deprecatedWarning3) {\r\n            AnimationState.deprecatedWarning3 = true;\r\n            console.warn(\"Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\r\n        }\r\n        return this.hasAnimation(animationName);\r\n    }\r\n}\r\n\r\n/** Stores settings and other state for the playback of an animation on an {@link AnimationState} track.\r\n *\r\n * References to a track entry must not be kept after the {@link AnimationStateListener#dispose()} event occurs.\r\n * @public\r\n * */\r\nexport class TrackEntry implements ITrackEntry {\r\n    /** The animation to apply for this track entry. */\r\n    animation: Animation;\r\n\r\n    previous: TrackEntry;\r\n\r\n    /** The animation queued to start after this animation, or null. `next` makes up a linked list. */\r\n    next: TrackEntry;\r\n\r\n    /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no\r\n     * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */\r\n    mixingFrom: TrackEntry;\r\n\r\n    /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is\r\n     * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */\r\n    mixingTo: TrackEntry;\r\n\r\n    /** The listener for events generated by this track entry, or null.\r\n     *\r\n     * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation\r\n     * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */\r\n    listener: AnimationStateListener;\r\n\r\n    /** The index of the track where this track entry is either current or queued.\r\n     *\r\n     * See {@link AnimationState#getCurrent()}. */\r\n    trackIndex: number;\r\n\r\n    /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\r\n     * duration. */\r\n    loop: boolean;\r\n\r\n    /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead\r\n     * of being mixed out.\r\n     *\r\n     * When mixing between animations that key the same property, if a lower track also keys that property then the value will\r\n     * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%\r\n     * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation\r\n     * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which\r\n     * keys the property, only when a higher track also keys the property.\r\n     *\r\n     * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the\r\n     * previous animation. */\r\n    holdPrevious: boolean;\r\n\r\n    reverse: boolean;\r\n\r\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\r\n     * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event\r\n     * timelines are not applied while this animation is being mixed out. */\r\n    eventThreshold: number;\r\n\r\n    /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the\r\n     * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to\r\n     * 0, so attachment timelines are not applied while this animation is being mixed out. */\r\n    attachmentThreshold: number;\r\n\r\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\r\n     * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,\r\n     * so draw order timelines are not applied while this animation is being mixed out. */\r\n    drawOrderThreshold: number;\r\n\r\n    /** Seconds when this animation starts, both initially and after looping. Defaults to 0.\r\n     *\r\n     * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same\r\n     * value to prevent timeline keys before the start time from triggering. */\r\n    animationStart: number;\r\n\r\n    /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will\r\n     * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */\r\n    animationEnd: number;\r\n\r\n\r\n    /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this\r\n     * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and\r\n     * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation\r\n     * is applied. */\r\n    animationLast: number;\r\n\r\n    nextAnimationLast: number;\r\n\r\n    /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`\r\n     * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from\r\n     * the start of the previous animation to when this track entry will become the current track entry (ie when the previous\r\n     * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).\r\n     *\r\n     * {@link #timeScale} affects the delay. */\r\n    delay: number;\r\n\r\n    /** Current time in seconds this track entry has been the current track entry. The track time determines\r\n     * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting\r\n     * looping. */\r\n    trackTime: number;\r\n\r\n    trackLast: number; nextTrackLast: number;\r\n\r\n    /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float\r\n     * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time\r\n     * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the\r\n     * properties keyed by the animation are set to the setup pose and the track is cleared.\r\n     *\r\n     * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation\r\n     * abruptly cease being applied. */\r\n    trackEnd: number;\r\n\r\n    /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or\r\n     * faster. Defaults to 1.\r\n     *\r\n     * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to\r\n     * match the animation speed.\r\n     *\r\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\r\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If\r\n     * the time scale is not 1, the delay may need to be adjusted.\r\n     *\r\n     * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */\r\n    timeScale: number;\r\n\r\n    /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults\r\n     * to 1, which overwrites the skeleton's current pose with this animation.\r\n     *\r\n     * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to\r\n     * use alpha on track 0 if the skeleton pose is from the last frame render. */\r\n    alpha: number;\r\n\r\n    /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be\r\n     * slightly more than `mixDuration` when the mix is complete. */\r\n    mixTime: number;\r\n\r\n    /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData\r\n     * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).\r\n     *\r\n     * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the\r\n     * properties it was animating.\r\n     *\r\n     * The `mixDuration` can be set manually rather than use the value from\r\n     * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new\r\n     * track entry only before {@link AnimationState#update(float)} is first called.\r\n     *\r\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\r\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set\r\n     * afterward. */\r\n    mixDuration: number; interruptAlpha: number; totalAlpha: number;\r\n\r\n    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\r\n     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\r\n     * the values from the lower tracks.\r\n     *\r\n     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\r\n     * called. */\r\n    mixBlend = MixBlend.replace;\r\n    timelineMode = new Array<number>();\r\n    timelineHoldMix = new Array<TrackEntry>();\r\n    timelinesRotation = new Array<number>();\r\n\r\n    reset () {\r\n        this.previous = null;\r\n        this.next = null;\r\n        this.mixingFrom = null;\r\n        this.mixingTo = null;\r\n        this.animation = null;\r\n        this.listener = null;\r\n        this.timelineMode.length = 0;\r\n        this.timelineHoldMix.length = 0;\r\n        this.timelinesRotation.length = 0;\r\n    }\r\n\r\n    /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\r\n     * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\r\n     * `animationStart` time. */\r\n    getAnimationTime () {\r\n        if (this.loop) {\r\n            let duration = this.animationEnd - this.animationStart;\r\n            if (duration == 0) return this.animationStart;\r\n            return (this.trackTime % duration) + this.animationStart;\r\n        }\r\n        return Math.min(this.trackTime + this.animationStart, this.animationEnd);\r\n    }\r\n\r\n    setAnimationLast(animationLast: number) {\r\n        this.animationLast = animationLast;\r\n        this.nextAnimationLast = animationLast;\r\n    }\r\n\r\n    /** Returns true if at least one loop has been completed.\r\n     *\r\n     * See {@link AnimationStateListener#complete()}. */\r\n    isComplete () {\r\n        return this.trackTime >= this.animationEnd - this.animationStart;\r\n    }\r\n\r\n    /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\r\n     * long way around when using {@link #alpha} and starting animations on other tracks.\r\n     *\r\n     * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\r\n     * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\r\n     * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\r\n     * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\r\n    resetRotationDirections () {\r\n        this.timelinesRotation.length = 0;\r\n    }\r\n\r\n    getTrackComplete() {\r\n        let duration = this.animationEnd - this.animationStart;\r\n        if (duration != 0) {\r\n            if (this.loop) return duration * (1 + ((this.trackTime / duration) | 0)); // Completion of next loop.\r\n            if (this.trackTime < duration) return duration; // Before duration.\r\n        }\r\n        return this.trackTime; // Next update.\r\n    }\r\n\r\n    //deprecated stuff\r\n    onComplete: (trackIndex: number, loopCount: number) => any;\r\n    onEvent: (trackIndex: number, event: Event) => any;\r\n    onStart: (trackIndex: number) => any;\r\n    onEnd: (trackIndex: number) => any;\r\n\r\n    private static deprecatedWarning1: Boolean = false;\r\n    private static deprecatedWarning2: Boolean = false;\r\n\r\n    get time() {\r\n        if (!TrackEntry.deprecatedWarning1) {\r\n            TrackEntry.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\r\n        }\r\n        return this.trackTime;\r\n    }\r\n\r\n    set time(value: number) {\r\n        if (!TrackEntry.deprecatedWarning1) {\r\n            TrackEntry.deprecatedWarning1 = true;\r\n            console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\r\n        }\r\n        this.trackTime = value;\r\n    }\r\n\r\n    get endTime() {\r\n        if (!TrackEntry.deprecatedWarning2) {\r\n            TrackEntry.deprecatedWarning2 = true;\r\n            console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\r\n        }\r\n        return this.trackTime;\r\n    }\r\n\r\n    set endTime(value: number) {\r\n        if (!TrackEntry.deprecatedWarning2) {\r\n            TrackEntry.deprecatedWarning2 = true;\r\n            console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\r\n        }\r\n        this.trackTime = value;\r\n    }\r\n\r\n    loopsCount() {\r\n        return Math.floor(this.trackTime / this.trackEnd);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class EventQueue {\r\n    objects: Array<any> = [];\r\n    drainDisabled = false;\r\n    animState: AnimationState;\r\n\r\n    constructor(animState: AnimationState) {\r\n        this.animState = animState;\r\n    }\r\n\r\n    start (entry: TrackEntry) {\r\n        this.objects.push(EventType.start);\r\n        this.objects.push(entry);\r\n        this.animState.animationsChanged = true;\r\n    }\r\n\r\n    interrupt (entry: TrackEntry) {\r\n        this.objects.push(EventType.interrupt);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    end (entry: TrackEntry) {\r\n        this.objects.push(EventType.end);\r\n        this.objects.push(entry);\r\n        this.animState.animationsChanged = true;\r\n    }\r\n\r\n    dispose (entry: TrackEntry) {\r\n        this.objects.push(EventType.dispose);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    complete (entry: TrackEntry) {\r\n        this.objects.push(EventType.complete);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    event (entry: TrackEntry, event: Event) {\r\n        this.objects.push(EventType.event);\r\n        this.objects.push(entry);\r\n        this.objects.push(event);\r\n    }\r\n\r\n    drain () {\r\n        if (this.drainDisabled) return;\r\n        this.drainDisabled = true;\r\n\r\n        let objects = this.objects;\r\n        let listeners = this.animState.listeners;\r\n\r\n        for (let i = 0; i < objects.length; i += 2) {\r\n            let type = objects[i] as EventType;\r\n            let entry = objects[i + 1] as TrackEntry;\r\n            switch (type) {\r\n                case EventType.start:\r\n                    if (entry.listener != null && entry.listener.start) entry.listener.start(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++)\r\n                        if (listeners[ii].start) listeners[ii].start(entry);\r\n                    break;\r\n                case EventType.interrupt:\r\n                    if (entry.listener != null && entry.listener.interrupt) entry.listener.interrupt(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++)\r\n                        if (listeners[ii].interrupt) listeners[ii].interrupt(entry);\r\n                    break;\r\n                case EventType.end:\r\n                    if (entry.listener != null && entry.listener.end) entry.listener.end(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++)\r\n                        if (listeners[ii].end) listeners[ii].end(entry);\r\n                // Fall through.\r\n                case EventType.dispose:\r\n                    if (entry.listener != null && entry.listener.dispose) entry.listener.dispose(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++)\r\n                        if (listeners[ii].dispose) listeners[ii].dispose(entry);\r\n                    this.animState.trackEntryPool.free(entry);\r\n                    break;\r\n                case EventType.complete:\r\n                    if (entry.listener != null && entry.listener.complete) entry.listener.complete(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++)\r\n                        if (listeners[ii].complete) listeners[ii].complete(entry);\r\n                    break;\r\n                case EventType.event:\r\n                    let event = objects[i++ + 2] as Event;\r\n                    if (entry.listener != null && entry.listener.event) entry.listener.event(entry, event);\r\n                    for (let ii = 0; ii < listeners.length; ii++)\r\n                        if (listeners[ii].event) listeners[ii].event(entry, event);\r\n                    break;\r\n            }\r\n        }\r\n        this.clear();\r\n\r\n        this.drainDisabled = false;\r\n    }\r\n\r\n    clear () {\r\n        this.objects.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum EventType {\r\n    start, interrupt, end, dispose, complete, event\r\n}\r\n\r\n/** The interface to implement for receiving TrackEntry events. It is always safe to call AnimationState methods when receiving\r\n * events.\r\n *\r\n * See TrackEntry {@link TrackEntry#listener} and AnimationState\r\n * {@link AnimationState#addListener()}.\r\n * @public\r\n * */\r\nexport interface AnimationStateListener {\r\n    /** Invoked when this entry has been set as the current entry. */\r\n    start (entry: TrackEntry): void;\r\n\r\n    /** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\r\n     * mixing. */\r\n    interrupt (entry: TrackEntry): void;\r\n\r\n    /** Invoked when this entry is no longer the current entry and will never be applied again. */\r\n    end (entry: TrackEntry): void;\r\n\r\n    /** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\r\n     * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\r\n    dispose (entry: TrackEntry): void;\r\n\r\n    /** Invoked every time this entry's animation completes a loop. */\r\n    complete (entry: TrackEntry): void;\r\n\r\n    /** Invoked when this entry's animation triggers an event. */\r\n    event (entry: TrackEntry, event: Event): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class AnimationStateAdapter implements AnimationStateListener {\r\n    start (entry: TrackEntry) {\r\n    }\r\n\r\n    interrupt (entry: TrackEntry) {\r\n    }\r\n\r\n    end (entry: TrackEntry) {\r\n    }\r\n\r\n    dispose (entry: TrackEntry) {\r\n    }\r\n\r\n    complete (entry: TrackEntry) {\r\n    }\r\n\r\n    event (entry: TrackEntry, event: Event) {\r\n    }\r\n}\r\n\r\n/** 1. A previously applied timeline has set this property.\r\n *\r\n * Result: Mix from the current pose to the timeline pose. */\r\nconst SUBSEQUENT = 0;\r\n/** 1. This is the first timeline to set this property.\r\n * 2. The next track entry applied after this one does not have a timeline to set this property.\r\n *\r\n * Result: Mix from the setup pose to the timeline pose. */\r\nconst FIRST = 1;\r\n/** 1) A previously applied timeline has set this property.<br>\r\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\r\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\r\n * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading\r\n * animations that key the same property. A subsequent timeline will set this property using a mix. */\r\nconst HOLD_SUBSEQUENT = 2;\r\n/** 1) This is the first timeline to set this property.<br>\r\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\r\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\r\n * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading animations\r\n * that key the same property. A subsequent timeline will set this property using a mix. */\r\nconst HOLD_FIRST = 3;\r\n/** 1. This is the first timeline to set this property.\r\n * 2. The next track entry to be applied does have a timeline to set this property.\r\n * 3. The next track entry after that one does have a timeline to set this property.\r\n * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.\r\n *\r\n * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than\r\n * 2 track entries in a row have a timeline that sets the same property.\r\n *\r\n * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid\r\n * \"dipping\" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A\r\n * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into\r\n * place. */\r\nconst HOLD_MIX = 4;\r\n\r\nconst SETUP = 1;\r\nconst CURRENT = 2;\r\n\r\nlet _emptyAnimation: Animation = null;\r\n","import {SkeletonData} from \"./SkeletonData\";\r\nimport {IAnimationStateData, Map} from '@pixi-spine/base';\r\nimport type {Animation} from './Animation';\r\n\r\n/** Stores mix (crossfade) durations to be applied when {@link AnimationState} animations are changed.\r\n * @public\r\n * */\r\nexport class AnimationStateData implements IAnimationStateData {\r\n    /** The SkeletonData to look up animations when they are specified by name. */\r\n    skeletonData: SkeletonData;\r\n\r\n    animationToMixTime: Map<number> = { };\r\n\r\n    /** The mix duration to use when no mix duration has been defined between two animations. */\r\n    defaultMix = 0;\r\n\r\n    constructor (skeletonData: SkeletonData) {\r\n        if (skeletonData == null) throw new Error(\"skeletonData cannot be null.\");\r\n        this.skeletonData = skeletonData;\r\n    }\r\n\r\n    /** Sets a mix duration by animation name.\r\n     *\r\n     * See {@link #setMixWith()}. */\r\n    setMix (fromName: string, toName: string, duration: number) {\r\n        let from = this.skeletonData.findAnimation(fromName);\r\n        if (from == null) throw new Error(\"Animation not found: \" + fromName);\r\n        let to = this.skeletonData.findAnimation(toName);\r\n        if (to == null) throw new Error(\"Animation not found: \" + toName);\r\n        this.setMixWith(from, to, duration);\r\n    }\r\n\r\n    /** Sets the mix duration when changing from the specified animation to the other.\r\n     *\r\n     * See {@link TrackEntry#mixDuration}. */\r\n    setMixWith (from: Animation, to: Animation, duration: number) {\r\n        if (from == null) throw new Error(\"from cannot be null.\");\r\n        if (to == null) throw new Error(\"to cannot be null.\");\r\n        let key = from.name + \".\" + to.name;\r\n        this.animationToMixTime[key] = duration;\r\n    }\r\n\r\n    /** Returns the mix duration to use when changing from the specified animation to the other, or the {@link #defaultMix} if\r\n     * no mix duration has been set. */\r\n    getMix (from: Animation, to: Animation) {\r\n        let key = from.name + \".\" + to.name;\r\n        let value = this.animationToMixTime[key];\r\n        return value === undefined ? this.defaultMix : value;\r\n    }\r\n}\r\n","\r\nimport {AttachmentLoader, RegionAttachment, MeshAttachment, BoundingBoxAttachment,\r\n    PathAttachment, PointAttachment, ClippingAttachment} from './attachments';\r\nimport type {TextureAtlas} from \"@pixi-spine/base\";\r\nimport type {Skin} from \"./Skin\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class AtlasAttachmentLoader implements AttachmentLoader {\r\n    atlas: TextureAtlas;\r\n\r\n    constructor(atlas: TextureAtlas) {\r\n        this.atlas = atlas;\r\n    }\r\n\r\n    /** @return May be null to not load an attachment. */\r\n    // @ts-ignore\r\n    newRegionAttachment(skin: Skin, name: string, path: string): RegionAttachment {\r\n        let region = this.atlas.findRegion(path);\r\n        if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\r\n        let attachment = new RegionAttachment(name);\r\n        attachment.region = region;\r\n        return attachment;\r\n    }\r\n\r\n    /** @return May be null to not load an attachment. */\r\n    // @ts-ignore\r\n    newMeshAttachment(skin: Skin, name: string, path: string): MeshAttachment {\r\n        let region = this.atlas.findRegion(path);\r\n        if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\r\n        let attachment = new MeshAttachment(name);\r\n        attachment.region = region;\r\n        return attachment;\r\n    }\r\n\r\n    /** @return May be null to not load an attachment. */\r\n    // @ts-ignore\r\n    newBoundingBoxAttachment(skin: Skin, name: string): BoundingBoxAttachment {\r\n        return new BoundingBoxAttachment(name);\r\n    }\r\n\r\n    /** @return May be null to not load an attachment */\r\n    // @ts-ignore\r\n    newPathAttachment(skin: Skin, name: string): PathAttachment {\r\n        return new PathAttachment(name);\r\n    }\r\n\r\n    // @ts-ignore\r\n    newPointAttachment(skin: Skin, name: string): PointAttachment {\r\n        return new PointAttachment(name);\r\n    }\r\n\r\n    // @ts-ignore\r\n    newClippingAttachment(skin: Skin, name: string): ClippingAttachment {\r\n        return new ClippingAttachment(name);\r\n    }\r\n}\r\n","import {Color} from '@pixi-spine/base';\r\n\r\n/** Stores the setup pose for a {@link Bone}.\r\n * @public\r\n * */\r\nexport class BoneData {\r\n    /** The index of the bone in {@link Skeleton#getBones()}. */\r\n    index: number;\r\n\r\n    /** The name of the bone, which is unique across all bones in the skeleton. */\r\n    name: string;\r\n\r\n    /** @returns May be null. */\r\n    parent: BoneData;\r\n\r\n    /** The bone's length. */\r\n    length: number;\r\n\r\n    /** The local x translation. */\r\n    x = 0;\r\n\r\n    /** The local y translation. */\r\n    y = 0;\r\n\r\n    /** The local rotation. */\r\n    rotation = 0;\r\n\r\n    /** The local scaleX. */\r\n    scaleX = 1;\r\n\r\n    /** The local scaleY. */\r\n    scaleY = 1;\r\n\r\n    /** The local shearX. */\r\n    shearX = 0;\r\n\r\n    /** The local shearX. */\r\n    shearY = 0;\r\n\r\n    /** The transform mode for how parent world transforms affect this bone. */\r\n    transformMode = TransformMode.Normal;\r\n\r\n    /** When true, {@link Skeleton#updateWorldTransform()} only updates this bone if the {@link Skeleton#skin} contains this\r\n     * bone.\r\n     * @see Skin#bones */\r\n    skinRequired = false;\r\n\r\n    /** The color of the bone as it was in Spine. Available only when nonessential data was exported. Bones are not usually\r\n     * rendered at runtime. */\r\n    color = new Color();\r\n\r\n    constructor (index: number, name: string, parent: BoneData) {\r\n        if (index < 0) throw new Error(\"index must be >= 0.\");\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        this.index = index;\r\n        this.name = name;\r\n        this.parent = parent;\r\n    }\r\n}\r\n\r\n/** Determines how a bone inherits world transforms from parent bones.\r\n * @public\r\n * */\r\nexport enum TransformMode {\r\n    Normal, OnlyTranslation, NoRotationOrReflection, NoScale, NoScaleOrReflection\r\n}\r\n","import {Matrix} from '@pixi/math';\r\nimport {Updatable} from \"./Updatable\";\r\nimport {BoneData, TransformMode} from \"./BoneData\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {IBone, MathUtils, settings, Vector2} from \"@pixi-spine/base\";\r\n\r\n/** Stores a bone's current pose.\r\n *\r\n * A bone has a local transform which is used to compute its world transform. A bone also has an applied transform, which is a\r\n * local transform that can be applied to compute the world transform. The local transform and applied transform may differ if a\r\n * constraint or application code modifies the world transform after it was computed from the local transform.\r\n * @public\r\n * */\r\nexport class Bone implements Updatable, IBone {\r\n    //be careful! Spine b,c is c,b in pixi matrix\r\n    matrix = new Matrix();\r\n\r\n    get worldX(): number {\r\n        return this.matrix.tx;\r\n    }\r\n\r\n    get worldY(): number {\r\n        return this.matrix.ty;\r\n    }\r\n\r\n    /** The bone's setup pose data. */\r\n    data: BoneData;\r\n\r\n    /** The skeleton this bone belongs to. */\r\n    skeleton: Skeleton;\r\n\r\n    /** The parent bone, or null if this is the root bone. */\r\n    parent: Bone;\r\n\r\n    /** The immediate children of this bone. */\r\n    children = new Array<Bone>();\r\n\r\n    /** The local x translation. */\r\n    x = 0;\r\n\r\n    /** The local y translation. */\r\n    y = 0;\r\n\r\n    /** The local rotation in degrees, counter clockwise. */\r\n    rotation = 0;\r\n\r\n    /** The local scaleX. */\r\n    scaleX = 0;\r\n\r\n    /** The local scaleY. */\r\n    scaleY = 0;\r\n\r\n    /** The local shearX. */\r\n    shearX = 0;\r\n\r\n    /** The local shearY. */\r\n    shearY = 0;\r\n\r\n    /** The applied local x translation. */\r\n    ax = 0;\r\n\r\n    /** The applied local y translation. */\r\n    ay = 0;\r\n\r\n    /** The applied local rotation in degrees, counter clockwise. */\r\n    arotation = 0;\r\n\r\n    /** The applied local scaleX. */\r\n    ascaleX = 0;\r\n\r\n    /** The applied local scaleY. */\r\n    ascaleY = 0;\r\n\r\n    /** The applied local shearX. */\r\n    ashearX = 0;\r\n\r\n    /** The applied local shearY. */\r\n    ashearY = 0;\r\n\r\n    sorted = false;\r\n    active = false;\r\n\r\n    /** @param parent May be null. */\r\n    constructor (data: BoneData, skeleton: Skeleton, parent: Bone) {\r\n        if (!data) throw new Error(\"data cannot be null.\");\r\n        if (!skeleton) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.skeleton = skeleton;\r\n        this.parent = parent;\r\n        this.setToSetupPose();\r\n    }\r\n\r\n    /** Returns false when the bone has not been computed because {@link BoneData#skinRequired} is true and the\r\n     * {@link Skeleton#skin active skin} does not {@link Skin#bones contain} this bone. */\r\n    isActive () {\r\n        return this.active;\r\n    }\r\n\r\n    /** Computes the world transform using the parent bone and this bone's local applied transform. */\r\n    update () {\r\n        this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);\r\n    }\r\n\r\n    /** Computes the world transform using the parent bone and this bone's local transform.\r\n     *\r\n     * See {@link #updateWorldTransformWith()}. */\r\n    updateWorldTransform () {\r\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n    }\r\n\r\n    /** Computes the world transform using the parent bone and the specified local transform. The applied transform is set to the\r\n     * specified local transform. Child bones are not updated.\r\n     *\r\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\r\n     * Runtimes Guide. */\r\n    updateWorldTransformWith (x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\r\n        this.ax = x;\r\n        this.ay = y;\r\n        this.arotation = rotation;\r\n        this.ascaleX = scaleX;\r\n        this.ascaleY = scaleY;\r\n        this.ashearX = shearX;\r\n        this.ashearY = shearY;\r\n\r\n        let parent = this.parent;\r\n        let m = this.matrix;\r\n\r\n        let sx = this.skeleton.scaleX;\r\n        let sy = settings.yDown? -this.skeleton.scaleY : this.skeleton.scaleY;\r\n        if (!parent) { // Root bone.\r\n            let skeleton = this.skeleton;\r\n            let rotationY = rotation + 90 + shearY;\r\n            m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\r\n            m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\r\n            m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\r\n            m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\r\n            m.tx = x * sx + skeleton.x;\r\n            m.ty = y * sy + skeleton.y;\r\n            return;\r\n        }\r\n\r\n        let pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\r\n        m.tx = pa * x + pb * y + parent.matrix.tx;\r\n        m.ty = pc * x + pd * y + parent.matrix.ty;\r\n\r\n        switch (this.data.transformMode) {\r\n            case TransformMode.Normal: {\r\n                let rotationY = rotation + 90 + shearY;\r\n                let la = MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n                let lb = MathUtils.cosDeg(rotationY) * scaleY;\r\n                let lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n                let ld = MathUtils.sinDeg(rotationY) * scaleY;\r\n                m.a = pa * la + pb * lc;\r\n                m.c = pa * lb + pb * ld;\r\n                m.b = pc * la + pd * lc;\r\n                m.d = pc * lb + pd * ld;\r\n                return;\r\n            }\r\n            case TransformMode.OnlyTranslation: {\r\n                let rotationY = rotation + 90 + shearY;\r\n                m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n                m.c = MathUtils.cosDeg(rotationY) * scaleY;\r\n                m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n                m.d = MathUtils.sinDeg(rotationY) * scaleY;\r\n                break;\r\n            }\r\n            case TransformMode.NoRotationOrReflection: {\r\n                let s = pa * pa + pc * pc;\r\n                let prx = 0;\r\n                if (s > 0.0001) {\r\n                    s = Math.abs(pa * pd - pb * pc) / s;\r\n                    pa /= this.skeleton.scaleX;\r\n                    pc /= this.skeleton.scaleY;\r\n                    pb = pc * s;\r\n                    pd = pa * s;\r\n                    prx = Math.atan2(pc, pa) * MathUtils.radDeg;\r\n                } else {\r\n                    pa = 0;\r\n                    pc = 0;\r\n                    prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\r\n                }\r\n                let rx = rotation + shearX - prx;\r\n                let ry = rotation + shearY - prx + 90;\r\n                let la = MathUtils.cosDeg(rx) * scaleX;\r\n                let lb = MathUtils.cosDeg(ry) * scaleY;\r\n                let lc = MathUtils.sinDeg(rx) * scaleX;\r\n                let ld = MathUtils.sinDeg(ry) * scaleY;\r\n                m.a = pa * la - pb * lc;\r\n                m.c = pa * lb - pb * ld;\r\n                m.b = pc * la + pd * lc;\r\n                m.d = pc * lb + pd * ld;\r\n                break;\r\n            }\r\n            case TransformMode.NoScale:\r\n            case TransformMode.NoScaleOrReflection: {\r\n                let cos = MathUtils.cosDeg(rotation);\r\n                let sin = MathUtils.sinDeg(rotation);\r\n                let za = (pa * cos + pb * sin) / sx;\r\n                let zc = (pc * cos + pd * sin) / sy;\r\n                let s = Math.sqrt(za * za + zc * zc);\r\n                if (s > 0.00001) s = 1 / s;\r\n                za *= s;\r\n                zc *= s;\r\n                s = Math.sqrt(za * za + zc * zc);\r\n                if (\r\n                    this.data.transformMode == TransformMode.NoScale\r\n                    && (pa * pd - pb * pc < 0) != (settings.yDown?\r\n                    (this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0) :\r\n                        (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))\r\n                ) s = -s;\r\n                let r = Math.PI / 2 + Math.atan2(zc, za);\r\n                let zb = Math.cos(r) * s;\r\n                let zd = Math.sin(r) * s;\r\n                let la = MathUtils.cosDeg(shearX) * scaleX;\r\n                let lb = MathUtils.cosDeg(90 + shearY) * scaleY;\r\n                let lc = MathUtils.sinDeg(shearX) * scaleX;\r\n                let ld = MathUtils.sinDeg(90 + shearY) * scaleY;\r\n                m.a = za * la + zb * lc;\r\n                m.c = za * lb + zb * ld;\r\n                m.b = zc * la + zd * lc;\r\n                m.d = zc * lb + zd * ld;\r\n                break;\r\n            }\r\n        }\r\n        m.a *= sx;\r\n        m.c *= sx;\r\n        m.b *= sy;\r\n        m.d *= sy;\r\n    }\r\n\r\n    /** Sets this bone's local transform to the setup pose. */\r\n    setToSetupPose () {\r\n        let data = this.data;\r\n        this.x = data.x;\r\n        this.y = data.y;\r\n        this.rotation = data.rotation;\r\n        this.scaleX = data.scaleX;\r\n        this.scaleY = data.scaleY;\r\n        this.shearX = data.shearX;\r\n        this.shearY = data.shearY;\r\n    }\r\n\r\n    /** The world rotation for the X axis, calculated using {@link #a} and {@link #c}. */\r\n    getWorldRotationX () {\r\n        return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\r\n    }\r\n\r\n    /** The world rotation for the Y axis, calculated using {@link #b} and {@link #d}. */\r\n    getWorldRotationY () {\r\n        return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\r\n    }\r\n\r\n    /** The magnitude (always positive) of the world scale X, calculated using {@link #a} and {@link #c}. */\r\n    getWorldScaleX () {\r\n        let m = this.matrix;\r\n        return Math.sqrt(m.a * m.a + m.b * m.b);\r\n    }\r\n\r\n    /** The magnitude (always positive) of the world scale Y, calculated using {@link #b} and {@link #d}. */\r\n    getWorldScaleY () {\r\n        let m = this.matrix;\r\n        return Math.sqrt(m.c * m.c + m.d * m.d);\r\n    }\r\n\r\n    /** Computes the applied transform values from the world transform.\r\n     *\r\n     * If the world transform is modified (by a constraint, {@link #rotateWorld(float)}, etc) then this method should be called so\r\n     * the applied transform matches the world transform. The applied transform may be needed by other code (eg to apply other\r\n     * constraints).\r\n     *\r\n     * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. The applied transform after\r\n     * calling this method is equivalent to the local transform used to compute the world transform, but may not be identical. */\r\n    updateAppliedTransform () {\r\n        let parent = this.parent;\r\n        let m = this.matrix;\r\n        if (!parent) {\r\n            this.ax = m.tx;\r\n            this.ay = m.ty;\r\n            this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\r\n            this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\r\n            this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\r\n            this.ashearX = 0;\r\n            this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\r\n            return;\r\n        }\r\n        let pm = parent.matrix;\r\n        let pid = 1 / (pm.a * pm.d - pm.b * pm.c);\r\n        let dx = m.tx - pm.tx, dy = m.ty - pm.ty;\r\n        this.ax = (dx * pm.d * pid - dy * pm.c * pid);\r\n        this.ay = (dy * pm.a * pid - dx * pm.b * pid);\r\n        let ia = pid * pm.d;\r\n        let id = pid * pm.a;\r\n        let ib = pid * pm.c;\r\n        let ic = pid * pm.b;\r\n        let ra = ia * m.a - ib * m.b;\r\n        let rb = ia * m.c - ib * m.d;\r\n        let rc = id * m.b - ic * m.a;\r\n        let rd = id * m.d - ic * m.c;\r\n        this.ashearX = 0;\r\n        this.ascaleX = Math.sqrt(ra * ra + rc * rc);\r\n        if (this.ascaleX > 0.0001) {\r\n            let det = ra * rd - rb * rc;\r\n            this.ascaleY = det / this.ascaleX;\r\n            this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\r\n            this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\r\n        } else {\r\n            this.ascaleX = 0;\r\n            this.ascaleY = Math.sqrt(rb * rb + rd * rd);\r\n            this.ashearY = 0;\r\n            this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\r\n        }\r\n    }\r\n\r\n    /** Transforms a point from world coordinates to the bone's local coordinates. */\r\n    worldToLocal(world: Vector2) {\r\n        let m = this.matrix;\r\n        let a = m.a, b = m.c, c = m.b, d = m.d;\r\n        let invDet = 1 / (a * d - b * c);\r\n        let x = world.x - m.tx, y = world.y - m.ty;\r\n        world.x = (x * d * invDet - y * b * invDet);\r\n        world.y = (y * a * invDet - x * c * invDet);\r\n        return world;\r\n    }\r\n\r\n    /** Transforms a point from the bone's local coordinates to world coordinates. */\r\n    localToWorld(local: Vector2) {\r\n        let m = this.matrix;\r\n        let x = local.x, y = local.y;\r\n        local.x = x * m.a + y * m.c + m.tx;\r\n        local.y = x * m.b + y * m.d + m.ty;\r\n        return local;\r\n    }\r\n\r\n    /** Transforms a world rotation to a local rotation. */\r\n    worldToLocalRotation (worldRotation: number) {\r\n        let sin = MathUtils.sinDeg(worldRotation), cos = MathUtils.cosDeg(worldRotation);\r\n        let mat = this.matrix;\r\n        return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\r\n    }\r\n\r\n    /** Transforms a local rotation to a world rotation. */\r\n    localToWorldRotation (localRotation: number) {\r\n        localRotation -= this.rotation - this.shearX;\r\n        let sin = MathUtils.sinDeg(localRotation), cos = MathUtils.cosDeg(localRotation);\r\n        let mat = this.matrix;\r\n        return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\r\n    }\r\n\r\n    /** Rotates the world transform the specified amount.\r\n     * <p>\r\n     * After changes are made to the world transform, {@link #updateAppliedTransform()} should be called and {@link #update()} will\r\n     * need to be called on any child bones, recursively. */\r\n    rotateWorld (degrees: number) {\r\n        let mat = this.matrix;\r\n        let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n        let cos = MathUtils.cosDeg(degrees), sin = MathUtils.sinDeg(degrees);\r\n        mat.a = cos * a - sin * c;\r\n        mat.c = cos * b - sin * d;\r\n        mat.b = sin * a + cos * c;\r\n        mat.d = sin * b + cos * d;\r\n    }\r\n}\r\n","/** The base class for all constraint datas.\r\n * @public\r\n * */\r\nexport abstract class ConstraintData {\r\n    constructor(public name: string, public order: number, public skinRequired: boolean) { }\r\n}\r\n","import {EventData} from \"./EventData\";\r\n\r\n/** Stores the current pose values for an {@link Event}.\r\n *\r\n * See Timeline {@link Timeline#apply()},\r\n * AnimationStateListener {@link AnimationStateListener#event()}, and\r\n * [Events](http://esotericsoftware.com/spine-events) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class Event {\r\n    data: EventData;\r\n    intValue: number;\r\n    floatValue: number;\r\n    stringValue: string;\r\n    time: number;\r\n    volume: number;\r\n    balance: number;\r\n\r\n    constructor (time: number, data: EventData) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        this.time = time;\r\n        this.data = data;\r\n    }\r\n}\r\n","/** Stores the setup pose values for an {@link Event}.\r\n *\r\n * See [Events](http://esotericsoftware.com/spine-events) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class EventData {\r\n    name: string;\r\n    intValue: number;\r\n    floatValue: number;\r\n    stringValue: string;\r\n    audioPath: string;\r\n    volume: number;\r\n    balance: number;\r\n\r\n    constructor (name: string) {\r\n        this.name = name;\r\n    }\r\n}\r\n","import {Updatable} from \"./Updatable\";\r\nimport {IkConstraintData} from \"./IkConstraintData\";\r\nimport {Bone} from \"./Bone\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {TransformMode} from \"./BoneData\";\r\nimport {MathUtils} from \"@pixi-spine/base\";\r\n\r\n/** Stores the current pose for an IK constraint. An IK constraint adjusts the rotation of 1 or 2 constrained bones so the tip of\r\n * the last bone is as close to the target bone as possible.\r\n *\r\n * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class IkConstraint implements Updatable {\r\n    /** The IK constraint's setup pose data. */\r\n    data: IkConstraintData;\r\n\r\n    /** The bones that will be modified by this IK constraint. */\r\n    bones: Array<Bone>;\r\n\r\n    /** The bone that is the IK target. */\r\n    target: Bone;\r\n\r\n    /** Controls the bend direction of the IK bones, either 1 or -1. */\r\n    bendDirection = 0;\r\n\r\n    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\r\n    compress = false;\r\n\r\n    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\r\n     * and the parent bone has local nonuniform scale, stretch is not applied. */\r\n    stretch = false;\r\n\r\n    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\r\n    mix = 1;\r\n\r\n    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\r\n    softness = 0;\r\n    active = false;\r\n\r\n    constructor (data: IkConstraintData, skeleton: Skeleton) {\r\n        if (!data) throw new Error(\"data cannot be null.\");\r\n        if (!skeleton) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.mix = data.mix;\r\n        this.softness = data.softness;\r\n        this.bendDirection = data.bendDirection;\r\n        this.compress = data.compress;\r\n        this.stretch = data.stretch;\r\n\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++)\r\n            this.bones.push(skeleton.findBone(data.bones[i].name));\r\n        this.target = skeleton.findBone(data.target.name);\r\n    }\r\n\r\n    isActive () {\r\n        return this.active;\r\n    }\r\n\r\n    update () {\r\n        if (this.mix == 0) return;\r\n        let target = this.target;\r\n        let bones = this.bones;\r\n        switch (bones.length) {\r\n            case 1:\r\n                this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\r\n                break;\r\n            case 2:\r\n                this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /** Applies 1 bone IK. The target is specified in the world coordinate system. */\r\n    apply1 (bone: Bone, targetX: number, targetY: number, compress: boolean, stretch: boolean, uniform: boolean, alpha: number) {\r\n        let p = bone.parent.matrix;\r\n\r\n        let pa = p.a, pb = p.c, pc = p.b, pd = p.d;\r\n        let rotationIK = -bone.ashearX - bone.arotation, tx = 0, ty = 0;\r\n\r\n        switch(bone.data.transformMode) {\r\n            case TransformMode.OnlyTranslation:\r\n                tx = targetX - bone.worldX;\r\n                ty = targetY - bone.worldY;\r\n                break;\r\n            case TransformMode.NoRotationOrReflection:\r\n                let s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\r\n                let sa = pa / bone.skeleton.scaleX;\r\n                let sc = pc / bone.skeleton.scaleY;\r\n                pb = -sc * s * bone.skeleton.scaleX;\r\n                pd = sa * s * bone.skeleton.scaleY;\r\n                rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\r\n            // Fall through\r\n            default:\r\n                let x = targetX - p.tx, y = targetY - p.ty;\r\n                let d = pa * pd - pb * pc;\r\n                tx = (x * pd - y * pb) / d - bone.ax;\r\n                ty = (y * pa - x * pc) / d - bone.ay;\r\n        }\r\n        rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\r\n        if (bone.ascaleX < 0) rotationIK += 180;\r\n        if (rotationIK > 180)\r\n            rotationIK -= 360;\r\n        else if (rotationIK < -180)\r\n            rotationIK += 360;\r\n        let sx = bone.ascaleX, sy = bone.ascaleY;\r\n        if (compress || stretch) {\r\n            switch (bone.data.transformMode) {\r\n                case TransformMode.NoScale:\r\n                case TransformMode.NoScaleOrReflection:\r\n                    tx = targetX - bone.worldX;\r\n                    ty = targetY - bone.worldY;\r\n            }\r\n            let b = bone.data.length * sx, dd = Math.sqrt(tx * tx + ty * ty);\r\n            if ((compress && dd < b) || (stretch && dd > b) && b > 0.0001) {\r\n                let s = (dd / b - 1) * alpha + 1;\r\n                sx *= s;\r\n                if (uniform) sy *= s;\r\n            }\r\n        }\r\n        bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX,\r\n            bone.ashearY);\r\n    }\r\n\r\n    /** Applies 2 bone IK. The target is specified in the world coordinate system.\r\n     * @param child A direct descendant of the parent bone. */\r\n    apply2 (parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, stretch: boolean, uniform: boolean, softness: number, alpha: number) {\r\n        let px = parent.ax, py = parent.ay, psx = parent.ascaleX, psy = parent.ascaleY, sx = psx, sy = psy, csx = child.ascaleX;\r\n        let pmat = parent.matrix;\r\n        let os1 = 0, os2 = 0, s2 = 0;\r\n        if (psx < 0) {\r\n            psx = -psx;\r\n            os1 = 180;\r\n            s2 = -1;\r\n        } else {\r\n            os1 = 0;\r\n            s2 = 1;\r\n        }\r\n        if (psy < 0) {\r\n            psy = -psy;\r\n            s2 = -s2;\r\n        }\r\n        if (csx < 0) {\r\n            csx = -csx;\r\n            os2 = 180;\r\n        } else\r\n            os2 = 0;\r\n        let cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = pmat.a, b = pmat.c, c = pmat.b, d = pmat.d;\r\n        let u = Math.abs(psx - psy) <= 0.0001;\r\n        if (!u || stretch) {\r\n            cy = 0;\r\n            cwx = a * cx + pmat.tx;\r\n            cwy = c * cx + pmat.ty;\r\n        } else {\r\n            cy = child.ay;\r\n            cwx = a * cx + b * cy + pmat.tx;\r\n            cwy = c * cx + d * cy + pmat.ty;\r\n        }\r\n        let pp = parent.parent.matrix;\r\n        a = pp.a;\r\n        b = pp.c;\r\n        c = pp.b;\r\n        d = pp.d;\r\n        let id = 1 / (a * d - b * c), x = cwx - pp.tx, y = cwy - pp.ty;\r\n        let dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\r\n        let l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;\r\n        if (l1 < 0.0001) {\r\n            this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\r\n            child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n            return;\r\n        }\r\n        x = targetX - pp.tx;\r\n        y = targetY - pp.ty;\r\n        let tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;\r\n        let dd = tx * tx + ty * ty;\r\n        if (softness != 0) {\r\n            softness *= psx * (csx + 1) * 0.5;\r\n            let td = Math.sqrt(dd), sd = td - l1 - l2 * psx + softness;\r\n            if (sd > 0) {\r\n                let p = Math.min(1, sd / (softness * 2)) - 1;\r\n                p = (sd - softness * (1 - p * p)) / td;\r\n                tx -= p * tx;\r\n                ty -= p * ty;\r\n                dd = tx * tx + ty * ty;\r\n            }\r\n        }\r\n        outer:\r\n            if (u) {\r\n                l2 *= psx;\r\n                let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\r\n                if (cos < -1) {\r\n                    cos = -1;\r\n                    a2 = Math.PI * bendDir;\r\n                } else if (cos > 1) {\r\n                    cos = 1;\r\n                    a2 = 0;\r\n                    if (stretch) {\r\n                        a = (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\r\n                        sx *= a;\r\n                        if (uniform) sy *= a;\r\n                    }\r\n                } else\r\n                    a2 = Math.acos(cos) * bendDir;\r\n                a = l1 + l2 * cos;\r\n                b = l2 * Math.sin(a2);\r\n                a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\r\n            } else {\r\n                a = psx * l2;\r\n                b = psy * l2;\r\n                let aa = a * a, bb = b * b, ta = Math.atan2(ty, tx);\r\n                c = bb * l1 * l1 + aa * dd - aa * bb;\r\n                let c1 = -2 * bb * l1, c2 = bb - aa;\r\n                d = c1 * c1 - 4 * c2 * c;\r\n                if (d >= 0) {\r\n                    let q = Math.sqrt(d);\r\n                    if (c1 < 0) q = -q;\r\n                    q = -(c1 + q) * 0.5;\r\n                    let r0 = q / c2, r1 = c / q;\r\n                    let r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\r\n                    if (r * r <= dd) {\r\n                        y = Math.sqrt(dd - r * r) * bendDir;\r\n                        a1 = ta - Math.atan2(y, r);\r\n                        a2 = Math.atan2(y / psy, (r - l1) / psx);\r\n                        break outer;\r\n                    }\r\n                }\r\n                let minAngle = MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;\r\n                let maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;\r\n                c = -a * l1 / (aa - bb);\r\n                if (c >= -1 && c <= 1) {\r\n                    c = Math.acos(c);\r\n                    x = a * Math.cos(c) + l1;\r\n                    y = b * Math.sin(c);\r\n                    d = x * x + y * y;\r\n                    if (d < minDist) {\r\n                        minAngle = c;\r\n                        minDist = d;\r\n                        minX = x;\r\n                        minY = y;\r\n                    }\r\n                    if (d > maxDist) {\r\n                        maxAngle = c;\r\n                        maxDist = d;\r\n                        maxX = x;\r\n                        maxY = y;\r\n                    }\r\n                }\r\n                if (dd <= (minDist + maxDist) * 0.5) {\r\n                    a1 = ta - Math.atan2(minY * bendDir, minX);\r\n                    a2 = minAngle * bendDir;\r\n                } else {\r\n                    a1 = ta - Math.atan2(maxY * bendDir, maxX);\r\n                    a2 = maxAngle * bendDir;\r\n                }\r\n            }\r\n        let os = Math.atan2(cy, cx) * s2;\r\n        let rotation = parent.arotation;\r\n        a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\r\n        if (a1 > 180)\r\n            a1 -= 360;\r\n        else if (a1 < -180) //\r\n            a1 += 360;\r\n        parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, sy, 0, 0);\r\n        rotation = child.arotation;\r\n        a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\r\n        if (a2 > 180)\r\n            a2 -= 360;\r\n        else if (a2 < -180) //\r\n            a2 += 360;\r\n        child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n    }\r\n}\r\n","import {ConstraintData} from \"./ConstraintData\";\r\nimport {BoneData} from \"./BoneData\";\r\n\r\n/** Stores the setup pose for an {@link IkConstraint}.\r\n * <p>\r\n * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class IkConstraintData extends ConstraintData {\r\n    /** The bones that are constrained by this IK constraint. */\r\n    bones = new Array<BoneData>();\r\n\r\n    /** The bone that is the IK target. */\r\n    target: BoneData;\r\n\r\n    /** Controls the bend direction of the IK bones, either 1 or -1. */\r\n    bendDirection = 1;\r\n\r\n    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\r\n    compress = false;\r\n\r\n    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\r\n     * and the parent bone has local nonuniform scale, stretch is not applied. */\r\n    stretch = false;\r\n\r\n    /** When true, only a single bone is being constrained, and {@link #getCompress()} or {@link #getStretch()} is used, the bone\r\n     * is scaled on both the X and Y axes. */\r\n    uniform = false;\r\n\r\n    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\r\n    mix = 1;\r\n\r\n    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\r\n    softness = 0;\r\n\r\n    constructor (name: string) {\r\n        super(name, 0, false);\r\n    }\r\n}\r\n","import {ConstraintData} from \"./ConstraintData\";\r\nimport type {SlotData} from \"./SlotData\";\r\nimport type {BoneData} from \"./BoneData\";\r\n\r\n/** Stores the setup pose for a {@link PathConstraint}.\r\n *\r\n * See [Path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class PathConstraintData extends ConstraintData {\r\n\r\n    /** The bones that will be modified by this path constraint. */\r\n    bones = new Array<BoneData>();\r\n\r\n    /** The slot whose path attachment will be used to constrained the bones. */\r\n    target: SlotData;\r\n\r\n    /** The mode for positioning the first bone on the path. */\r\n    positionMode: PositionMode;\r\n\r\n    /** The mode for positioning the bones after the first bone on the path. */\r\n    spacingMode: SpacingMode;\r\n\r\n    /** The mode for adjusting the rotation of the bones. */\r\n    rotateMode: RotateMode;\r\n\r\n    /** An offset added to the constrained bone rotation. */\r\n    offsetRotation: number;\r\n\r\n    /** The position along the path. */\r\n    position: number;\r\n\r\n    /** The spacing between bones. */\r\n    spacing: number;\r\n\r\n    mixRotate = 0;\r\n    mixX = 0;\r\n    mixY = 0;\r\n\r\n    constructor (name: string) {\r\n        super(name, 0, false);\r\n    }\r\n}\r\n\r\n/** Controls how the first bone is positioned along the path.\r\n *\r\n * See [Position mode](http://esotericsoftware.com/spine-path-constraints#Position-mode) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport enum PositionMode {\r\n    Fixed, Percent\r\n}\r\n\r\n/** Controls how bones after the first bone are positioned along the path.\r\n *\r\n * [Spacing mode](http://esotericsoftware.com/spine-path-constraints#Spacing-mode) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport enum SpacingMode {\r\n    Length, Fixed, Percent, Proportional\r\n}\r\n\r\n/** Controls how bones are rotated, translated, and scaled to match the path.\r\n *\r\n * [Rotate mode](http://esotericsoftware.com/spine-path-constraints#Rotate-mod) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport enum RotateMode {\r\n    Tangent, Chain, ChainScale\r\n}\r\n","import {PathAttachment} from \"./attachments\";\r\nimport {Updatable} from \"./Updatable\";\r\nimport {PathConstraintData, PositionMode, RotateMode, SpacingMode} from \"./PathConstraintData\";\r\nimport {Bone} from \"./Bone\";\r\nimport {Slot} from \"./Slot\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {MathUtils, Utils} from \"@pixi-spine/base\";\r\n/** Stores the current pose for a path constraint. A path constraint adjusts the rotation, translation, and scale of the\r\n * constrained bones so they follow a {@link PathAttachment}.\r\n *\r\n * See [Path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class PathConstraint implements Updatable {\r\n    static NONE = -1; static BEFORE = -2; static AFTER = -3;\r\n    static epsilon = 0.00001;\r\n\r\n    /** The path constraint's setup pose data. */\r\n    data: PathConstraintData;\r\n\r\n    /** The bones that will be modified by this path constraint. */\r\n    bones: Array<Bone>;\r\n\r\n    /** The slot whose path attachment will be used to constrained the bones. */\r\n    target: Slot;\r\n\r\n    /** The position along the path. */\r\n    position = 0;\r\n\r\n    /** The spacing between bones. */\r\n    spacing = 0;\r\n\r\n    mixRotate = 0;\r\n\r\n    mixX = 0;\r\n\r\n    mixY = 0;\r\n\r\n    spaces = new Array<number>(); positions = new Array<number>();\r\n    world = new Array<number>(); curves = new Array<number>(); lengths = new Array<number>();\r\n    segments = new Array<number>();\r\n\r\n    active = false;\r\n\r\n    constructor (data: PathConstraintData, skeleton: Skeleton) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0, n = data.bones.length; i < n; i++)\r\n            this.bones.push(skeleton.findBone(data.bones[i].name));\r\n        this.target = skeleton.findSlot(data.target.name);\r\n        this.position = data.position;\r\n        this.spacing = data.spacing;\r\n        this.mixRotate = data.mixRotate;\r\n        this.mixX = data.mixX;\r\n        this.mixY = data.mixY;\r\n    }\r\n\r\n    isActive () {\r\n        return this.active;\r\n    }\r\n\r\n    update () {\r\n        let attachment = this.target.getAttachment();\r\n        if (!(attachment instanceof PathAttachment)) return;\r\n\r\n        let mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY;\r\n        if (mixRotate == 0 && mixX == 0 && mixY == 0) return;\r\n\r\n        let data = this.data;\r\n        let tangents = data.rotateMode == RotateMode.Tangent, scale = data.rotateMode == RotateMode.ChainScale;\r\n\r\n        let boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\r\n        let bones = this.bones;\r\n        let spaces = Utils.setArraySize(this.spaces, spacesCount), lengths: Array<number> = scale ? this.lengths = Utils.setArraySize(this.lengths, boneCount) : null;\r\n        let spacing = this.spacing;\r\n\r\n        switch (data.spacingMode) {\r\n            case SpacingMode.Percent:\r\n                if (scale) {\r\n                    for (let i = 0, n = spacesCount - 1; i < n; i++) {\r\n                        let bone = bones[i];\r\n                        let setupLength = bone.data.length;\r\n                        if (setupLength < PathConstraint.epsilon)\r\n                            lengths[i] = 0;\r\n                        else {\r\n                            let x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;\r\n                            lengths[i] = Math.sqrt(x * x + y * y);\r\n                        }\r\n                    }\r\n                }\r\n                Utils.arrayFill(spaces, 1, spacesCount, spacing);\r\n                break;\r\n            case SpacingMode.Proportional:\r\n                let sum = 0;\r\n                for (let i = 0, n = spacesCount - 1; i < n;) {\r\n                    let bone = bones[i];\r\n                    let setupLength = bone.data.length;\r\n                    if (setupLength < PathConstraint.epsilon) {\r\n                        if (scale) lengths[i] = 0;\r\n                        spaces[++i] = spacing;\r\n                    } else {\r\n                        let x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;\r\n                        let length = Math.sqrt(x * x + y * y);\r\n                        if (scale) lengths[i] = length;\r\n                        spaces[++i] = length;\r\n                        sum += length;\r\n                    }\r\n                }\r\n                if (sum > 0) {\r\n                    sum = spacesCount / sum * spacing;\r\n                    for (let i = 1; i < spacesCount; i++)\r\n                        spaces[i] *= sum;\r\n                }\r\n                break;\r\n            default:\r\n                let lengthSpacing = data.spacingMode == SpacingMode.Length;\r\n                for (let i = 0, n = spacesCount - 1; i < n;) {\r\n                    let bone = bones[i];\r\n                    let setupLength = bone.data.length;\r\n                    if (setupLength < PathConstraint.epsilon) {\r\n                        if (scale) lengths[i] = 0;\r\n                        spaces[++i] = spacing;\r\n                    } else {\r\n                        let x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;\r\n                        let length = Math.sqrt(x * x + y * y);\r\n                        if (scale) lengths[i] = length;\r\n                        spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;\r\n                    }\r\n                }\r\n        }\r\n\r\n        let positions = this.computeWorldPositions(<PathAttachment>attachment, spacesCount, tangents);\r\n        let boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\r\n        let tip = false;\r\n        if (offsetRotation == 0)\r\n            tip = data.rotateMode == RotateMode.Chain;\r\n        else {\r\n            tip = false;\r\n            let p = this.target.bone.matrix;\r\n            offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n        }\r\n        for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\r\n            let bone = bones[i];\r\n            let mat = bone.matrix;\r\n            mat.tx += (boneX - mat.tx) * mixX;\r\n            mat.ty += (boneY - mat.ty) * mixY;\r\n            let x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\r\n            if (scale) {\r\n                let length = lengths[i];\r\n                if (length != 0) {\r\n                    let s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * mixRotate + 1;\r\n                    mat.a *= s;\r\n                    mat.b *= s;\r\n                }\r\n            }\r\n            boneX = x;\r\n            boneY = y;\r\n            if (mixRotate > 0) {\r\n                let a = mat.a, b = mat.c, c = mat.b, d = mat.d, r = 0, cos = 0, sin = 0;\r\n                if (tangents)\r\n                    r = positions[p - 1];\r\n                else if (spaces[i + 1] == 0)\r\n                    r = positions[p + 2];\r\n                else\r\n                    r = Math.atan2(dy, dx);\r\n                r -= Math.atan2(c, a);\r\n                if (tip) {\r\n                    cos = Math.cos(r);\r\n                    sin = Math.sin(r);\r\n                    let length = bone.data.length;\r\n                    boneX += (length * (cos * a - sin * c) - dx) * mixRotate;\r\n                    boneY += (length * (sin * a + cos * c) - dy) * mixRotate;\r\n                } else {\r\n                    r += offsetRotation;\r\n                }\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI) //\r\n                    r += MathUtils.PI2;\r\n                r *= mixRotate;\r\n                cos = Math.cos(r);\r\n                sin = Math.sin(r);\r\n                mat.a = cos * a - sin * c;\r\n                mat.c = cos * b - sin * d;\r\n                mat.b = sin * a + cos * c;\r\n                mat.d = sin * b + cos * d;\r\n            }\r\n            bone.updateAppliedTransform();\r\n        }\r\n    }\r\n\r\n    computeWorldPositions (path: PathAttachment, spacesCount: number, tangents: boolean) {\r\n        let target = this.target;\r\n        let position = this.position;\r\n        let spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world: Array<number> = null;\r\n        let closed = path.closed;\r\n        let verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\r\n\r\n        if (!path.constantSpeed) {\r\n            let lengths = path.lengths;\r\n            curveCount -= closed ? 1 : 2;\r\n            let pathLength = lengths[curveCount];\r\n            if (this.data.positionMode == PositionMode.Percent) position *= pathLength;\r\n\r\n            let multiplier;\r\n            switch (this.data.spacingMode) {\r\n                case SpacingMode.Percent:\r\n                    multiplier = pathLength;\r\n                    break;\r\n                case SpacingMode.Proportional:\r\n                    multiplier = pathLength / spacesCount;\r\n                    break;\r\n                default:\r\n                    multiplier = 1;\r\n            }\r\n            world = Utils.setArraySize(this.world, 8);\r\n            for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\r\n                let space = spaces[i] * multiplier;\r\n                position += space;\r\n                let p = position;\r\n\r\n                if (closed) {\r\n                    p %= pathLength;\r\n                    if (p < 0) p += pathLength;\r\n                    curve = 0;\r\n                } else if (p < 0) {\r\n                    if (prevCurve != PathConstraint.BEFORE) {\r\n                        prevCurve = PathConstraint.BEFORE;\r\n                        path.computeWorldVertices(target, 2, 4, world, 0, 2);\r\n                    }\r\n                    this.addBeforePosition(p, world, 0, out, o);\r\n                    continue;\r\n                } else if (p > pathLength) {\r\n                    if (prevCurve != PathConstraint.AFTER) {\r\n                        prevCurve = PathConstraint.AFTER;\r\n                        path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\r\n                    }\r\n                    this.addAfterPosition(p - pathLength, world, 0, out, o);\r\n                    continue;\r\n                }\r\n\r\n                // Determine curve containing position.\r\n                for (;; curve++) {\r\n                    let length = lengths[curve];\r\n                    if (p > length) continue;\r\n                    if (curve == 0)\r\n                        p /= length;\r\n                    else {\r\n                        let prev = lengths[curve - 1];\r\n                        p = (p - prev) / (length - prev);\r\n                    }\r\n                    break;\r\n                }\r\n                if (curve != prevCurve) {\r\n                    prevCurve = curve;\r\n                    if (closed && curve == curveCount) {\r\n                        path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\r\n                        path.computeWorldVertices(target, 0, 4, world, 4, 2);\r\n                    } else\r\n                        path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\r\n                }\r\n                this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o,\r\n                    tangents || (i > 0 && space == 0));\r\n            }\r\n            return out;\r\n        }\r\n\r\n        // World vertices.\r\n        if (closed) {\r\n            verticesLength += 2;\r\n            world = Utils.setArraySize(this.world, verticesLength);\r\n            path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\r\n            path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\r\n            world[verticesLength - 2] = world[0];\r\n            world[verticesLength - 1] = world[1];\r\n        } else {\r\n            curveCount--;\r\n            verticesLength -= 4;\r\n            world = Utils.setArraySize(this.world, verticesLength);\r\n            path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\r\n        }\r\n\r\n        // Curve lengths.\r\n        let curves = Utils.setArraySize(this.curves, curveCount);\r\n        let pathLength = 0;\r\n        let x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\r\n        let tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\r\n        for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\r\n            cx1 = world[w];\r\n            cy1 = world[w + 1];\r\n            cx2 = world[w + 2];\r\n            cy2 = world[w + 3];\r\n            x2 = world[w + 4];\r\n            y2 = world[w + 5];\r\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\r\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\r\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\r\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\r\n            ddfx = tmpx * 2 + dddfx;\r\n            ddfy = tmpy * 2 + dddfy;\r\n            dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\r\n            dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx + dddfx;\r\n            dfy += ddfy + dddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            curves[i] = pathLength;\r\n            x1 = x2;\r\n            y1 = y2;\r\n        }\r\n\r\n        if (this.data.positionMode == PositionMode.Percent) position *= pathLength;\r\n\r\n        let multiplier = 0;\r\n        switch (this.data.spacingMode) {\r\n            case SpacingMode.Percent:\r\n                multiplier = pathLength;\r\n                break;\r\n            case SpacingMode.Proportional:\r\n                multiplier = pathLength / spacesCount;\r\n                break;\r\n            default:\r\n                multiplier = 1;\r\n        }\r\n\r\n        let segments = this.segments;\r\n        let curveLength = 0;\r\n        for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\r\n            let space = spaces[i] * multiplier;\r\n            position += space;\r\n            let p = position;\r\n\r\n            if (closed) {\r\n                p %= pathLength;\r\n                if (p < 0) p += pathLength;\r\n                curve = 0;\r\n            } else if (p < 0) {\r\n                this.addBeforePosition(p, world, 0, out, o);\r\n                continue;\r\n            } else if (p > pathLength) {\r\n                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\r\n                continue;\r\n            }\r\n\r\n            // Determine curve containing position.\r\n            for (;; curve++) {\r\n                let length = curves[curve];\r\n                if (p > length) continue;\r\n                if (curve == 0)\r\n                    p /= length;\r\n                else {\r\n                    let prev = curves[curve - 1];\r\n                    p = (p - prev) / (length - prev);\r\n                }\r\n                break;\r\n            }\r\n\r\n            // Curve segment lengths.\r\n            if (curve != prevCurve) {\r\n                prevCurve = curve;\r\n                let ii = curve * 6;\r\n                x1 = world[ii];\r\n                y1 = world[ii + 1];\r\n                cx1 = world[ii + 2];\r\n                cy1 = world[ii + 3];\r\n                cx2 = world[ii + 4];\r\n                cy2 = world[ii + 5];\r\n                x2 = world[ii + 6];\r\n                y2 = world[ii + 7];\r\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\r\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\r\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\r\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\r\n                ddfx = tmpx * 2 + dddfx;\r\n                ddfy = tmpy * 2 + dddfy;\r\n                dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\r\n                dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\r\n                curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[0] = curveLength;\r\n                for (ii = 1; ii < 8; ii++) {\r\n                    dfx += ddfx;\r\n                    dfy += ddfy;\r\n                    ddfx += dddfx;\r\n                    ddfy += dddfy;\r\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    segments[ii] = curveLength;\r\n                }\r\n                dfx += ddfx;\r\n                dfy += ddfy;\r\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[8] = curveLength;\r\n                dfx += ddfx + dddfx;\r\n                dfy += ddfy + dddfy;\r\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[9] = curveLength;\r\n                segment = 0;\r\n            }\r\n\r\n            // Weight by segment length.\r\n            p *= curveLength;\r\n            for (;; segment++) {\r\n                let length = segments[segment];\r\n                if (p > length) continue;\r\n                if (segment == 0)\r\n                    p /= length;\r\n                else {\r\n                    let prev = segments[segment - 1];\r\n                    p = segment + (p - prev) / (length - prev);\r\n                }\r\n                break;\r\n            }\r\n            this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\r\n        }\r\n        return out;\r\n    }\r\n\r\n    addBeforePosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\r\n        let x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\r\n        out[o] = x1 + p * Math.cos(r);\r\n        out[o + 1] = y1 + p * Math.sin(r);\r\n        out[o + 2] = r;\r\n    }\r\n\r\n    addAfterPosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\r\n        let x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\r\n        out[o] = x1 + p * Math.cos(r);\r\n        out[o + 1] = y1 + p * Math.sin(r);\r\n        out[o + 2] = r;\r\n    }\r\n\r\n    addCurvePosition (p: number, x1: number, y1: number, cx1: number, cy1: number, cx2: number, cy2: number, x2: number, y2: number,\r\n                      out: Array<number>, o: number, tangents: boolean) {\r\n        if (p == 0 || isNaN(p)) {\r\n            out[o] = x1;\r\n            out[o + 1] = y1;\r\n            out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\r\n            return;\r\n        }\r\n        let tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\r\n        let ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\r\n        let x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\r\n        out[o] = x;\r\n        out[o + 1] = y;\r\n        if (tangents) {\r\n            if (p < 0.001)\r\n                out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\r\n            else\r\n                out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\r\n        }\r\n    }\r\n}\r\n","import {Color, ISlot} from '@pixi-spine/base';\r\n\r\nimport type {Attachment} from './attachments/Attachment';\r\nimport type {Bone} from './Bone';\r\nimport type {SlotData} from './SlotData';\r\nimport type {Skeleton} from './Skeleton';\r\n\r\n/** Stores a slot's current pose. Slots organize attachments for {@link Skeleton#drawOrder} purposes and provide a place to store\r\n * state for an attachment. State cannot be stored in an attachment itself because attachments are stateless and may be shared\r\n * across multiple skeletons.\r\n * @public\r\n * */\r\nexport class Slot implements ISlot {\r\n    //this is canon\r\n    blendMode: number;\r\n    /** The slot's setup pose data. */\r\n    data: SlotData;\r\n\r\n    /** The bone this slot belongs to. */\r\n    bone: Bone;\r\n\r\n    /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\r\n     * color tinting. */\r\n    color: Color;\r\n\r\n    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\r\n     * color's alpha is not used. */\r\n    darkColor: Color;\r\n\r\n    attachment: Attachment;\r\n\r\n    private attachmentTime: number;\r\n\r\n    attachmentState: number;\r\n\r\n    /** Values to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a\r\n     * weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.\r\n     *\r\n     * See {@link VertexAttachment#computeWorldVertices()} and {@link DeformTimeline}. */\r\n    deform = new Array<number>();\r\n\r\n    constructor (data: SlotData, bone: Bone) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        if (bone == null) throw new Error(\"bone cannot be null.\");\r\n        this.data = data;\r\n        this.bone = bone;\r\n        this.color = new Color();\r\n        this.darkColor = data.darkColor == null ? null : new Color();\r\n        this.setToSetupPose();\r\n\r\n        this.blendMode = this.data.blendMode;\r\n    }\r\n\r\n    /** The skeleton this slot belongs to. */\r\n    getSkeleton (): Skeleton {\r\n        return this.bone.skeleton;\r\n    }\r\n\r\n    /** The current attachment for the slot, or null if the slot has no attachment. */\r\n    getAttachment (): Attachment {\r\n        return this.attachment;\r\n    }\r\n\r\n    /** Sets the slot's attachment and, if the attachment changed, resets {@link #attachmentTime} and clears {@link #deform}.\r\n     * @param attachment May be null. */\r\n    setAttachment (attachment: Attachment) {\r\n        if (this.attachment == attachment) return;\r\n        this.attachment = attachment;\r\n        this.attachmentTime = this.bone.skeleton.time;\r\n        this.deform.length = 0;\r\n    }\r\n\r\n    setAttachmentTime (time: number) {\r\n        this.attachmentTime = this.bone.skeleton.time - time;\r\n    }\r\n\r\n    /** The time that has elapsed since the last time the attachment was set or cleared. Relies on Skeleton\r\n     * {@link Skeleton#time}. */\r\n    getAttachmentTime (): number {\r\n        return this.bone.skeleton.time - this.attachmentTime;\r\n    }\r\n\r\n    /** Sets this slot to the setup pose. */\r\n    setToSetupPose () {\r\n        this.color.setFromColor(this.data.color);\r\n        if (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);\r\n        if (this.data.attachmentName == null)\r\n            this.attachment = null;\r\n        else {\r\n            this.attachment = null;\r\n            this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\r\n        }\r\n    }\r\n}\r\n","import {Updatable} from \"./Updatable\";\nimport {TransformConstraintData} from \"./TransformConstraintData\";\nimport {Bone} from \"./Bone\";\nimport {MathUtils, Vector2} from \"@pixi-spine/base\";\nimport {Skeleton} from \"./Skeleton\";\n\n/** Stores the current pose for a transform constraint. A transform constraint adjusts the world transform of the constrained\n * bones to match that of the target bone.\n *\n * See [Transform constraints](http://esotericsoftware.com/spine-transform-constraints) in the Spine User Guide.\n * @public\n * */\nexport class TransformConstraint implements Updatable {\n\n    /** The transform constraint's setup pose data. */\n    data: TransformConstraintData;\n\n    /** The bones that will be modified by this transform constraint. */\n    bones: Array<Bone>;\n\n    /** The target bone whose world transform will be copied to the constrained bones. */\n    target: Bone;\n\n    mixRotate = 0; mixX = 0; mixY = 0; mixScaleX = 0; mixScaleY = 0; mixShearY = 0;\n\n    temp = new Vector2();\n    active = false;\n\n    constructor (data: TransformConstraintData, skeleton: Skeleton) {\n        if (!data) throw new Error(\"data cannot be null.\");\n        if (!skeleton) throw new Error(\"skeleton cannot be null.\");\n        this.data = data;\n        this.mixRotate = data.mixRotate;\n        this.mixX = data.mixX;\n        this.mixY = data.mixY;\n        this.mixScaleX = data.mixScaleX;\n        this.mixScaleY = data.mixScaleY;\n        this.mixShearY = data.mixShearY;\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++)\n            this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findBone(data.target.name);\n    }\n\n    isActive () {\n        return this.active;\n    }\n\n    update () {\n        if (this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleX == 0 && this.mixShearY == 0) return;\n\n        if (this.data.local) {\n            if (this.data.relative)\n                this.applyRelativeLocal();\n            else\n                this.applyAbsoluteLocal();\n        } else {\n            if (this.data.relative)\n                this.applyRelativeWorld();\n            else\n                this.applyAbsoluteWorld();\n        }\n    }\n\n    applyAbsoluteWorld () {\n        let mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX,\n            mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;\n        let translate = mixX != 0 || mixY != 0;\n\n        let target = this.target;\n        const targetMat = target.matrix;\n        let ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;\n        let degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        let offsetRotation = this.data.offsetRotation * degRadReflect;\n        let offsetShearY = this.data.offsetShearY * degRadReflect;\n\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n            const mat = bone.matrix;\n\n            if (mixRotate != 0) {\n                let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\n                let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n                if (r > MathUtils.PI)\n                    r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) //\n                    r += MathUtils.PI2;\n                r *= mixRotate;\n                let cos = Math.cos(r), sin = Math.sin(r);\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n            }\n\n            if (translate) {\n                let temp = this.temp;\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                mat.tx += (temp.x - mat.tx) * mixX;\n                mat.ty += (temp.y - mat.ty) * mixY;\n            }\n\n            if (mixScaleX != 0) {\n                let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\n                if (s != 0) s = (s + (Math.sqrt(ta * ta + tc * tc) - s + this.data.offsetScaleX) * mixScaleX) / s;\n                mat.a *= s;\n                mat.b *= s;\n            }\n            if (mixScaleY != 0) {\n                let s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\n                if (s != 0) s = (s + (Math.sqrt(tb * tb + td * td) - s + this.data.offsetScaleY) * mixScaleY) / s;\n                mat.c *= s;\n                mat.d *= s;\n\n            }\n\n            if (mixShearY > 0) {\n                let b = mat.c, d = mat.d;\n                let by = Math.atan2(d, b);\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\n                if (r > MathUtils.PI)\n                    r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) //\n                    r += MathUtils.PI2;\n                r = by + (r + offsetShearY) * mixShearY;\n                let s = Math.sqrt(b * b + d * d);\n                mat.c = Math.cos(r) * s;\n                mat.d = Math.sin(r) * s;\n\n            }\n\n            bone.updateAppliedTransform();\n        }\n    }\n\n    applyRelativeWorld () {\n        let mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX,\n            mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;\n        let translate = mixX != 0 || mixY != 0;\n\n        let target = this.target;\n        let targetMat = target.matrix;\n        let ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;\n        let degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        let offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;\n\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n            const mat = bone.matrix;\n\n            if (mixRotate != 0) {\n                let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\n                let r = Math.atan2(tc, ta) + offsetRotation;\n                if (r > MathUtils.PI)\n                    r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) //\n                    r += MathUtils.PI2;\n                r *= mixRotate;\n                let cos = Math.cos(r), sin = Math.sin(r);\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n            }\n\n            if (translate) {\n                let temp = this.temp;\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                mat.tx += temp.x * mixX;\n                mat.ty += temp.y * mixY;\n            }\n\n            if (mixScaleX != 0) {\n                let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * mixScaleX + 1;\n                mat.a *= s;\n                mat.b *= s;\n            }\n            if (mixScaleY != 0) {\n                let s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * mixScaleY + 1;\n                mat.c *= s;\n                mat.d *= s;\n            }\n\n            if (mixShearY > 0) {\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n                if (r > MathUtils.PI)\n                    r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) //\n                    r += MathUtils.PI2;\n                let b = mat.c, d = mat.d;\n                r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * mixShearY;\n                let s = Math.sqrt(b * b + d * d);\n                mat.c = Math.cos(r) * s;\n                mat.d = Math.sin(r) * s;\n            }\n\n            bone.updateAppliedTransform();\n        }\n    }\n\n    applyAbsoluteLocal () {\n        let mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX,\n            mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;\n\n        let target = this.target;\n\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n\n            let rotation = bone.arotation;\n            if (mixRotate != 0) {\n                let r = target.arotation - rotation + this.data.offsetRotation;\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                rotation += r * mixRotate;\n            }\n\n            let x = bone.ax, y = bone.ay;\n            x += (target.ax - x + this.data.offsetX) * mixX;\n            y += (target.ay - y + this.data.offsetY) * mixY;\n\n            let scaleX = bone.ascaleX, scaleY = bone.ascaleY;\n            if (mixScaleX != 0 && scaleX != 0)\n                scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * mixScaleX) / scaleX;\n            if (mixScaleY != 0 && scaleY != 0)\n                scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * mixScaleY) / scaleY;\n\n            let shearY = bone.ashearY;\n            if (mixShearY != 0) {\n                let r = target.ashearY - shearY + this.data.offsetShearY;\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                shearY += r * mixShearY;\n            }\n\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n        }\n    }\n\n    applyRelativeLocal () {\n        let mixRotate = this.mixRotate, mixX = this.mixX, mixY = this.mixY, mixScaleX = this.mixScaleX,\n            mixScaleY = this.mixScaleY, mixShearY = this.mixShearY;\n\n        let target = this.target;\n\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n\n            let rotation = bone.arotation + (target.arotation + this.data.offsetRotation) * mixRotate;\n            let x = bone.ax + (target.ax + this.data.offsetX) * mixX;\n            let y = bone.ay + (target.ay + this.data.offsetY) * mixY;\n            let scaleX = (bone.ascaleX * ((target.ascaleX - 1 + this.data.offsetScaleX) * mixScaleX) + 1);\n            let scaleY = (bone.ascaleY * ((target.ascaleY - 1 + this.data.offsetScaleY) * mixScaleY) + 1);\n            let shearY = bone.ashearY + (target.ashearY + this.data.offsetShearY) * mixShearY;\n\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n        }\n    }\n}\n","import {Attachment, RegionAttachment, MeshAttachment, PathAttachment} from './attachments';\nimport {Bone} from \"./Bone\";\nimport {Slot} from \"./Slot\";\nimport {Updatable} from \"./Updatable\";\nimport {SkeletonData} from \"./SkeletonData\";\nimport {IkConstraint} from \"./IkConstraint\";\nimport {TransformConstraint} from \"./TransformConstraint\";\nimport {PathConstraint} from \"./PathConstraint\";\nimport {Skin} from \"./Skin\";\nimport {Color, MathUtils, settings, Utils, Vector2, ISkeleton} from \"@pixi-spine/base\";\n\n/** Stores the current pose for a skeleton.\n *\n * See [Instance objects](http://esotericsoftware.com/spine-runtime-architecture#Instance-objects) in the Spine Runtimes Guide.\n * @public\n * */\nexport class Skeleton implements ISkeleton<Bone, Slot> {\n    /** The skeleton's setup pose data. */\n    data: SkeletonData;\n\n    /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\n    bones: Array<Bone>;\n\n    /** The skeleton's slots. */\n    slots: Array<Slot>;\n\n    /** The skeleton's slots in the order they should be drawn. The returned array may be modified to change the draw order. */\n    drawOrder: Array<Slot>;\n\n    /** The skeleton's IK constraints. */\n    ikConstraints: Array<IkConstraint>;\n\n    /** The skeleton's transform constraints. */\n    transformConstraints: Array<TransformConstraint>;\n\n    /** The skeleton's path constraints. */\n    pathConstraints: Array<PathConstraint>;\n\n    /** The list of bones and constraints, sorted in the order they should be updated, as computed by {@link #updateCache()}. */\n    _updateCache = new Array<Updatable>();\n\n    /** The skeleton's current skin. May be null. */\n    skin: Skin;\n\n    /** The color to tint all the skeleton's attachments. */\n    color: Color;\n\n    /** Returns the skeleton's time. This can be used for tracking, such as with Slot {@link Slot#attachmentTime}.\n     * <p>\n     * See {@link #update()}. */\n    time = 0;\n\n    /** Scales the entire skeleton on the X axis. This affects all bones, even if the bone's transform mode disallows scale\n     * inheritance. */\n    scaleX = 1;\n\n    /** Scales the entire skeleton on the Y axis. This affects all bones, even if the bone's transform mode disallows scale\n     * inheritance. */\n    scaleY = 1;\n\n    /** Sets the skeleton X position, which is added to the root bone worldX position. */\n    x = 0;\n\n    /** Sets the skeleton Y position, which is added to the root bone worldY position. */\n    y = 0;\n\n    constructor (data: SkeletonData) {\n        if (!data) throw new Error(\"data cannot be null.\");\n        this.data = data;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) {\n            let boneData = data.bones[i];\n            let bone: Bone;\n            if (!boneData.parent)\n                bone = new Bone(boneData, this, null);\n            else {\n                let parent = this.bones[boneData.parent.index];\n                bone = new Bone(boneData, this, parent);\n                parent.children.push(bone);\n            }\n            this.bones.push(bone);\n        }\n\n        this.slots = new Array<Slot>();\n        this.drawOrder = new Array<Slot>();\n        for (let i = 0; i < data.slots.length; i++) {\n            let slotData = data.slots[i];\n            let bone = this.bones[slotData.boneData.index];\n            let slot = new Slot(slotData, bone);\n            this.slots.push(slot);\n            this.drawOrder.push(slot);\n        }\n\n        this.ikConstraints = new Array<IkConstraint>();\n        for (let i = 0; i < data.ikConstraints.length; i++) {\n            let ikConstraintData = data.ikConstraints[i];\n            this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n        }\n\n        this.transformConstraints = new Array<TransformConstraint>();\n        for (let i = 0; i < data.transformConstraints.length; i++) {\n            let transformConstraintData = data.transformConstraints[i];\n            this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n        }\n\n        this.pathConstraints = new Array<PathConstraint>();\n        for (let i = 0; i < data.pathConstraints.length; i++) {\n            let pathConstraintData = data.pathConstraints[i];\n            this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n        }\n\n        this.color = new Color(1, 1, 1, 1);\n        this.updateCache();\n    }\n\n    /** Caches information about bones and constraints. Must be called if the {@link #getSkin()} is modified or if bones,\n     * constraints, or weighted path attachments are added or removed. */\n    updateCache () {\n        let updateCache = this._updateCache;\n        updateCache.length = 0;\n\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n            bone.sorted = bone.data.skinRequired;\n            bone.active = !bone.sorted;\n        }\n\n        if (this.skin) {\n            let skinBones = this.skin.bones;\n            for (let i = 0, n = this.skin.bones.length; i < n; i++) {\n                let bone = this.bones[skinBones[i].index];\n                do {\n                    bone.sorted = false;\n                    bone.active = true;\n                    bone = bone.parent;\n                } while (bone);\n            }\n        }\n\n        // IK first, lowest hierarchy depth first.\n        let ikConstraints = this.ikConstraints;\n        let transformConstraints = this.transformConstraints;\n        let pathConstraints = this.pathConstraints;\n        let ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;\n        let constraintCount = ikCount + transformCount + pathCount;\n\n        outer:\n            for (let i = 0; i < constraintCount; i++) {\n                for (let ii = 0; ii < ikCount; ii++) {\n                    let constraint = ikConstraints[ii];\n                    if (constraint.data.order == i) {\n                        this.sortIkConstraint(constraint);\n                        continue outer;\n                    }\n                }\n                for (let ii = 0; ii < transformCount; ii++) {\n                    let constraint = transformConstraints[ii];\n                    if (constraint.data.order == i) {\n                        this.sortTransformConstraint(constraint);\n                        continue outer;\n                    }\n                }\n                for (let ii = 0; ii < pathCount; ii++) {\n                    let constraint = pathConstraints[ii];\n                    if (constraint.data.order == i) {\n                        this.sortPathConstraint(constraint);\n                        continue outer;\n                    }\n                }\n            }\n\n        for (let i = 0, n = bones.length; i < n; i++)\n            this.sortBone(bones[i]);\n    }\n\n    sortIkConstraint (constraint: IkConstraint) {\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)));\n        if (!constraint.active) return;\n\n        let target = constraint.target;\n        this.sortBone(target);\n\n        let constrained = constraint.bones;\n        let parent = constrained[0];\n        this.sortBone(parent);\n\n        if (constrained.length == 1) {\n            this._updateCache.push(constraint);\n            this.sortReset(parent.children);\n        } else {\n            let child = constrained[constrained.length - 1];\n            this.sortBone(child);\n\n            this._updateCache.push(constraint);\n\n            this.sortReset(parent.children);\n            child.sorted = true;\n        }\n    }\n\n    sortPathConstraint (constraint: PathConstraint) {\n        constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)));\n        if (!constraint.active) return;\n\n        let slot = constraint.target;\n        let slotIndex = slot.data.index;\n        let slotBone = slot.bone;\n        if (this.skin) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n        if (this.data.defaultSkin && this.data.defaultSkin != this.skin)\n            this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n        for (let i = 0, n = this.data.skins.length; i < n; i++)\n            this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n\n        let attachment = slot.getAttachment();\n        if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n\n        let constrained = constraint.bones;\n        let boneCount = constrained.length;\n        for (let i = 0; i < boneCount; i++)\n            this.sortBone(constrained[i]);\n\n        this._updateCache.push(constraint);\n\n        for (let i = 0; i < boneCount; i++)\n            this.sortReset(constrained[i].children);\n        for (let i = 0; i < boneCount; i++)\n            constrained[i].sorted = true;\n    }\n\n    sortTransformConstraint (constraint: TransformConstraint) {\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)));\n        if (!constraint.active) return;\n\n        this.sortBone(constraint.target);\n\n        let constrained = constraint.bones;\n        let boneCount = constrained.length;\n        if (constraint.data.local) {\n            for (let i = 0; i < boneCount; i++) {\n                let child = constrained[i];\n                this.sortBone(child.parent);\n                this.sortBone(child);\n            }\n        } else {\n            for (let i = 0; i < boneCount; i++) {\n                this.sortBone(constrained[i]);\n            }\n        }\n\n        this._updateCache.push(constraint);\n\n        for (let i = 0; i < boneCount; i++)\n            this.sortReset(constrained[i].children);\n        for (let i = 0; i < boneCount; i++)\n            constrained[i].sorted = true;\n    }\n\n    sortPathConstraintAttachment (skin: Skin, slotIndex: number, slotBone: Bone) {\n        let attachments = skin.attachments[slotIndex];\n        if (!attachments) return;\n        for (let key in attachments) {\n            this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n        }\n    }\n\n    sortPathConstraintAttachmentWith (attachment: Attachment, slotBone: Bone) {\n        if (!(attachment instanceof PathAttachment)) return;\n        let pathBones = (<PathAttachment>attachment).bones;\n        if (!pathBones)\n            this.sortBone(slotBone);\n        else {\n            let bones = this.bones;\n            for (let i = 0, n = pathBones.length; i < n;) {\n                let nn = pathBones[i++];\n                nn += i;\n                while (i < nn)\n                    this.sortBone(bones[pathBones[i++]]);\n            }\n        }\n    }\n\n    sortBone (bone: Bone) {\n        if (bone.sorted) return;\n        let parent = bone.parent;\n        if (parent) this.sortBone(parent);\n        bone.sorted = true;\n        this._updateCache.push(bone);\n    }\n\n    sortReset (bones: Array<Bone>) {\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n            if (!bone.active) continue;\n            if (bone.sorted) this.sortReset(bone.children);\n            bone.sorted = false;\n        }\n    }\n\n    /** Updates the world transform for each bone and applies all constraints.\n     *\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n     * Runtimes Guide. */\n    updateWorldTransform () {\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n            bone.ax = bone.x;\n            bone.ay = bone.y;\n            bone.arotation = bone.rotation;\n            bone.ascaleX = bone.scaleX;\n            bone.ascaleY = bone.scaleY;\n            bone.ashearX = bone.shearX;\n            bone.ashearY = bone.shearY;\n        }\n\n        let updateCache = this._updateCache;\n        for (let i = 0, n = updateCache.length; i < n; i++)\n            updateCache[i].update();\n    }\n\n    updateWorldTransformWith (parent: Bone) {\n        // Apply the parent bone transform to the root bone. The root bone always inherits scale, rotation and reflection.\n        let rootBone = this.getRootBone();\n        let pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\n        rootBone.matrix.tx = pa * this.x + pb * this.y + parent.worldX;\n        rootBone.matrix.ty = pc * this.x + pd * this.y + parent.worldY;\n\n        let rotationY = rootBone.rotation + 90 + rootBone.shearY;\n        let la = MathUtils.cosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\n        let lb = MathUtils.cosDeg(rotationY) * rootBone.scaleY;\n        let lc = MathUtils.sinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\n        let ld = MathUtils.sinDeg(rotationY) * rootBone.scaleY;\n\n        const sx = this.scaleX;\n        const sy = settings.yDown? -this.scaleY : this.scaleY;\n        rootBone.matrix.a = (pa * la + pb * lc) * sx;\n        rootBone.matrix.c = (pa * lb + pb * ld) * sx;\n        rootBone.matrix.b = (pc * la + pd * lc) * sy;\n        rootBone.matrix.d = (pc * lb + pd * ld) * sy;\n\n        // Update everything except root bone.\n        let updateCache = this._updateCache;\n        for (let i = 0, n = updateCache.length; i < n; i++) {\n            let updatable = updateCache[i];\n            if (updatable != rootBone) updatable.update();\n        }\n    }\n\n    /** Sets the bones, constraints, and slots to their setup pose values. */\n    setToSetupPose () {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    }\n\n    /** Sets the bones and constraints to their setup pose values. */\n    setBonesToSetupPose () {\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++)\n            bones[i].setToSetupPose();\n\n        let ikConstraints = this.ikConstraints;\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            let constraint = ikConstraints[i];\n            constraint.mix = constraint.data.mix;\n            constraint.softness = constraint.data.softness;\n            constraint.bendDirection = constraint.data.bendDirection;\n            constraint.compress = constraint.data.compress;\n            constraint.stretch = constraint.data.stretch;\n        }\n\n        let transformConstraints = this.transformConstraints;\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            let constraint = transformConstraints[i];\n            let data = constraint.data;\n            constraint.mixRotate = data.mixRotate;\n            constraint.mixX = data.mixX;\n            constraint.mixY = data.mixY;\n            constraint.mixScaleX = data.mixScaleX;\n            constraint.mixScaleY = data.mixScaleY;\n            constraint.mixShearY = data.mixShearY;\n        }\n\n        let pathConstraints = this.pathConstraints;\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            let constraint = pathConstraints[i];\n            let data = constraint.data;\n            constraint.position = data.position;\n            constraint.spacing = data.spacing;\n            constraint.mixRotate = data.mixRotate;\n            constraint.mixX = data.mixX;\n            constraint.mixY = data.mixY;\n        }\n    }\n\n    /** Sets the slots and draw order to their setup pose values. */\n    setSlotsToSetupPose () {\n        let slots = this.slots;\n        Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n        for (let i = 0, n = slots.length; i < n; i++)\n            slots[i].setToSetupPose();\n    }\n\n    /** @returns May return null. */\n    getRootBone () {\n        if (this.bones.length == 0) return null;\n        return this.bones[0];\n    }\n\n    /** @returns May be null. */\n    findBone (boneName: string) {\n        if (!boneName) throw new Error(\"boneName cannot be null.\");\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++) {\n            let bone = bones[i];\n            if (bone.data.name == boneName) return bone;\n        }\n        return null;\n    }\n\n    /** @returns -1 if the bone was not found. */\n    findBoneIndex (boneName: string) {\n        if (!boneName) throw new Error(\"boneName cannot be null.\");\n        let bones = this.bones;\n        for (let i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return i;\n        return -1;\n    }\n\n    /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\n     * repeatedly.\n     * @returns May be null. */\n    findSlot (slotName: string) {\n        if (!slotName) throw new Error(\"slotName cannot be null.\");\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++) {\n            let slot = slots[i];\n            if (slot.data.name == slotName) return slot;\n        }\n        return null;\n    }\n\n    /** @returns -1 if the bone was not found. */\n    findSlotIndex (slotName: string) {\n        if (!slotName) throw new Error(\"slotName cannot be null.\");\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return i;\n        return -1;\n    }\n\n    /** Sets a skin by name.\n     *\n     * See {@link #setSkin()}. */\n    setSkinByName (skinName: string) {\n        let skin = this.data.findSkin(skinName);\n        if (!skin) throw new Error(\"Skin not found: \" + skinName);\n        this.setSkin(skin);\n    }\n\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#defaultSkin default skin}. If the\n     * skin is changed, {@link #updateCache()} is called.\n     *\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n     * old skin, each slot's setup mode attachment is attached from the new skin.\n     *\n     * After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling\n     * {@link #setSlotsToSetupPose()}. Also, often {@link AnimationState#apply()} is called before the next time the\n     * skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.\n     * @param newSkin May be null. */\n    setSkin (newSkin: Skin) {\n        if (newSkin == this.skin) return;\n        if (newSkin) {\n            if (this.skin)\n                newSkin.attachAll(this, this.skin);\n            else {\n                let slots = this.slots;\n                for (let i = 0, n = slots.length; i < n; i++) {\n                    let slot = slots[i];\n                    let name = slot.data.attachmentName;\n                    if (name) {\n                        let attachment: Attachment = newSkin.getAttachment(i, name);\n                        if (attachment) slot.setAttachment(attachment);\n                    }\n                }\n            }\n        }\n        this.skin = newSkin;\n        this.updateCache();\n    }\n\n\n    /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment\n     * name.\n     *\n     * See {@link #getAttachment()}.\n     * @returns May be null. */\n    getAttachmentByName (slotName: string, attachmentName: string): Attachment {\n        return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n    }\n\n    /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot index and\n     * attachment name. First the skin is checked and if the attachment was not found, the default skin is checked.\n     *\n     * See [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\n     * @returns May be null. */\n    getAttachment (slotIndex: number, attachmentName: string): Attachment {\n        if (!attachmentName) throw new Error(\"attachmentName cannot be null.\");\n        if (this.skin) {\n            let attachment: Attachment = this.skin.getAttachment(slotIndex, attachmentName);\n            if (attachment) return attachment;\n        }\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n        return null;\n    }\n\n    /** A convenience method to set an attachment by finding the slot with {@link #findSlot()}, finding the attachment with\n     * {@link #getAttachment()}, then setting the slot's {@link Slot#attachment}.\n     * @param attachmentName May be null to clear the slot's attachment. */\n    setAttachment (slotName: string, attachmentName: string) {\n        if (!slotName) throw new Error(\"slotName cannot be null.\");\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++) {\n            let slot = slots[i];\n            if (slot.data.name == slotName) {\n                let attachment: Attachment = null;\n                if (attachmentName) {\n                    attachment = this.getAttachment(i, attachmentName);\n                    if (!attachment) throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\n                }\n                slot.setAttachment(attachment);\n                return;\n            }\n        }\n        throw new Error(\"Slot not found: \" + slotName);\n    }\n\n\n    /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\n     * than to call it repeatedly.\n     * @return May be null. */\n    findIkConstraint (constraintName: string) {\n        if (!constraintName) throw new Error(\"constraintName cannot be null.\");\n        let ikConstraints = this.ikConstraints;\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            let ikConstraint = ikConstraints[i];\n            if (ikConstraint.data.name == constraintName) return ikConstraint;\n        }\n        return null;\n    }\n\n    /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\n     * this method than to call it repeatedly.\n     * @return May be null. */\n    findTransformConstraint (constraintName: string) {\n        if (!constraintName) throw new Error(\"constraintName cannot be null.\");\n        let transformConstraints = this.transformConstraints;\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            let constraint = transformConstraints[i];\n            if (constraint.data.name == constraintName) return constraint;\n        }\n        return null;\n    }\n\n    /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\n     * than to call it repeatedly.\n     * @return May be null. */\n    findPathConstraint (constraintName: string) {\n        if (!constraintName) throw new Error(\"constraintName cannot be null.\");\n        let pathConstraints = this.pathConstraints;\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            let constraint = pathConstraints[i];\n            if (constraint.data.name == constraintName) return constraint;\n        }\n        return null;\n    }\n\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n     * @param offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.\n     * @param size An output value, the width and height of the AABB.\n     * @param temp Working memory to temporarily store attachments' computed world vertices. */\n    getBounds (offset: Vector2, size: Vector2, temp: Array<number> = new Array<number>(2)) {\n        if (!offset) throw new Error(\"offset cannot be null.\");\n        if (!size) throw new Error(\"size cannot be null.\");\n        let drawOrder = this.drawOrder;\n        let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\n            let slot = drawOrder[i];\n            if (!slot.bone.active) continue;\n            let verticesLength = 0;\n            let vertices: ArrayLike<number> = null;\n            let attachment = slot.getAttachment();\n            if (attachment instanceof RegionAttachment) {\n                verticesLength = 8;\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\n                (<RegionAttachment>attachment).computeWorldVertices(slot.bone, vertices, 0, 2);\n            }else if (attachment instanceof MeshAttachment) {\n                let mesh = (<MeshAttachment>attachment);\n                verticesLength = mesh.worldVerticesLength;\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\n                mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n            }\n            if (vertices) {\n                for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n                    let x = vertices[ii], y = vertices[ii + 1];\n                    minX = Math.min(minX, x);\n                    minY = Math.min(minY, y);\n                    maxX = Math.max(maxX, x);\n                    maxY = Math.max(maxY, y);\n                }\n            }\n        }\n        offset.set(minX, minY);\n        size.set(maxX - minX, maxY - minY);\n    }\n\n    /** Increments the skeleton's {@link #time}. */\n    update (delta: number) {\n        this.time += delta;\n    }\n\n    get flipX(): boolean {\n        return this.scaleX == -1;\n    }\n\n    set flipX(value: boolean) {\n        if (!Skeleton.deprecatedWarning1) {\n            Skeleton.deprecatedWarning1 = true;\n            console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\n        }\n        this.scaleX = value ? 1.0 : -1.0;\n    }\n\n    get flipY(): boolean {\n        return this.scaleY == -1;\n    }\n\n    set flipY(value: boolean) {\n        if (!Skeleton.deprecatedWarning1) {\n            Skeleton.deprecatedWarning1 = true;\n            console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\n        }\n        this.scaleY = value ? 1.0 : -1.0;\n    }\n\n    private static deprecatedWarning1: boolean = false;\n}\n","import type {Animation} from \"./Animation\";\r\nimport {BoneData} from \"./BoneData\";\r\nimport {SlotData} from \"./SlotData\";\r\nimport {Skin} from \"./Skin\";\r\nimport {IkConstraintData} from \"./IkConstraintData\";\r\nimport {EventData} from \"./EventData\";\r\nimport {TransformConstraintData} from \"./TransformConstraintData\";\r\nimport {PathConstraintData} from \"./PathConstraintData\";\r\n\r\n/** Stores the setup pose and all of the stateless data for a skeleton.\r\n *\r\n * See [Data objects](http://esotericsoftware.com/spine-runtime-architecture#Data-objects) in the Spine Runtimes\r\n * Guide.\r\n * @public\r\n * */\r\nexport class SkeletonData {\r\n\r\n    /** The skeleton's name, which by default is the name of the skeleton data file, if possible. May be null. */\r\n    name: string;\r\n\r\n    /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\r\n    bones = new Array<BoneData>(); // Ordered parents first.\r\n\r\n    /** The skeleton's slots. */\r\n    slots = new Array<SlotData>(); // Setup pose draw order.\r\n    skins = new Array<Skin>();\r\n\r\n    /** The skeleton's default skin. By default this skin contains all attachments that were not in a skin in Spine.\r\n     *\r\n     * See {@link Skeleton#getAttachmentByName()}.\r\n     * May be null. */\r\n    defaultSkin: Skin;\r\n\r\n    /** The skeleton's events. */\r\n    events = new Array<EventData>();\r\n\r\n    /** The skeleton's animations. */\r\n    animations = new Array<Animation>();\r\n\r\n    /** The skeleton's IK constraints. */\r\n    ikConstraints = new Array<IkConstraintData>();\r\n\r\n    /** The skeleton's transform constraints. */\r\n    transformConstraints = new Array<TransformConstraintData>();\r\n\r\n    /** The skeleton's path constraints. */\r\n    pathConstraints = new Array<PathConstraintData>();\r\n\r\n    /** The X coordinate of the skeleton's axis aligned bounding box in the setup pose. */\r\n    x: number;\r\n\r\n    /** The Y coordinate of the skeleton's axis aligned bounding box in the setup pose. */\r\n    y: number;\r\n\r\n    /** The width of the skeleton's axis aligned bounding box in the setup pose. */\r\n    width: number;\r\n\r\n    /** The height of the skeleton's axis aligned bounding box in the setup pose. */\r\n    height: number;\r\n\r\n    /** The Spine version used to export the skeleton data, or null. */\r\n    version: string;\r\n\r\n    /** The skeleton data hash. This value will change if any of the skeleton data has changed. May be null. */\r\n    hash: string;\r\n\r\n    // Nonessential\r\n    /** The dopesheet FPS in Spine. Available only when nonessential data was exported. */\r\n    fps = 0;\r\n\r\n    /** The path to the images directory as defined in Spine. Available only when nonessential data was exported. May be null. */\r\n    imagesPath: string;\r\n\r\n    /** The path to the audio directory as defined in Spine. Available only when nonessential data was exported. May be null. */\r\n    audioPath: string;\r\n\r\n    /** Finds a bone by comparing each bone's name. It is more efficient to cache the results of this method than to call it\r\n     * multiple times.\r\n     * @returns May be null. */\r\n    findBone (boneName: string) {\r\n        if (!boneName) throw new Error(\"boneName cannot be null.\");\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            if (bone.name == boneName) return bone;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findBoneIndex (boneName: string) {\r\n        if (!boneName) throw new Error(\"boneName cannot be null.\");\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].name == boneName) return i;\r\n        return -1;\r\n    }\r\n\r\n    /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\r\n     * multiple times.\r\n     * @returns May be null. */\r\n    findSlot (slotName: string) {\r\n        if (!slotName) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            let slot = slots[i];\r\n            if (slot.name == slotName) return slot;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findSlotIndex (slotName: string) {\r\n        if (!slotName) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].name == slotName) return i;\r\n        return -1;\r\n    }\r\n\r\n    /** Finds a skin by comparing each skin's name. It is more efficient to cache the results of this method than to call it\r\n     * multiple times.\r\n     * @returns May be null. */\r\n    findSkin (skinName: string) {\r\n        if (!skinName) throw new Error(\"skinName cannot be null.\");\r\n        let skins = this.skins;\r\n        for (let i = 0, n = skins.length; i < n; i++) {\r\n            let skin = skins[i];\r\n            if (skin.name == skinName) return skin;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** Finds an event by comparing each events's name. It is more efficient to cache the results of this method than to call it\r\n     * multiple times.\r\n     * @returns May be null. */\r\n    findEvent (eventDataName: string) {\r\n        if (!eventDataName) throw new Error(\"eventDataName cannot be null.\");\r\n        let events = this.events;\r\n        for (let i = 0, n = events.length; i < n; i++) {\r\n            let event = events[i];\r\n            if (event.name == eventDataName) return event;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** Finds an animation by comparing each animation's name. It is more efficient to cache the results of this method than to\r\n     * call it multiple times.\r\n     * @returns May be null. */\r\n    findAnimation (animationName: string) {\r\n        if (!animationName) throw new Error(\"animationName cannot be null.\");\r\n        let animations = this.animations;\r\n        for (let i = 0, n = animations.length; i < n; i++) {\r\n            let animation = animations[i];\r\n            if (animation.name == animationName) return animation;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\r\n     * than to call it multiple times.\r\n     * @return May be null. */\r\n    findIkConstraint (constraintName: string) {\r\n        if (!constraintName) throw new Error(\"constraintName cannot be null.\");\r\n        let ikConstraints = this.ikConstraints;\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            let constraint = ikConstraints[i];\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\r\n     * this method than to call it multiple times.\r\n     * @return May be null. */\r\n    findTransformConstraint (constraintName: string) {\r\n        if (!constraintName) throw new Error(\"constraintName cannot be null.\");\r\n        let transformConstraints = this.transformConstraints;\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            let constraint = transformConstraints[i];\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\r\n     * than to call it multiple times.\r\n     * @return May be null. */\r\n    findPathConstraint (constraintName: string) {\r\n        if (!constraintName) throw new Error(\"constraintName cannot be null.\");\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            let constraint = pathConstraints[i];\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findPathConstraintIndex (pathConstraintName: string) {\r\n        if (pathConstraintName == null) throw new Error(\"pathConstraintName cannot be null.\");\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++)\r\n            if (pathConstraints[i].name == pathConstraintName) return i;\r\n        return -1;\r\n    }\r\n}\r\n","import {Color} from '@pixi-spine/base';\r\n\r\nimport type {ISlotData} from '@pixi-spine/base';\r\nimport type {BLEND_MODES} from '@pixi/constants';\r\nimport {BoneData} from \"./BoneData\";\r\n\r\n/** Stores the setup pose for a {@link Slot}.\r\n * @public\r\n * */\r\nexport class SlotData implements ISlotData {\r\n\r\n    /** The index of the slot in {@link Skeleton#getSlots()}. */\r\n    index: number;\r\n\r\n    /** The name of the slot, which is unique across all slots in the skeleton. */\r\n    name: string;\r\n\r\n    /** The bone this slot belongs to. */\r\n    boneData: BoneData;\r\n\r\n    /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\r\n     * color tinting. */\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\r\n     * color's alpha is not used. */\r\n    darkColor: Color;\r\n\r\n    /** The name of the attachment that is visible for this slot in the setup pose, or null if no attachment is visible. */\r\n    attachmentName: string;\r\n\r\n    /** The blend mode for drawing the slot's attachment. */\r\n    blendMode: BLEND_MODES;\r\n\r\n    constructor (index: number, name: string, boneData: BoneData) {\r\n        if (index < 0) throw new Error(\"index must be >= 0.\");\r\n        if (!name) throw new Error(\"name cannot be null.\");\r\n        if (!boneData) throw new Error(\"boneData cannot be null.\");\r\n        this.index = index;\r\n        this.name = name;\r\n        this.boneData = boneData;\r\n    }\r\n}\r\n\r\n","import {BoneData} from './BoneData';\r\nimport {ConstraintData} from './ConstraintData';\r\n\r\n/** Stores the setup pose for a {@link TransformConstraint}.\r\n *\r\n * See [Transform constraints](http://esotericsoftware.com/spine-transform-constraints) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class TransformConstraintData extends ConstraintData {\r\n\r\n    /** The bones that will be modified by this transform constraint. */\r\n    bones = new Array<BoneData>();\r\n\r\n    /** The target bone whose world transform will be copied to the constrained bones. */\r\n    target: BoneData;\r\n\r\n    mixRotate = 0;\r\n    mixX = 0;\r\n    mixY = 0;\r\n    mixScaleX = 0;\r\n    mixScaleY = 0;\r\n    mixShearY = 0;\r\n\r\n    /** An offset added to the constrained bone rotation. */\r\n    offsetRotation = 0;\r\n\r\n    /** An offset added to the constrained bone X translation. */\r\n    offsetX = 0;\r\n\r\n    /** An offset added to the constrained bone Y translation. */\r\n    offsetY = 0;\r\n\r\n    /** An offset added to the constrained bone scaleX. */\r\n    offsetScaleX = 0;\r\n\r\n    /** An offset added to the constrained bone scaleY. */\r\n    offsetScaleY = 0;\r\n\r\n    /** An offset added to the constrained bone shearY. */\r\n    offsetShearY = 0;\r\n\r\n    relative = false;\r\n    local = false;\r\n\r\n    constructor (name: string) {\r\n        super(name, 0, false);\r\n    }\r\n}\r\n","import {Attachment, MeshAttachment} from './attachments';\r\nimport {BoneData} from \"./BoneData\";\r\nimport {ConstraintData} from \"./ConstraintData\";\r\nimport {Skeleton} from \"./Skeleton\";\r\n\r\nimport type {Map} from '@pixi-spine/base';\r\n\r\n/** Stores an entry in the skin consisting of the slot index, name, and attachment\r\n * @public\r\n * **/\r\nexport class SkinEntry {\r\n    constructor(public slotIndex: number, public name: string, public attachment: Attachment) { }\r\n}\r\n\r\n/** Stores attachments by slot index and attachment name.\r\n *\r\n * See SkeletonData {@link SkeletonData#defaultSkin}, Skeleton {@link Skeleton#skin}, and\r\n * [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\r\n * @public\r\n * */\r\nexport class Skin {\r\n    /** The skin's name, which is unique across all skins in the skeleton. */\r\n    name: string;\r\n\r\n    attachments = new Array<Map<Attachment>>();\r\n    bones = Array<BoneData>();\r\n    constraints = new Array<ConstraintData>();\r\n\r\n    constructor (name: string) {\r\n        if (!name) throw new Error(\"name cannot be null.\");\r\n        this.name = name;\r\n    }\r\n\r\n    /** Adds an attachment to the skin for the specified slot index and name. */\r\n    setAttachment (slotIndex: number, name: string, attachment: Attachment) {\r\n        if (!attachment) throw new Error(\"attachment cannot be null.\");\r\n        let attachments = this.attachments;\r\n        if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\r\n        if (!attachments[slotIndex]) attachments[slotIndex] = { };\r\n        attachments[slotIndex][name] = attachment;\r\n    }\r\n\r\n    /** Adds all attachments, bones, and constraints from the specified skin to this skin. */\r\n    addSkin (skin: Skin) {\r\n        for(let i = 0; i < skin.bones.length; i++) {\r\n            let bone = skin.bones[i];\r\n            let contained = false;\r\n            for (let ii = 0; ii < this.bones.length; ii++) {\r\n                if (this.bones[ii] == bone) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.bones.push(bone);\r\n        }\r\n\r\n        for(let i = 0; i < skin.constraints.length; i++) {\r\n            let constraint = skin.constraints[i];\r\n            let contained = false;\r\n            for (let ii = 0; ii < this.constraints.length; ii++) {\r\n                if (this.constraints[ii] == constraint) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.constraints.push(constraint);\r\n        }\r\n\r\n        let attachments = skin.getAttachments();\r\n        for (let i = 0; i < attachments.length; i++) {\r\n            var attachment = attachments[i];\r\n            this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n        }\r\n    }\r\n\r\n    /** Adds all bones and constraints and copies of all attachments from the specified skin to this skin. Mesh attachments are not\r\n     * copied, instead a new linked mesh is created. The attachment copies can be modified without affecting the originals. */\r\n    copySkin (skin: Skin) {\r\n        for(let i = 0; i < skin.bones.length; i++) {\r\n            let bone = skin.bones[i];\r\n            let contained = false;\r\n            for (let ii = 0; ii < this.bones.length; ii++) {\r\n                if (this.bones[ii] == bone) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.bones.push(bone);\r\n        }\r\n\r\n        for(let i = 0; i < skin.constraints.length; i++) {\r\n            let constraint = skin.constraints[i];\r\n            let contained = false;\r\n            for (let ii = 0; ii < this.constraints.length; ii++) {\r\n                if (this.constraints[ii] == constraint) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.constraints.push(constraint);\r\n        }\r\n\r\n        let attachments = skin.getAttachments();\r\n        for (let i = 0; i < attachments.length; i++) {\r\n            var attachment = attachments[i];\r\n            if (!attachment.attachment) continue;\r\n            if (attachment.attachment instanceof MeshAttachment) {\r\n                attachment.attachment = attachment.attachment.newLinkedMesh();\r\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n            } else {\r\n                attachment.attachment = attachment.attachment.copy();\r\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Returns the attachment for the specified slot index and name, or null. */\r\n    getAttachment (slotIndex: number, name: string): Attachment {\r\n        let dictionary = this.attachments[slotIndex];\r\n        return dictionary ? dictionary[name] : null;\r\n    }\r\n\r\n    /** Removes the attachment in the skin for the specified slot index and name, if any. */\r\n    removeAttachment (slotIndex: number, name: string) {\r\n        let dictionary = this.attachments[slotIndex];\r\n        if (dictionary) dictionary[name] = null;\r\n    }\r\n\r\n    /** Returns all attachments in this skin. */\r\n    getAttachments (): Array<SkinEntry> {\r\n        let entries = new Array<SkinEntry>();\r\n        for (var i = 0; i < this.attachments.length; i++) {\r\n            let slotAttachments = this.attachments[i];\r\n            if (slotAttachments) {\r\n                for (let name in slotAttachments) {\r\n                    let attachment = slotAttachments[name];\r\n                    if (attachment) entries.push(new SkinEntry(i, name, attachment));\r\n                }\r\n            }\r\n        }\r\n        return entries;\r\n    }\r\n\r\n    /** Returns all attachments in this skin for the specified slot index. */\r\n    getAttachmentsForSlot (slotIndex: number, attachments: Array<SkinEntry>) {\r\n        let slotAttachments = this.attachments[slotIndex];\r\n        if (slotAttachments) {\r\n            for (let name in slotAttachments) {\r\n                let attachment = slotAttachments[name];\r\n                if (attachment) attachments.push(new SkinEntry(slotIndex, name, attachment));\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Clears all attachments, bones, and constraints. */\r\n    clear () {\r\n        this.attachments.length = 0;\r\n        this.bones.length = 0;\r\n        this.constraints.length = 0;\r\n    }\r\n\r\n    /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\r\n    attachAll (skeleton: Skeleton, oldSkin: Skin) {\r\n        let slotIndex = 0;\r\n        for (let i = 0; i < skeleton.slots.length; i++) {\r\n            let slot = skeleton.slots[i];\r\n            let slotAttachment = slot.getAttachment();\r\n            if (slotAttachment && slotIndex < oldSkin.attachments.length) {\r\n                let dictionary = oldSkin.attachments[slotIndex];\r\n                for (let key in dictionary) {\r\n                    let skinAttachment:Attachment = dictionary[key];\r\n                    if (slotAttachment == skinAttachment) {\r\n                        let attachment = this.getAttachment(slotIndex, key);\r\n                        if (attachment) slot.setAttachment(attachment);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            slotIndex++;\r\n        }\r\n    }\r\n}\r\n","import type {Attachment, AttachmentLoader, MeshAttachment, VertexAttachment} from './attachments';\r\nimport {\r\n    AlphaTimeline, Animation,\r\n    AttachmentTimeline, CurveTimeline, CurveTimeline1, CurveTimeline2, DeformTimeline, DrawOrderTimeline, EventTimeline,\r\n    IkConstraintTimeline,\r\n    PathConstraintMixTimeline,\r\n    PathConstraintPositionTimeline,\r\n    PathConstraintSpacingTimeline, RGB2Timeline, RGBA2Timeline, RGBATimeline, RGBTimeline,\r\n    RotateTimeline,\r\n    ScaleTimeline, ScaleXTimeline, ScaleYTimeline,\r\n    ShearTimeline, ShearXTimeline, ShearYTimeline,\r\n    Timeline,\r\n    TransformConstraintTimeline,\r\n    TranslateTimeline, TranslateXTimeline, TranslateYTimeline\r\n} from './Animation';\r\nimport {Event} from './Event';\r\nimport {SkeletonData} from './SkeletonData';\r\nimport {SlotData} from './SlotData';\r\nimport {BoneData} from './BoneData';\r\nimport {IkConstraintData} from './IkConstraintData';\r\nimport {TransformConstraintData} from './TransformConstraintData';\r\nimport {PathConstraintData, PositionMode, SpacingMode} from './PathConstraintData';\r\nimport {Skin} from './Skin';\r\nimport {EventData} from './EventData';\r\nimport {AttachmentType, BinaryInput, Color, Utils} from '@pixi-spine/base';\r\nimport {BLEND_MODES} from '@pixi/constants';\r\n\r\n/** Loads skeleton data in the Spine binary format.\r\n *\r\n * See [Spine binary format](http://esotericsoftware.com/spine-binary-format) and\r\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\r\n * Runtimes Guide.\r\n * @public\r\n * */\r\nexport class SkeletonBinary {\r\n    static BlendModeValues = [ BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];\r\n    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\r\n     * runtime than were used in Spine.\r\n     *\r\n     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\r\n    scale = 1;\r\n\r\n    attachmentLoader: AttachmentLoader;\r\n    private linkedMeshes = new Array<LinkedMesh>();\r\n\r\n    constructor (attachmentLoader: AttachmentLoader) {\r\n        this.attachmentLoader = attachmentLoader;\r\n    }\r\n\r\n    readSkeletonData (binary: Uint8Array): SkeletonData {\r\n        let scale = this.scale;\r\n\r\n        let skeletonData = new SkeletonData();\r\n        skeletonData.name = \"\"; // BOZO\r\n\r\n        let input = new BinaryInput(binary);\r\n\r\n        let lowHash = input.readInt32();\r\n        let highHash = input.readInt32();\r\n        skeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);\r\n        skeletonData.version = input.readString();\r\n        if (skeletonData.version.substr(0, 3) !== '4.0')\r\n        {\r\n            let error = `Spine 4.0 loader cant load version ${skeletonData.version}. Please configure your pixi-spine bundle`;\r\n            console.error(error);\r\n        }\r\n        skeletonData.x = input.readFloat();\r\n        skeletonData.y = input.readFloat();\r\n        skeletonData.width = input.readFloat();\r\n        skeletonData.height = input.readFloat();\r\n\r\n        let nonessential = input.readBoolean();\r\n        if (nonessential) {\r\n            skeletonData.fps = input.readFloat();\r\n\r\n            skeletonData.imagesPath = input.readString();\r\n            skeletonData.audioPath = input.readString();\r\n        }\r\n\r\n        let n = 0;\r\n        // Strings.\r\n        n = input.readInt(true)\r\n        for (let i = 0; i < n; i++)\r\n            input.strings.push(input.readString());\r\n\r\n        // Bones.\r\n        n = input.readInt(true)\r\n        for (let i = 0; i < n; i++) {\r\n            let name = input.readString();\r\n            let parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\r\n            let data = new BoneData(i, name, parent);\r\n            data.rotation = input.readFloat();\r\n            data.x = input.readFloat() * scale;\r\n            data.y = input.readFloat() * scale;\r\n            data.scaleX = input.readFloat();\r\n            data.scaleY = input.readFloat();\r\n            data.shearX = input.readFloat();\r\n            data.shearY = input.readFloat();\r\n            data.length = input.readFloat() * scale;\r\n            data.transformMode = input.readInt(true);\r\n            data.skinRequired = input.readBoolean();\r\n            if (nonessential) Color.rgba8888ToColor(data.color, input.readInt32());\r\n            skeletonData.bones.push(data);\r\n        }\r\n\r\n        // Slots.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) {\r\n            let slotName = input.readString();\r\n            let boneData = skeletonData.bones[input.readInt(true)];\r\n            let data = new SlotData(i, slotName, boneData);\r\n            Color.rgba8888ToColor(data.color, input.readInt32());\r\n\r\n            let darkColor = input.readInt32();\r\n            if (darkColor != -1) Color.rgb888ToColor(data.darkColor = new Color(), darkColor);\r\n\r\n            data.attachmentName = input.readStringRef();\r\n            data.blendMode = SkeletonBinary.BlendModeValues[input.readInt(true)];\r\n            skeletonData.slots.push(data);\r\n        }\r\n\r\n        // IK constraints.\r\n        n = input.readInt(true);\r\n        for (let i = 0, nn; i < n; i++) {\r\n            let data = new IkConstraintData(input.readString());\r\n            data.order = input.readInt(true);\r\n            data.skinRequired = input.readBoolean();\r\n            nn = input.readInt(true);\r\n            for (let ii = 0; ii < nn; ii++)\r\n                data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n            data.target = skeletonData.bones[input.readInt(true)];\r\n            data.mix = input.readFloat();\r\n            data.softness = input.readFloat() * scale;\r\n            data.bendDirection = input.readByte();\r\n            data.compress = input.readBoolean();\r\n            data.stretch = input.readBoolean();\r\n            data.uniform = input.readBoolean();\r\n            skeletonData.ikConstraints.push(data);\r\n        }\r\n\r\n        // Transform constraints.\r\n        n = input.readInt(true);\r\n        for (let i = 0, nn; i < n; i++) {\r\n            let data = new TransformConstraintData(input.readString());\r\n            data.order = input.readInt(true);\r\n            data.skinRequired = input.readBoolean();\r\n            nn = input.readInt(true);\r\n            for (let ii = 0; ii < nn; ii++)\r\n                data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n            data.target = skeletonData.bones[input.readInt(true)];\r\n            data.local = input.readBoolean();\r\n            data.relative = input.readBoolean();\r\n            data.offsetRotation = input.readFloat();\r\n            data.offsetX = input.readFloat() * scale;\r\n            data.offsetY = input.readFloat() * scale;\r\n            data.offsetScaleX = input.readFloat();\r\n            data.offsetScaleY = input.readFloat();\r\n            data.offsetShearY = input.readFloat();\r\n            data.mixRotate = input.readFloat();\r\n            data.mixX = input.readFloat();\r\n            data.mixY = input.readFloat();\r\n            data.mixScaleX = input.readFloat();\r\n            data.mixScaleY = input.readFloat();\r\n            data.mixShearY = input.readFloat();\r\n            skeletonData.transformConstraints.push(data);\r\n        }\r\n\r\n        // Path constraints.\r\n        n = input.readInt(true);\r\n        for (let i = 0, nn; i < n; i++) {\r\n            let data = new PathConstraintData(input.readString());\r\n            data.order = input.readInt(true);\r\n            data.skinRequired = input.readBoolean();\r\n            nn = input.readInt(true);\r\n            for (let ii = 0; ii < nn; ii++)\r\n                data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n            data.target = skeletonData.slots[input.readInt(true)];\r\n            data.positionMode = input.readInt(true);\r\n            data.spacingMode = input.readInt(true);\r\n            data.rotateMode = input.readInt(true);\r\n            data.offsetRotation = input.readFloat();\r\n            data.position = input.readFloat();\r\n            if (data.positionMode == PositionMode.Fixed) data.position *= scale;\r\n            data.spacing = input.readFloat();\r\n            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\r\n            data.mixRotate = input.readFloat();\r\n            data.mixX = input.readFloat();\r\n            data.mixY = input.readFloat();\r\n            skeletonData.pathConstraints.push(data);\r\n        }\r\n\r\n        // Default skin.\r\n        let defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\r\n        if (defaultSkin) {\r\n            skeletonData.defaultSkin = defaultSkin;\r\n            skeletonData.skins.push(defaultSkin);\r\n        }\r\n\r\n        // Skins.\r\n        {\r\n            let i = skeletonData.skins.length;\r\n            Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));\r\n            for (; i < n; i++)\r\n                skeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);\r\n        }\r\n\r\n        // Linked meshes.\r\n        n = this.linkedMeshes.length;\r\n        for (let i = 0; i < n; i++) {\r\n            let linkedMesh = this.linkedMeshes[i];\r\n            let skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n            let parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n            linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent as VertexAttachment : linkedMesh.mesh;\r\n            linkedMesh.mesh.setParentMesh(parent as MeshAttachment);\r\n            // linkedMesh.mesh.updateUVs();\r\n        }\r\n        this.linkedMeshes.length = 0;\r\n\r\n        // Events.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) {\r\n            let data = new EventData(input.readStringRef());\r\n            data.intValue = input.readInt(false);\r\n            data.floatValue = input.readFloat();\r\n            data.stringValue = input.readString();\r\n            data.audioPath = input.readString();\r\n            if (data.audioPath) {\r\n                data.volume = input.readFloat();\r\n                data.balance = input.readFloat();\r\n            }\r\n            skeletonData.events.push(data);\r\n        }\r\n\r\n        // Animations.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++)\r\n            skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));\r\n        return skeletonData;\r\n    }\r\n\r\n    private readSkin (input: BinaryInput, skeletonData: SkeletonData, defaultSkin: boolean, nonessential: boolean): Skin {\r\n        let skin = null;\r\n        let slotCount = 0;\r\n\r\n        if (defaultSkin) {\r\n            slotCount = input.readInt(true)\r\n            if (slotCount == 0) return null;\r\n            skin = new Skin(\"default\");\r\n        } else {\r\n            skin = new Skin(input.readStringRef());\r\n            skin.bones.length = input.readInt(true);\r\n            for (let i = 0, n = skin.bones.length; i < n; i++)\r\n                skin.bones[i] = skeletonData.bones[input.readInt(true)];\r\n\r\n            for (let i = 0, n = input.readInt(true); i < n; i++)\r\n                skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\r\n            for (let i = 0, n = input.readInt(true); i < n; i++)\r\n                skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\r\n            for (let i = 0, n = input.readInt(true); i < n; i++)\r\n                skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\r\n\r\n            slotCount = input.readInt(true);\r\n        }\r\n\r\n        for (let i = 0; i < slotCount; i++) {\r\n            let slotIndex = input.readInt(true);\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                let name = input.readStringRef();\r\n                let attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\r\n                if (attachment) skin.setAttachment(slotIndex, name, attachment);\r\n            }\r\n        }\r\n        return skin;\r\n    }\r\n\r\n    private readAttachment(input: BinaryInput, skeletonData: SkeletonData, skin: Skin, slotIndex: number, attachmentName: string, nonessential: boolean): Attachment {\r\n        let scale = this.scale;\r\n\r\n        let name = input.readStringRef();\r\n        if (!name) name = attachmentName;\r\n\r\n        switch (input.readByte()) {\r\n            case AttachmentType.Region: {\r\n                let path = input.readStringRef();\r\n                let rotation = input.readFloat();\r\n                let x = input.readFloat();\r\n                let y = input.readFloat();\r\n                let scaleX = input.readFloat();\r\n                let scaleY = input.readFloat();\r\n                let width = input.readFloat();\r\n                let height = input.readFloat();\r\n                let color = input.readInt32();\r\n\r\n                if (!path) path = name;\r\n                let region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n                if (!region) return null;\r\n                region.path = path;\r\n                region.x = x * scale;\r\n                region.y = y * scale;\r\n                region.scaleX = scaleX;\r\n                region.scaleY = scaleY;\r\n                region.rotation = rotation;\r\n                region.width = width * scale;\r\n                region.height = height * scale;\r\n                Color.rgba8888ToColor(region.color, color);\r\n                // region.updateOffset();\r\n                return region;\r\n            }\r\n            case AttachmentType.BoundingBox: {\r\n                let vertexCount = input.readInt(true);\r\n                let vertices = this.readVertices(input, vertexCount);\r\n                let color = nonessential ? input.readInt32() : 0;\r\n\r\n                let box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n                if (!box) return null;\r\n                box.worldVerticesLength = vertexCount << 1;\r\n                box.vertices = vertices.vertices;\r\n                box.bones = vertices.bones;\r\n                if (nonessential) Color.rgba8888ToColor(box.color, color);\r\n                return box;\r\n            }\r\n            case AttachmentType.Mesh: {\r\n                let path = input.readStringRef();\r\n                let color = input.readInt32();\r\n                let vertexCount = input.readInt(true);\r\n                let uvs = this.readFloatArray(input, vertexCount << 1, 1);\r\n                let triangles = this.readShortArray(input);\r\n                let vertices = this.readVertices(input, vertexCount);\r\n                let hullLength = input.readInt(true);\r\n                let edges = null;\r\n                let width = 0, height = 0;\r\n                if (nonessential) {\r\n                    edges = this.readShortArray(input);\r\n                    width = input.readFloat();\r\n                    height = input.readFloat();\r\n                }\r\n\r\n                if (!path) path = name;\r\n                let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n                if (!mesh) return null;\r\n                mesh.path = path;\r\n                Color.rgba8888ToColor(mesh.color, color);\r\n                mesh.bones = vertices.bones;\r\n                mesh.vertices = vertices.vertices;\r\n                mesh.worldVerticesLength = vertexCount << 1;\r\n                mesh.triangles = triangles;\r\n                mesh.regionUVs = new Float32Array(uvs);\r\n                // mesh.updateUVs();\r\n                mesh.hullLength = hullLength << 1;\r\n                if (nonessential) {\r\n                    mesh.edges = edges;\r\n                    mesh.width = width * scale;\r\n                    mesh.height = height * scale;\r\n                }\r\n                return mesh;\r\n            }\r\n            case AttachmentType.LinkedMesh: {\r\n                let path = input.readStringRef();\r\n                let color = input.readInt32();\r\n                let skinName = input.readStringRef();\r\n                let parent = input.readStringRef();\r\n                let inheritDeform = input.readBoolean();\r\n                let width = 0, height = 0;\r\n                if (nonessential) {\r\n                    width = input.readFloat();\r\n                    height = input.readFloat();\r\n                }\r\n\r\n                if (!path) path = name;\r\n                let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n                if (!mesh) return null;\r\n                mesh.path = path;\r\n                Color.rgba8888ToColor(mesh.color, color);\r\n                if (nonessential) {\r\n                    mesh.width = width * scale;\r\n                    mesh.height = height * scale;\r\n                }\r\n                this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritDeform));\r\n                return mesh;\r\n            }\r\n            case AttachmentType.Path: {\r\n                let closed = input.readBoolean();\r\n                let constantSpeed = input.readBoolean();\r\n                let vertexCount = input.readInt(true);\r\n                let vertices = this.readVertices(input, vertexCount);\r\n                let lengths = Utils.newArray(vertexCount / 3, 0);\r\n                for (let i = 0, n = lengths.length; i < n; i++)\r\n                    lengths[i] = input.readFloat() * scale;\r\n                let color = nonessential ? input.readInt32() : 0;\r\n\r\n                let path = this.attachmentLoader.newPathAttachment(skin, name);\r\n                if (!path) return null;\r\n                path.closed = closed;\r\n                path.constantSpeed = constantSpeed;\r\n                path.worldVerticesLength = vertexCount << 1;\r\n                path.vertices = vertices.vertices;\r\n                path.bones = vertices.bones;\r\n                path.lengths = lengths;\r\n                if (nonessential) Color.rgba8888ToColor(path.color, color);\r\n                return path;\r\n            }\r\n            case AttachmentType.Point: {\r\n                let rotation = input.readFloat();\r\n                let x = input.readFloat();\r\n                let y = input.readFloat();\r\n                let color = nonessential ? input.readInt32() : 0;\r\n\r\n                let point = this.attachmentLoader.newPointAttachment(skin, name);\r\n                if (!point) return null;\r\n                point.x = x * scale;\r\n                point.y = y * scale;\r\n                point.rotation = rotation;\r\n                if (nonessential) Color.rgba8888ToColor(point.color, color);\r\n                return point;\r\n            }\r\n            case AttachmentType.Clipping: {\r\n                let endSlotIndex = input.readInt(true);\r\n                let vertexCount = input.readInt(true);\r\n                let vertices = this.readVertices(input, vertexCount);\r\n                let color = nonessential ? input.readInt32() : 0;\r\n\r\n                let clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n                if (!clip) return null;\r\n                clip.endSlot = skeletonData.slots[endSlotIndex];\r\n                clip.worldVerticesLength = vertexCount << 1;\r\n                clip.vertices = vertices.vertices;\r\n                clip.bones = vertices.bones;\r\n                if (nonessential) Color.rgba8888ToColor(clip.color, color);\r\n                return clip;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private readVertices (input: BinaryInput, vertexCount: number): Vertices {\r\n        let scale = this.scale;\r\n        let verticesLength = vertexCount << 1;\r\n        let vertices = new Vertices();\r\n        if (!input.readBoolean()) {\r\n            vertices.vertices = this.readFloatArray(input, verticesLength, scale);\r\n            return vertices;\r\n        }\r\n        let weights = new Array<number>();\r\n        let bonesArray = new Array<number>();\r\n        for (let i = 0; i < vertexCount; i++) {\r\n            let boneCount = input.readInt(true);\r\n            bonesArray.push(boneCount);\r\n            for (let ii = 0; ii < boneCount; ii++) {\r\n                bonesArray.push(input.readInt(true));\r\n                weights.push(input.readFloat() * scale);\r\n                weights.push(input.readFloat() * scale);\r\n                weights.push(input.readFloat());\r\n            }\r\n        }\r\n        vertices.vertices = Utils.toFloatArray(weights);\r\n        vertices.bones = bonesArray;\r\n        return vertices;\r\n    }\r\n\r\n    private readFloatArray (input: BinaryInput, n: number, scale: number): number[] {\r\n        let array = new Array<number>(n);\r\n        if (scale == 1) {\r\n            for (let i = 0; i < n; i++)\r\n                array[i] = input.readFloat();\r\n        } else {\r\n            for (let i = 0; i < n; i++)\r\n                array[i] = input.readFloat() * scale;\r\n        }\r\n        return array;\r\n    }\r\n\r\n    private readShortArray (input: BinaryInput): number[] {\r\n        let n = input.readInt(true);\r\n        let array = new Array<number>(n);\r\n        for (let i = 0; i < n; i++)\r\n            array[i] = input.readShort();\r\n        return array;\r\n    }\r\n\r\n    private readAnimation (input: BinaryInput, name: string, skeletonData: SkeletonData): Animation {\r\n        input.readInt(true); // Number of timelines.\r\n        let timelines = new Array<Timeline>();\r\n        let scale = this.scale;\r\n\r\n        // Slot timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            let slotIndex = input.readInt(true);\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                let timelineType = input.readByte();\r\n                let frameCount = input.readInt(true);\r\n                let frameLast = frameCount - 1;\r\n                switch (timelineType) {\r\n                    case SLOT_ATTACHMENT: {\r\n                        let timeline = new AttachmentTimeline(frameCount, slotIndex);\r\n                        for (let frame = 0; frame < frameCount; frame++)\r\n                            timeline.setFrame(frame, input.readFloat(), input.readStringRef());\r\n                        timelines.push(timeline);\r\n                        break;\r\n                    }\r\n                    case SLOT_RGBA: {\r\n                        let bezierCount = input.readInt(true);\r\n                        let timeline = new RGBATimeline(frameCount, bezierCount, slotIndex);\r\n\r\n                        let time = input.readFloat();\r\n                        let r = input.readUnsignedByte() / 255.0;\r\n                        let g = input.readUnsignedByte() / 255.0;\r\n                        let b = input.readUnsignedByte() / 255.0;\r\n                        let a = input.readUnsignedByte() / 255.0;\r\n\r\n                        for (let frame = 0, bezier = 0;; frame++) {\r\n                            timeline.setFrame(frame, time, r, g, b, a);\r\n                            if (frame == frameLast) break;\r\n\r\n                            let time2 = input.readFloat();\r\n                            let r2 = input.readUnsignedByte() / 255.0;\r\n                            let g2 = input.readUnsignedByte() / 255.0;\r\n                            let b2 = input.readUnsignedByte() / 255.0;\r\n                            let a2 = input.readUnsignedByte() / 255.0;\r\n\r\n                            switch (input.readByte()) {\r\n                                case CURVE_STEPPED:\r\n                                    timeline.setStepped(frame);\r\n                                    break;\r\n                                case CURVE_BEZIER:\r\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 3, time, time2, a, a2, 1);\r\n                            }\r\n                            time = time2;\r\n                            r = r2;\r\n                            g = g2;\r\n                            b = b2;\r\n                            a = a2;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        break;\r\n                    }\r\n                    case SLOT_RGB: {\r\n                        let bezierCount = input.readInt(true);\r\n                        let timeline = new RGBTimeline(frameCount, bezierCount, slotIndex);\r\n\r\n                        let time = input.readFloat();\r\n                        let r = input.readUnsignedByte() / 255.0;\r\n                        let g = input.readUnsignedByte() / 255.0;\r\n                        let b = input.readUnsignedByte() / 255.0;\r\n\r\n                        for (let frame = 0, bezier = 0;; frame++) {\r\n                            timeline.setFrame(frame, time, r, g, b);\r\n                            if (frame == frameLast) break;\r\n\r\n                            let time2 = input.readFloat();\r\n                            let r2 = input.readUnsignedByte() / 255.0;\r\n                            let g2 = input.readUnsignedByte() / 255.0;\r\n                            let b2 = input.readUnsignedByte() / 255.0;\r\n\r\n                            switch (input.readByte()) {\r\n                                case CURVE_STEPPED:\r\n                                    timeline.setStepped(frame);\r\n                                    break;\r\n                                case CURVE_BEZIER:\r\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\r\n                            }\r\n                            time = time2;\r\n                            r = r2;\r\n                            g = g2;\r\n                            b = b2;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        break;\r\n                    }\r\n                    case SLOT_RGBA2: {\r\n                        let bezierCount = input.readInt(true);\r\n                        let timeline = new RGBA2Timeline(frameCount, bezierCount, slotIndex);\r\n\r\n                        let time = input.readFloat();\r\n                        let r = input.readUnsignedByte() / 255.0;\r\n                        let g = input.readUnsignedByte() / 255.0;\r\n                        let b = input.readUnsignedByte() / 255.0;\r\n                        let a = input.readUnsignedByte() / 255.0;\r\n                        let r2 = input.readUnsignedByte() / 255.0;\r\n                        let g2 = input.readUnsignedByte() / 255.0;\r\n                        let b2 = input.readUnsignedByte() / 255.0;\r\n\r\n                        for (let frame = 0, bezier = 0;; frame++) {\r\n                            timeline.setFrame(frame, time, r, g, b, a, r2, g2, b2);\r\n                            if (frame == frameLast) break;\r\n                            let time2 = input.readFloat();\r\n                            let nr = input.readUnsignedByte() / 255.0;\r\n                            let ng = input.readUnsignedByte() / 255.0;\r\n                            let nb = input.readUnsignedByte() / 255.0;\r\n                            let na = input.readUnsignedByte() / 255.0;\r\n                            let nr2 = input.readUnsignedByte() / 255.0;\r\n                            let ng2 = input.readUnsignedByte() / 255.0;\r\n                            let nb2 = input.readUnsignedByte() / 255.0;\r\n\r\n                            switch (input.readByte()) {\r\n                                case CURVE_STEPPED:\r\n                                    timeline.setStepped(frame);\r\n                                    break;\r\n                                case CURVE_BEZIER:\r\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 3, time, time2, a, na, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 4, time, time2, r2, nr2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 5, time, time2, g2, ng2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 6, time, time2, b2, nb2, 1);\r\n                            }\r\n                            time = time2;\r\n                            r = nr;\r\n                            g = ng;\r\n                            b = nb;\r\n                            a = na;\r\n                            r2 = nr2;\r\n                            g2 = ng2;\r\n                            b2 = nb2;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        break;\r\n                    }\r\n                    case SLOT_RGB2: {\r\n                        let bezierCount = input.readInt(true);\r\n                        let timeline = new RGB2Timeline(frameCount, bezierCount, slotIndex);\r\n\r\n                        let time = input.readFloat();\r\n                        let r = input.readUnsignedByte() / 255.0;\r\n                        let g = input.readUnsignedByte() / 255.0;\r\n                        let b = input.readUnsignedByte() / 255.0;\r\n                        let r2 = input.readUnsignedByte() / 255.0;\r\n                        let g2 = input.readUnsignedByte() / 255.0;\r\n                        let b2 = input.readUnsignedByte() / 255.0;\r\n\r\n                        for (let frame = 0, bezier = 0;; frame++) {\r\n                            timeline.setFrame(frame, time, r, g, b, r2, g2, b2);\r\n                            if (frame == frameLast) break;\r\n                            let time2 = input.readFloat();\r\n                            let nr = input.readUnsignedByte() / 255.0;\r\n                            let ng = input.readUnsignedByte() / 255.0;\r\n                            let nb = input.readUnsignedByte() / 255.0;\r\n                            let nr2 = input.readUnsignedByte() / 255.0;\r\n                            let ng2 = input.readUnsignedByte() / 255.0;\r\n                            let nb2 = input.readUnsignedByte() / 255.0;\r\n\r\n                            switch (input.readByte()) {\r\n                                case CURVE_STEPPED:\r\n                                    timeline.setStepped(frame);\r\n                                    break;\r\n                                case CURVE_BEZIER:\r\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 3, time, time2, r2, nr2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 4, time, time2, g2, ng2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 5, time, time2, b2, nb2, 1);\r\n                            }\r\n                            time = time2;\r\n                            r = nr;\r\n                            g = ng;\r\n                            b = nb;\r\n                            r2 = nr2;\r\n                            g2 = ng2;\r\n                            b2 = nb2;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        break;\r\n                    }\r\n                    case SLOT_ALPHA: {\r\n                        let timeline = new AlphaTimeline(frameCount, input.readInt(true), slotIndex);\r\n                        let time = input.readFloat(), a = input.readUnsignedByte() / 255;\r\n                        for (let frame = 0, bezier = 0;; frame++) {\r\n                            timeline.setFrame(frame, time, a);\r\n                            if (frame == frameLast) break;\r\n                            let time2 = input.readFloat();\r\n                            let a2 = input.readUnsignedByte() / 255;\r\n                            switch (input.readByte()) {\r\n                                case CURVE_STEPPED:\r\n                                    timeline.setStepped(frame);\r\n                                    break;\r\n                                case CURVE_BEZIER:\r\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, a, a2, 1);\r\n                            }\r\n                            time = time2;\r\n                            a = a2;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bone timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            let boneIndex = input.readInt(true);\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                let type = input.readByte(), frameCount = input.readInt(true), bezierCount = input.readInt(true);\r\n                switch (type) {\r\n                    case BONE_ROTATE:\r\n                        timelines.push(readTimeline1(input, new RotateTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                        break;\r\n                    case BONE_TRANSLATE:\r\n                        timelines.push(readTimeline2(input, new TranslateTimeline(frameCount, bezierCount, boneIndex), scale));\r\n                        break;\r\n                    case BONE_TRANSLATEX:\r\n                        timelines.push(readTimeline1(input, new TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));\r\n                        break;\r\n                    case BONE_TRANSLATEY:\r\n                        timelines.push(readTimeline1(input, new TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));\r\n                        break;\r\n                    case BONE_SCALE:\r\n                        timelines.push(readTimeline2(input, new ScaleTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                        break;\r\n                    case BONE_SCALEX:\r\n                        timelines.push(readTimeline1(input, new ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                        break;\r\n                    case BONE_SCALEY:\r\n                        timelines.push(readTimeline1(input, new ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                        break;\r\n                    case BONE_SHEAR:\r\n                        timelines.push(readTimeline2(input, new ShearTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                        break;\r\n                    case BONE_SHEARX:\r\n                        timelines.push(readTimeline1(input, new ShearXTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                        break;\r\n                    case BONE_SHEARY:\r\n                        timelines.push(readTimeline1(input, new ShearYTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                }\r\n            }\r\n        }\r\n\r\n        // IK constraint timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            let index = input.readInt(true), frameCount = input.readInt(true), frameLast = frameCount - 1;\r\n            let timeline = new IkConstraintTimeline(frameCount, input.readInt(true), index);\r\n            let time = input.readFloat(), mix = input.readFloat(), softness = input.readFloat() * scale;\r\n            for (let frame = 0, bezier = 0;; frame++) {\r\n                timeline.setFrame(frame, time, mix, softness, input.readByte(), input.readBoolean(), input.readBoolean());\r\n                if (frame == frameLast) break;\r\n                let time2 = input.readFloat(), mix2 = input.readFloat(), softness2 = input.readFloat() * scale;\r\n                switch (input.readByte()) {\r\n                    case CURVE_STEPPED:\r\n                        timeline.setStepped(frame);\r\n                        break;\r\n                    case CURVE_BEZIER:\r\n                        setBezier(input, timeline, bezier++, frame, 0, time, time2, mix, mix2, 1);\r\n                        setBezier(input, timeline, bezier++, frame, 1, time, time2, softness, softness2, scale);\r\n                }\r\n                time = time2;\r\n                mix = mix2;\r\n                softness = softness2;\r\n            }\r\n            timelines.push(timeline);\r\n        }\r\n\r\n        // Transform constraint timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            let index = input.readInt(true), frameCount = input.readInt(true), frameLast = frameCount - 1;\r\n            let timeline = new TransformConstraintTimeline(frameCount, input.readInt(true), index);\r\n            let time = input.readFloat(), mixRotate = input.readFloat(), mixX = input.readFloat(), mixY = input.readFloat(),\r\n                mixScaleX = input.readFloat(), mixScaleY = input.readFloat(), mixShearY = input.readFloat();\r\n            for (let frame = 0, bezier = 0;; frame++) {\r\n                timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\r\n                if (frame == frameLast) break;\r\n                let time2 = input.readFloat(), mixRotate2 = input.readFloat(), mixX2 = input.readFloat(), mixY2 = input.readFloat(),\r\n                    mixScaleX2 = input.readFloat(), mixScaleY2 = input.readFloat(), mixShearY2 = input.readFloat();\r\n                switch (input.readByte()) {\r\n                    case CURVE_STEPPED:\r\n                        timeline.setStepped(frame);\r\n                        break;\r\n                    case CURVE_BEZIER:\r\n                        setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\r\n                        setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\r\n                        setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\r\n                        setBezier(input, timeline, bezier++, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\r\n                        setBezier(input, timeline, bezier++, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\r\n                        setBezier(input, timeline, bezier++, frame, 5, time, time2, mixShearY, mixShearY2, 1);\r\n                }\r\n                time = time2;\r\n                mixRotate = mixRotate2;\r\n                mixX = mixX2;\r\n                mixY = mixY2;\r\n                mixScaleX = mixScaleX2;\r\n                mixScaleY = mixScaleY2;\r\n                mixShearY = mixShearY2;\r\n            }\r\n            timelines.push(timeline);\r\n        }\r\n\r\n        // Path constraint timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            let index = input.readInt(true);\r\n            let data = skeletonData.pathConstraints[index];\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                switch (input.readByte()) {\r\n                    case PATH_POSITION:\r\n                        timelines\r\n                            .push(readTimeline1(input, new PathConstraintPositionTimeline(input.readInt(true), input.readInt(true), index),\r\n                                data.positionMode == PositionMode.Fixed ? scale : 1));\r\n                        break;\r\n                    case PATH_SPACING:\r\n                        timelines\r\n                            .push(readTimeline1(input, new PathConstraintSpacingTimeline(input.readInt(true), input.readInt(true), index),\r\n                                data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed ? scale : 1));\r\n                        break;\r\n                    case PATH_MIX:\r\n                        let timeline = new PathConstraintMixTimeline(input.readInt(true), input.readInt(true), index);\r\n                        let time = input.readFloat(), mixRotate = input.readFloat(), mixX = input.readFloat(), mixY = input.readFloat();\r\n                        for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1;; frame++) {\r\n                            timeline.setFrame(frame, time, mixRotate, mixX, mixY);\r\n                            if (frame == frameLast) break;\r\n                            let time2 = input.readFloat(), mixRotate2 = input.readFloat(), mixX2 = input.readFloat(),\r\n                                mixY2 = input.readFloat();\r\n                            switch (input.readByte()) {\r\n                                case CURVE_STEPPED:\r\n                                    timeline.setStepped(frame);\r\n                                    break;\r\n                                case CURVE_BEZIER:\r\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\r\n                            }\r\n                            time = time2;\r\n                            mixRotate = mixRotate2;\r\n                            mixX = mixX2;\r\n                            mixY = mixY2;\r\n                        }\r\n                        timelines.push(timeline);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Deform timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            let skin = skeletonData.skins[input.readInt(true)];\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                let slotIndex = input.readInt(true);\r\n                for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\r\n                    let attachmentName = input.readStringRef();\r\n                    let attachment = skin.getAttachment(slotIndex, attachmentName) as VertexAttachment;\r\n                    let weighted = attachment.bones;\r\n                    let vertices = attachment.vertices;\r\n                    let deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n\r\n                    let frameCount = input.readInt(true);\r\n                    let frameLast = frameCount - 1;\r\n                    let bezierCount = input.readInt(true);\r\n                    let timeline = new DeformTimeline(frameCount, bezierCount, slotIndex, attachment);\r\n\r\n                    let time = input.readFloat();\r\n                    for (let frame = 0, bezier = 0;; frame++) {\r\n                        let deform;\r\n                        let end = input.readInt(true);\r\n                        if (end == 0)\r\n                            deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\r\n                        else {\r\n                            deform = Utils.newFloatArray(deformLength);\r\n                            let start = input.readInt(true);\r\n                            end += start;\r\n                            if (scale == 1) {\r\n                                for (let v = start; v < end; v++)\r\n                                    deform[v] = input.readFloat();\r\n                            } else {\r\n                                for (let v = start; v < end; v++)\r\n                                    deform[v] = input.readFloat() * scale;\r\n                            }\r\n                            if (!weighted) {\r\n                                for (let v = 0, vn = deform.length; v < vn; v++)\r\n                                    deform[v] += vertices[v];\r\n                            }\r\n                        }\r\n\r\n                        timeline.setFrame(frame, time, deform);\r\n                        if (frame == frameLast) break;\r\n                        let time2 = input.readFloat();\r\n                        switch(input.readByte()) {\r\n                            case CURVE_STEPPED:\r\n                                timeline.setStepped(frame);\r\n                                break;\r\n                            case CURVE_BEZIER:\r\n                                setBezier(input, timeline, bezier++, frame, 0, time, time2, 0, 1, 1);\r\n                        }\r\n                        time = time2;\r\n                    }\r\n                    timelines.push(timeline);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Draw order timeline.\r\n        let drawOrderCount = input.readInt(true);\r\n        if (drawOrderCount > 0) {\r\n            let timeline = new DrawOrderTimeline(drawOrderCount);\r\n            let slotCount = skeletonData.slots.length;\r\n            for (let i = 0; i < drawOrderCount; i++) {\r\n                let time = input.readFloat();\r\n                let offsetCount = input.readInt(true);\r\n                let drawOrder = Utils.newArray(slotCount, 0);\r\n                for (let ii = slotCount - 1; ii >= 0; ii--)\r\n                    drawOrder[ii] = -1;\r\n                let unchanged = Utils.newArray(slotCount - offsetCount, 0);\r\n                let originalIndex = 0, unchangedIndex = 0;\r\n                for (let ii = 0; ii < offsetCount; ii++) {\r\n                    let slotIndex = input.readInt(true);\r\n                    // Collect unchanged items.\r\n                    while (originalIndex != slotIndex)\r\n                        unchanged[unchangedIndex++] = originalIndex++;\r\n                    // Set changed items.\r\n                    drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\r\n                }\r\n                // Collect remaining unchanged items.\r\n                while (originalIndex < slotCount)\r\n                    unchanged[unchangedIndex++] = originalIndex++;\r\n                // Fill in unchanged items.\r\n                for (let ii = slotCount - 1; ii >= 0; ii--)\r\n                    if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\r\n                timeline.setFrame(i, time, drawOrder);\r\n            }\r\n            timelines.push(timeline);\r\n        }\r\n\r\n        // Event timeline.\r\n        let eventCount = input.readInt(true);\r\n        if (eventCount > 0) {\r\n            let timeline = new EventTimeline(eventCount);\r\n            for (let i = 0; i < eventCount; i++) {\r\n                let time = input.readFloat();\r\n                let eventData = skeletonData.events[input.readInt(true)];\r\n                let event = new Event(time, eventData);\r\n                event.intValue = input.readInt(false);\r\n                event.floatValue = input.readFloat();\r\n                event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\r\n                if (event.data.audioPath) {\r\n                    event.volume = input.readFloat();\r\n                    event.balance = input.readFloat();\r\n                }\r\n                timeline.setFrame(i, event);\r\n            }\r\n            timelines.push(timeline);\r\n        }\r\n\r\n        let duration = 0;\r\n        for (let i = 0, n = timelines.length; i < n; i++)\r\n            duration = Math.max(duration, timelines[i].getDuration());\r\n        return new Animation(name, timelines, duration);\r\n    }\r\n}\r\n\r\nclass LinkedMesh {\r\n    parent: string; skin: string;\r\n    slotIndex: number;\r\n    mesh: MeshAttachment;\r\n    inheritDeform: boolean;\r\n\r\n    constructor (mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\r\n        this.mesh = mesh;\r\n        this.skin = skin;\r\n        this.slotIndex = slotIndex;\r\n        this.parent = parent;\r\n        this.inheritDeform = inheritDeform;\r\n    }\r\n}\r\n\r\nclass Vertices {\r\n    constructor(public bones: Array<number> = null, public vertices: Array<number> | Float32Array = null) { }\r\n}\r\n\r\nfunction readTimeline1 (input: BinaryInput, timeline: CurveTimeline1, scale: number): CurveTimeline1 {\r\n    let time = input.readFloat(), value = input.readFloat() * scale;\r\n    for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1;; frame++) {\r\n        timeline.setFrame(frame, time, value);\r\n        if (frame == frameLast) break;\r\n        let time2 = input.readFloat(), value2 = input.readFloat() * scale;\r\n        switch (input.readByte()) {\r\n            case CURVE_STEPPED:\r\n                timeline.setStepped(frame);\r\n                break;\r\n            case CURVE_BEZIER:\r\n                setBezier(input, timeline, bezier++, frame, 0, time, time2, value, value2, 1);\r\n        }\r\n        time = time2;\r\n        value = value2;\r\n    }\r\n    return timeline;\r\n}\r\n\r\nfunction readTimeline2 (input: BinaryInput, timeline: CurveTimeline2, scale: number): CurveTimeline2 {\r\n    let time = input.readFloat(), value1 = input.readFloat() * scale, value2 = input.readFloat() * scale;\r\n    for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1;; frame++) {\r\n        timeline.setFrame(frame, time, value1, value2);\r\n        if (frame == frameLast) break;\r\n        let time2 = input.readFloat(), nvalue1 = input.readFloat() * scale, nvalue2 = input.readFloat() * scale;\r\n        switch (input.readByte()) {\r\n            case CURVE_STEPPED:\r\n                timeline.setStepped(frame);\r\n                break;\r\n            case CURVE_BEZIER:\r\n                setBezier(input, timeline, bezier++, frame, 0, time, time2, value1, nvalue1, scale);\r\n                setBezier(input, timeline, bezier++, frame, 1, time, time2, value2, nvalue2, scale);\r\n        }\r\n        time = time2;\r\n        value1 = nvalue1;\r\n        value2 = nvalue2;\r\n    }\r\n    return timeline;\r\n}\r\n\r\nfunction setBezier (input: BinaryInput, timeline: CurveTimeline, bezier: number, frame: number, value: number,\r\n                    time1: number, time2: number, value1: number, value2: number, scale: number) {\r\n    timeline.setBezier(bezier, frame, value, time1, value1, input.readFloat(), input.readFloat() * scale, input.readFloat(), input.readFloat() * scale, time2, value2);\r\n}\r\n\r\nconst  BONE_ROTATE = 0;\r\nconst  BONE_TRANSLATE = 1;\r\nconst  BONE_TRANSLATEX = 2;\r\nconst  BONE_TRANSLATEY = 3;\r\nconst  BONE_SCALE = 4;\r\nconst  BONE_SCALEX = 5;\r\nconst  BONE_SCALEY = 6;\r\nconst  BONE_SHEAR = 7;\r\nconst  BONE_SHEARX = 8;\r\nconst  BONE_SHEARY = 9;\r\n\r\nconst  SLOT_ATTACHMENT = 0;\r\nconst  SLOT_RGBA = 1;\r\nconst  SLOT_RGB = 2;\r\nconst  SLOT_RGBA2 = 3;\r\nconst  SLOT_RGB2 = 4;\r\nconst  SLOT_ALPHA = 5;\r\n\r\nconst  PATH_POSITION = 0;\r\nconst  PATH_SPACING = 1;\r\nconst  PATH_MIX = 2;\r\n\r\n// @ts-ignore\r\nconst  CURVE_LINEAR = 0;\r\nconst  CURVE_STEPPED = 1;\r\nconst  CURVE_BEZIER = 2;\r\n","import {BoundingBoxAttachment} from \"./attachments\";\r\nimport {Pool, Utils} from \"@pixi-spine/base\";\r\nimport type {Skeleton} from \"./Skeleton\";\r\n\r\n/** Collects each visible {@link BoundingBoxAttachment} and computes the world vertices for its polygon. The polygon vertices are\r\n * provided along with convenience methods for doing hit detection.\r\n * @public\r\n * */\r\nexport class SkeletonBounds {\r\n\r\n    /** The left edge of the axis aligned bounding box. */\r\n    minX = 0;\r\n\r\n    /** The bottom edge of the axis aligned bounding box. */\r\n    minY = 0;\r\n\r\n    /** The right edge of the axis aligned bounding box. */\r\n    maxX = 0;\r\n\r\n    /** The top edge of the axis aligned bounding box. */\r\n    maxY = 0;\r\n\r\n    /** The visible bounding boxes. */\r\n    boundingBoxes = new Array<BoundingBoxAttachment>();\r\n\r\n    /** The world vertices for the bounding box polygons. */\r\n    polygons = new Array<ArrayLike<number>>();\r\n\r\n    private polygonPool = new Pool<ArrayLike<number>>(() => {\r\n        return Utils.newFloatArray(16);\r\n    });\r\n\r\n    /** Clears any previous polygons, finds all visible bounding box attachments, and computes the world vertices for each bounding\r\n     * box's polygon.\r\n     * @param updateAabb If true, the axis aligned bounding box containing all the polygons is computed. If false, the\r\n     *           SkeletonBounds AABB methods will always return true. */\r\n    update (skeleton: Skeleton, updateAabb: boolean) {\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n        let boundingBoxes = this.boundingBoxes;\r\n        let polygons = this.polygons;\r\n        let polygonPool = this.polygonPool;\r\n        let slots = skeleton.slots;\r\n        let slotCount = slots.length;\r\n\r\n        boundingBoxes.length = 0;\r\n        polygonPool.freeAll(polygons);\r\n        polygons.length = 0;\r\n\r\n        for (let i = 0; i < slotCount; i++) {\r\n            let slot = slots[i];\r\n            if (!slot.bone.active) continue;\r\n            let attachment = slot.getAttachment();\r\n            if (attachment instanceof BoundingBoxAttachment) {\r\n                let boundingBox = attachment as BoundingBoxAttachment;\r\n                boundingBoxes.push(boundingBox);\r\n\r\n                let polygon = polygonPool.obtain();\r\n                if (polygon.length != boundingBox.worldVerticesLength) {\r\n                    polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\r\n                }\r\n                polygons.push(polygon);\r\n                boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\r\n            }\r\n        }\r\n\r\n        if (updateAabb) {\r\n            this.aabbCompute();\r\n        } else {\r\n            this.minX = Number.POSITIVE_INFINITY;\r\n            this.minY = Number.POSITIVE_INFINITY;\r\n            this.maxX = Number.NEGATIVE_INFINITY;\r\n            this.maxY = Number.NEGATIVE_INFINITY;\r\n        }\r\n    }\r\n\r\n    aabbCompute () {\r\n        let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n        let polygons = this.polygons;\r\n        for (let i = 0, n = polygons.length; i < n; i++) {\r\n            let polygon = polygons[i];\r\n            let vertices = polygon;\r\n            for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\r\n                let x = vertices[ii];\r\n                let y = vertices[ii + 1];\r\n                minX = Math.min(minX, x);\r\n                minY = Math.min(minY, y);\r\n                maxX = Math.max(maxX, x);\r\n                maxY = Math.max(maxY, y);\r\n            }\r\n        }\r\n        this.minX = minX;\r\n        this.minY = minY;\r\n        this.maxX = maxX;\r\n        this.maxY = maxY;\r\n    }\r\n\r\n    /** Returns true if the axis aligned bounding box contains the point. */\r\n    aabbContainsPoint (x: number, y: number) {\r\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n    }\r\n\r\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\r\n    aabbIntersectsSegment (x1: number, y1: number, x2: number, y2: number) {\r\n        let minX = this.minX;\r\n        let minY = this.minY;\r\n        let maxX = this.maxX;\r\n        let maxY = this.maxY;\r\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n            return false;\r\n        let m = (y2 - y1) / (x2 - x1);\r\n        let y = m * (minX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        y = m * (maxX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        let x = (minY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        x = (maxY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        return false;\r\n    }\r\n\r\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\r\n    aabbIntersectsSkeleton (bounds: SkeletonBounds) {\r\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n    }\r\n\r\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\r\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\r\n    containsPoint (x: number, y: number): BoundingBoxAttachment {\r\n        let polygons = this.polygons;\r\n        for (let i = 0, n = polygons.length; i < n; i++)\r\n            if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\r\n        return null;\r\n    }\r\n\r\n    /** Returns true if the polygon contains the point. */\r\n    containsPointPolygon (polygon: ArrayLike<number>, x: number, y: number) {\r\n        let vertices = polygon;\r\n        let nn = polygon.length;\r\n\r\n        let prevIndex = nn - 2;\r\n        let inside = false;\r\n        for (let ii = 0; ii < nn; ii += 2) {\r\n            let vertexY = vertices[ii + 1];\r\n            let prevY = vertices[prevIndex + 1];\r\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\r\n                let vertexX = vertices[ii];\r\n                if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\r\n            }\r\n            prevIndex = ii;\r\n        }\r\n        return inside;\r\n    }\r\n\r\n    /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\r\n     * is usually more efficient to only call this method if {@link #aabbIntersectsSegment()} returns\r\n     * true. */\r\n    intersectsSegment (x1: number, y1: number, x2: number, y2: number) {\r\n        let polygons = this.polygons;\r\n        for (let i = 0, n = polygons.length; i < n; i++)\r\n            if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\r\n        return null;\r\n    }\r\n\r\n    /** Returns true if the polygon contains any part of the line segment. */\r\n    intersectsSegmentPolygon (polygon: ArrayLike<number>, x1: number, y1: number, x2: number, y2: number) {\r\n        let vertices = polygon;\r\n        let nn = polygon.length;\r\n\r\n        let width12 = x1 - x2, height12 = y1 - y2;\r\n        let det1 = x1 * y2 - y1 * x2;\r\n        let x3 = vertices[nn - 2], y3 = vertices[nn - 1];\r\n        for (let ii = 0; ii < nn; ii += 2) {\r\n            let x4 = vertices[ii], y4 = vertices[ii + 1];\r\n            let det2 = x3 * y4 - y3 * x4;\r\n            let width34 = x3 - x4, height34 = y3 - y4;\r\n            let det3 = width12 * height34 - height12 * width34;\r\n            let x = (det1 * width34 - width12 * det2) / det3;\r\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\r\n                let y = (det1 * height34 - height12 * det2) / det3;\r\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\r\n            }\r\n            x3 = x4;\r\n            y3 = y4;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** Returns the polygon for the specified bounding box, or null. */\r\n    getPolygon (boundingBox: BoundingBoxAttachment) {\r\n        if (boundingBox == null) throw new Error(\"boundingBox cannot be null.\");\r\n        let index = this.boundingBoxes.indexOf(boundingBox);\r\n        return index == -1 ? null : this.polygons[index];\r\n    }\r\n\r\n    /** The width of the axis aligned bounding box. */\r\n    getWidth () {\r\n        return this.maxX - this.minX;\r\n    }\r\n\r\n    /** The height of the axis aligned bounding box. */\r\n    getHeight () {\r\n        return this.maxY - this.minY;\r\n    }\r\n}\r\n","import type {Attachment, AttachmentLoader, MeshAttachment, VertexAttachment} from './attachments';\r\nimport {\r\n    AlphaTimeline, Animation,\r\n    AttachmentTimeline, CurveTimeline, CurveTimeline1, CurveTimeline2, DeformTimeline, DrawOrderTimeline, EventTimeline,\r\n    IkConstraintTimeline,\r\n    PathConstraintMixTimeline,\r\n    PathConstraintPositionTimeline,\r\n    PathConstraintSpacingTimeline, RGB2Timeline, RGBA2Timeline, RGBATimeline, RGBTimeline,\r\n    RotateTimeline,\r\n    ScaleTimeline, ScaleXTimeline, ScaleYTimeline,\r\n    ShearTimeline, ShearXTimeline, ShearYTimeline,\r\n    Timeline,\r\n    TransformConstraintTimeline,\r\n    TranslateTimeline, TranslateXTimeline, TranslateYTimeline\r\n} from './Animation';\r\nimport {Event} from './Event';\r\nimport {SkeletonData} from './SkeletonData';\r\nimport {SlotData} from './SlotData';\r\nimport {BoneData, TransformMode} from './BoneData';\r\nimport {IkConstraintData} from './IkConstraintData';\r\nimport {TransformConstraintData} from './TransformConstraintData';\r\nimport {PathConstraintData, PositionMode, RotateMode, SpacingMode} from './PathConstraintData';\r\nimport {Skin} from './Skin';\r\nimport {EventData} from './EventData';\r\nimport {ArrayLike, Color, Utils, settings} from '@pixi-spine/base';\r\nimport {BLEND_MODES} from '@pixi/constants';\r\n\r\n/** Loads skeleton data in the Spine JSON format.\r\n *\r\n * See [Spine JSON format](http://esotericsoftware.com/spine-json-format) and\r\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\r\n * Runtimes Guide.\r\n * @public\r\n * */\r\nexport class SkeletonJson {\r\n    attachmentLoader: AttachmentLoader;\r\n\r\n    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\r\n     * runtime than were used in Spine.\r\n     *\r\n     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\r\n    scale = 1;\r\n    private linkedMeshes = new Array<LinkedMesh>();\r\n\r\n    constructor (attachmentLoader: AttachmentLoader) {\r\n        this.attachmentLoader = attachmentLoader;\r\n    }\r\n\r\n    readSkeletonData (json: string | any): SkeletonData {\r\n        let scale = this.scale;\r\n        let skeletonData = new SkeletonData();\r\n        let root = typeof(json) === \"string\" ? JSON.parse(json) : json;\r\n\r\n        // Skeleton\r\n        let skeletonMap = root.skeleton;\r\n        if (skeletonMap) {\r\n            skeletonData.hash = skeletonMap.hash;\r\n            skeletonData.version = skeletonMap.spine;\r\n            if (skeletonData.version.substr(0, 3) !== '4.0') {\r\n                let error = `Spine 4.0 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;\r\n                console.error(error);\r\n            }\r\n            skeletonData.x = skeletonMap.x;\r\n            skeletonData.y = skeletonMap.y;\r\n            skeletonData.width = skeletonMap.width;\r\n            skeletonData.height = skeletonMap.height;\r\n            skeletonData.fps = skeletonMap.fps;\r\n            skeletonData.imagesPath = skeletonMap.images;\r\n        }\r\n\r\n        // Bones\r\n        if (root.bones) {\r\n            for (let i = 0; i < root.bones.length; i++) {\r\n                let boneMap = root.bones[i];\r\n\r\n                let parent: BoneData = null;\r\n                let parentName: string = getValue(boneMap, \"parent\", null);\r\n                if (parentName != null) {\r\n                    parent = skeletonData.findBone(parentName);\r\n                    if (parent == null) throw new Error(\"Parent bone not found: \" + parentName);\r\n                }\r\n                let data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\r\n                data.length = getValue(boneMap, \"length\", 0) * scale;\r\n                data.x = getValue(boneMap, \"x\", 0) * scale;\r\n                data.y = getValue(boneMap, \"y\", 0) * scale;\r\n                data.rotation = getValue(boneMap, \"rotation\", 0);\r\n                data.scaleX = getValue(boneMap, \"scaleX\", 1);\r\n                data.scaleY = getValue(boneMap, \"scaleY\", 1);\r\n                data.shearX = getValue(boneMap, \"shearX\", 0);\r\n                data.shearY = getValue(boneMap, \"shearY\", 0);\r\n                data.transformMode = Utils.enumValue(TransformMode, getValue(boneMap, \"transform\", \"Normal\"));\r\n                data.skinRequired = getValue(boneMap, \"skin\", false);\r\n\r\n                let color = getValue(boneMap, \"color\", null);\r\n                if (color) data.color.setFromString(color);\r\n\r\n                skeletonData.bones.push(data);\r\n            }\r\n        }\r\n\r\n        // Slots.\r\n        if (root.slots) {\r\n            for (let i = 0; i < root.slots.length; i++) {\r\n                let slotMap = root.slots[i];\r\n                let slotName: string = slotMap.name;\r\n                let boneName: string = slotMap.bone;\r\n                let boneData = skeletonData.findBone(boneName);\r\n                if (boneData == null) throw new Error(\"Slot bone not found: \" + boneName);\r\n                let data = new SlotData(skeletonData.slots.length, slotName, boneData);\r\n\r\n                let color: string = getValue(slotMap, \"color\", null);\r\n                if (color) data.color.setFromString(color);\r\n\r\n                let dark: string = getValue(slotMap, \"dark\", null);\r\n                if (dark) data.darkColor = Color.fromString(dark);\r\n\r\n                data.attachmentName = getValue(slotMap, \"attachment\", null);\r\n                data.blendMode = SkeletonJson.blendModeFromString(getValue(slotMap, \"blend\", \"normal\"));\r\n                skeletonData.slots.push(data);\r\n            }\r\n        }\r\n\r\n        // IK constraints\r\n        if (root.ik) {\r\n            for (let i = 0; i < root.ik.length; i++) {\r\n                let constraintMap = root.ik[i];\r\n                let data = new IkConstraintData(constraintMap.name);\r\n                data.order = getValue(constraintMap, \"order\", 0);\r\n                data.skinRequired = getValue(constraintMap, \"skin\", false);\r\n\r\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\r\n                    let boneName = constraintMap.bones[ii];\r\n                    let bone = skeletonData.findBone(boneName);\r\n                    if (bone == null) throw new Error(\"IK bone not found: \" + boneName);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                data.target = skeletonData.findBone(constraintMap.target);\r\n\r\n                data.mix = getValue(constraintMap, \"mix\", 1);\r\n                data.softness = getValue(constraintMap, \"softness\", 0) * scale;\r\n                data.bendDirection = getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\r\n                data.compress = getValue(constraintMap, \"compress\", false);\r\n                data.stretch = getValue(constraintMap, \"stretch\", false);\r\n                data.uniform = getValue(constraintMap, \"uniform\", false);\r\n\r\n                skeletonData.ikConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Transform constraints.\r\n        if (root.transform) {\r\n            for (let i = 0; i < root.transform.length; i++) {\r\n                let constraintMap = root.transform[i];\r\n                let data = new TransformConstraintData(constraintMap.name);\r\n                data.order = getValue(constraintMap, \"order\", 0);\r\n                data.skinRequired = getValue(constraintMap, \"skin\", false);\r\n\r\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\r\n                    let boneName = constraintMap.bones[ii];\r\n                    let bone = skeletonData.findBone(boneName);\r\n                    if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                let targetName: string = constraintMap.target;\r\n                data.target = skeletonData.findBone(targetName);\r\n                if (data.target == null) throw new Error(\"Transform constraint target bone not found: \" + targetName);\r\n\r\n                data.local = getValue(constraintMap, \"local\", false);\r\n                data.relative = getValue(constraintMap, \"relative\", false);\r\n                data.offsetRotation = getValue(constraintMap, \"rotation\", 0);\r\n                data.offsetX = getValue(constraintMap, \"x\", 0) * scale;\r\n                data.offsetY = getValue(constraintMap, \"y\", 0) * scale;\r\n                data.offsetScaleX = getValue(constraintMap, \"scaleX\", 0);\r\n                data.offsetScaleY = getValue(constraintMap, \"scaleY\", 0);\r\n                data.offsetShearY = getValue(constraintMap, \"shearY\", 0);\r\n\r\n                data.mixRotate = getValue(constraintMap, \"mixRotate\", 1);\r\n                data.mixX = getValue(constraintMap, \"mixX\", 1);\r\n                data.mixY = getValue(constraintMap, \"mixY\", data.mixX);\r\n                data.mixScaleX = getValue(constraintMap, \"mixScaleX\", 1);\r\n                data.mixScaleY = getValue(constraintMap, \"mixScaleY\", data.mixScaleX);\r\n                data.mixShearY = getValue(constraintMap, \"mixShearY\", 1);\r\n\r\n                skeletonData.transformConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Path constraints.\r\n        if (root.path) {\r\n            for (let i = 0; i < root.path.length; i++) {\r\n                let constraintMap = root.path[i];\r\n                let data = new PathConstraintData(constraintMap.name);\r\n                data.order = getValue(constraintMap, \"order\", 0);\r\n                data.skinRequired = getValue(constraintMap, \"skin\", false);\r\n\r\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\r\n                    let boneName = constraintMap.bones[ii];\r\n                    let bone = skeletonData.findBone(boneName);\r\n                    if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                let targetName: string = constraintMap.target;\r\n                data.target = skeletonData.findSlot(targetName);\r\n                if (data.target == null) throw new Error(\"Path target slot not found: \" + targetName);\r\n\r\n                data.positionMode = Utils.enumValue(PositionMode, getValue(constraintMap, \"positionMode\", \"Percent\"));\r\n                data.spacingMode = Utils.enumValue(SpacingMode, getValue(constraintMap, \"spacingMode\", \"Length\"));\r\n                data.rotateMode = Utils.enumValue(RotateMode, getValue(constraintMap, \"rotateMode\", \"Tangent\"));\r\n                data.offsetRotation = getValue(constraintMap, \"rotation\", 0);\r\n                data.position = getValue(constraintMap, \"position\", 0);\r\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\r\n                data.spacing = getValue(constraintMap, \"spacing\", 0);\r\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\r\n                data.mixRotate = getValue(constraintMap, \"mixRotate\", 1);\r\n                data.mixX = getValue(constraintMap, \"mixX\", 1);\r\n                data.mixY = getValue(constraintMap, \"mixY\", data.mixX);\r\n\r\n                skeletonData.pathConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Skins.\r\n        if (root.skins) {\r\n            for (let i = 0; i < root.skins.length; i++) {\r\n                let skinMap = root.skins[i]\r\n                let skin = new Skin(skinMap.name);\r\n\r\n                if (skinMap.bones) {\r\n                    for (let ii = 0; ii < skinMap.bones.length; ii++) {\r\n                        let bone = skeletonData.findBone(skinMap.bones[ii]);\r\n                        if (bone == null) throw new Error(\"Skin bone not found: \" + skinMap.bones[i]);\r\n                        skin.bones.push(bone);\r\n                    }\r\n                }\r\n\r\n                if (skinMap.ik) {\r\n                    for (let ii = 0; ii < skinMap.ik.length; ii++) {\r\n                        let constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);\r\n                        if (constraint == null) throw new Error(\"Skin IK constraint not found: \" + skinMap.ik[i]);\r\n                        skin.constraints.push(constraint);\r\n                    }\r\n                }\r\n\r\n                if (skinMap.transform) {\r\n                    for (let ii = 0; ii < skinMap.transform.length; ii++) {\r\n                        let constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);\r\n                        if (constraint == null) throw new Error(\"Skin transform constraint not found: \" + skinMap.transform[i]);\r\n                        skin.constraints.push(constraint);\r\n                    }\r\n                }\r\n\r\n                if (skinMap.path) {\r\n                    for (let ii = 0; ii < skinMap.path.length; ii++) {\r\n                        let constraint = skeletonData.findPathConstraint(skinMap.path[ii]);\r\n                        if (constraint == null) throw new Error(\"Skin path constraint not found: \" + skinMap.path[i]);\r\n                        skin.constraints.push(constraint);\r\n                    }\r\n                }\r\n\r\n                for (let slotName in skinMap.attachments) {\r\n                    let slot = skeletonData.findSlot(slotName);\r\n                    if (slot == null) throw new Error(\"Slot not found: \" + slotName);\r\n                    let slotMap = skinMap.attachments[slotName];\r\n                    for (let entryName in slotMap) {\r\n                        let attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\r\n                        if (attachment) skin.setAttachment(slot.index, entryName, attachment);\r\n                    }\r\n                }\r\n                skeletonData.skins.push(skin);\r\n                if (skin.name == \"default\") skeletonData.defaultSkin = skin;\r\n            }\r\n        }\r\n\r\n        // Linked meshes.\r\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\r\n            let linkedMesh = this.linkedMeshes[i];\r\n            let skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n            let parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n            linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? <VertexAttachment>parent : <VertexAttachment>linkedMesh.mesh;\r\n            linkedMesh.mesh.setParentMesh(<MeshAttachment> parent);\r\n            // linkedMesh.mesh.updateUVs();\r\n        }\r\n        this.linkedMeshes.length = 0;\r\n\r\n        // Events.\r\n        if (root.events) {\r\n            for (let eventName in root.events) {\r\n                let eventMap = root.events[eventName];\r\n                let data = new EventData(eventName);\r\n                data.intValue = getValue(eventMap, \"int\", 0);\r\n                data.floatValue = getValue(eventMap, \"float\", 0);\r\n                data.stringValue = getValue(eventMap, \"string\", \"\");\r\n                data.audioPath = getValue(eventMap, \"audio\", null);\r\n                if (data.audioPath) {\r\n                    data.volume = getValue(eventMap, \"volume\", 1);\r\n                    data.balance = getValue(eventMap, \"balance\", 0);\r\n                }\r\n                skeletonData.events.push(data);\r\n            }\r\n        }\r\n\r\n        // Animations.\r\n        if (root.animations) {\r\n            for (let animationName in root.animations) {\r\n                let animationMap = root.animations[animationName];\r\n                this.readAnimation(animationMap, animationName, skeletonData);\r\n            }\r\n        }\r\n\r\n        return skeletonData;\r\n    }\r\n\r\n    readAttachment (map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment {\r\n        let scale = this.scale;\r\n        name = getValue(map, \"name\", name);\r\n\r\n        switch (getValue(map, \"type\", \"region\")) {\r\n            case \"region\": {\r\n                let path = getValue(map, \"path\", name);\r\n                let region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n                if (!region) return null;\r\n                region.path = path;\r\n                region.x = getValue(map, \"x\", 0) * scale;\r\n                region.y = getValue(map, \"y\", 0) * scale;\r\n                region.scaleX = getValue(map, \"scaleX\", 1);\r\n                region.scaleY = getValue(map, \"scaleY\", 1);\r\n                region.rotation = getValue(map, \"rotation\", 0);\r\n                region.width = map.width * scale;\r\n                region.height = map.height * scale;\r\n\r\n                let color: string = getValue(map, \"color\", null);\r\n                if (color) region.color.setFromString(color);\r\n\r\n                // region.updateOffset();\r\n                return region;\r\n            }\r\n            case \"boundingbox\": {\r\n                let box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n                if (!box) return null;\r\n                this.readVertices(map, box, map.vertexCount << 1);\r\n                let color: string = getValue(map, \"color\", null);\r\n                if (color) box.color.setFromString(color);\r\n                return box;\r\n            }\r\n            case \"mesh\":\r\n            case \"linkedmesh\": {\r\n                let path = getValue(map, \"path\", name);\r\n                let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n                if (!mesh) return null;\r\n                mesh.path = path;\r\n\r\n                let color = getValue(map, \"color\", null);\r\n                if (color) mesh.color.setFromString(color);\r\n\r\n                mesh.width = getValue(map, \"width\", 0) * scale;\r\n                mesh.height = getValue(map, \"height\", 0) * scale;\r\n\r\n                let parent: string = getValue(map, \"parent\", null);\r\n                if (parent) {\r\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string> getValue(map, \"skin\", null), slotIndex, parent, getValue(map, \"deform\", true)));\r\n                    return mesh;\r\n                }\r\n\r\n                let uvs: Array<number> = map.uvs;\r\n                this.readVertices(map, mesh, uvs.length);\r\n                mesh.triangles = map.triangles;\r\n                mesh.regionUVs = new Float32Array(uvs);\r\n                // mesh.updateUVs();\r\n\r\n                mesh.edges = getValue(map, \"edges\", null);\r\n                mesh.hullLength = getValue(map, \"hull\", 0) * 2;\r\n                return mesh;\r\n            }\r\n            case \"path\": {\r\n                let path = this.attachmentLoader.newPathAttachment(skin, name);\r\n                if (!path) return null;\r\n                path.closed = getValue(map, \"closed\", false);\r\n                path.constantSpeed = getValue(map, \"constantSpeed\", true);\r\n\r\n                let vertexCount = map.vertexCount;\r\n                this.readVertices(map, path, vertexCount << 1);\r\n\r\n                let lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\r\n                for (let i = 0; i < map.lengths.length; i++)\r\n                    lengths[i] = map.lengths[i] * scale;\r\n                path.lengths = lengths;\r\n\r\n                let color: string = getValue(map, \"color\", null);\r\n                if (color) path.color.setFromString(color);\r\n                return path;\r\n            }\r\n            case \"point\": {\r\n                let point = this.attachmentLoader.newPointAttachment(skin, name);\r\n                if (!point) return null;\r\n                point.x = getValue(map, \"x\", 0) * scale;\r\n                point.y = getValue(map, \"y\", 0) * scale;\r\n                point.rotation = getValue(map, \"rotation\", 0);\r\n\r\n                let color = getValue(map, \"color\", null);\r\n                if (color) point.color.setFromString(color);\r\n                return point;\r\n            }\r\n            case \"clipping\": {\r\n                let clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n                if (!clip) return null;\r\n\r\n                let end = getValue(map, \"end\", null);\r\n                if (end != null) {\r\n                    let slot = skeletonData.findSlot(end);\r\n                    if (slot == null) throw new Error(\"Clipping end slot not found: \" + end);\r\n                    clip.endSlot = slot;\r\n                }\r\n\r\n                let vertexCount = map.vertexCount;\r\n                this.readVertices(map, clip, vertexCount << 1);\r\n\r\n                let color: string = getValue(map, \"color\", null);\r\n                if (color) clip.color.setFromString(color);\r\n                return clip;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    readVertices (map: any, attachment: VertexAttachment, verticesLength: number) {\r\n        let scale = this.scale;\r\n        attachment.worldVerticesLength = verticesLength;\r\n        let vertices: Array<number> = map.vertices;\r\n        if (verticesLength == vertices.length) {\r\n            let scaledVertices = Utils.toFloatArray(vertices);\r\n            if (scale != 1) {\r\n                for (let i = 0, n = vertices.length; i < n; i++)\r\n                    scaledVertices[i] *= scale;\r\n            }\r\n            attachment.vertices = scaledVertices;\r\n            return;\r\n        }\r\n        let weights = new Array<number>();\r\n        let bones = new Array<number>();\r\n        for (let i = 0, n = vertices.length; i < n;) {\r\n            let boneCount = vertices[i++];\r\n            bones.push(boneCount);\r\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\r\n                bones.push(vertices[i]);\r\n                weights.push(vertices[i + 1] * scale);\r\n                weights.push(vertices[i + 2] * scale);\r\n                weights.push(vertices[i + 3]);\r\n            }\r\n        }\r\n        attachment.bones = bones;\r\n        attachment.vertices = Utils.toFloatArray(weights);\r\n    }\r\n\r\n    readAnimation (map: any, name: string, skeletonData: SkeletonData) {\r\n        let scale = this.scale;\r\n        let timelines = new Array<Timeline>();\r\n\r\n        // Slot timelines.\r\n        if (map.slots) {\r\n            for (let slotName in map.slots) {\r\n                let slotMap = map.slots[slotName];\r\n                let slotIndex = skeletonData.findSlotIndex(slotName);\r\n                if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\r\n                for (let timelineName in slotMap) {\r\n                    let timelineMap = slotMap[timelineName];\r\n                    if (!timelineMap) continue;\r\n                    if (timelineName == \"attachment\") {\r\n                        let timeline = new AttachmentTimeline(timelineMap.length, slotIndex);\r\n                        for (let frame = 0; frame < timelineMap.length; frame++) {\r\n                            let keyMap = timelineMap[frame];\r\n                            timeline.setFrame(frame, getValue(keyMap, \"time\", 0), keyMap.name);\r\n                        }\r\n                        timelines.push(timeline);\r\n\r\n                    } else if (timelineName == \"rgba\") {\r\n                        let timeline = new RGBATimeline(timelineMap.length, timelineMap.length << 2, slotIndex);\r\n                        let keyMap = timelineMap[0];\r\n                        let time = getValue(keyMap, \"time\", 0);\r\n                        let color = Color.fromString(keyMap.color);\r\n\r\n                        for (let frame = 0, bezier = 0;; frame++) {\r\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color.a);\r\n                            let nextMap = timelineMap[frame + 1];\r\n                            if (!nextMap)  {\r\n                                timeline.shrink(bezier);\r\n                                break;\r\n                            }\r\n                            let time2 = getValue(nextMap, \"time\", 0);\r\n                            let newColor = Color.fromString(nextMap.color);\r\n                            let curve = keyMap.curve;\r\n                            if (curve) {\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\r\n                            }\r\n                            time = time2;\r\n                            color = newColor;\r\n                            keyMap = nextMap;\r\n                        }\r\n\r\n                        timelines.push(timeline);\r\n\r\n                    } else if (timelineName == \"rgb\") {\r\n                        let timeline = new RGBTimeline(timelineMap.length, timelineMap.length * 3, slotIndex);\r\n                        let keyMap = timelineMap[0];\r\n                        let time = getValue(keyMap, \"time\", 0);\r\n                        let color = Color.fromString(keyMap.color);\r\n\r\n                        for (let frame = 0, bezier = 0;; frame++) {\r\n                            timeline.setFrame(frame, time, color.r, color.g, color.b);\r\n                            let nextMap = timelineMap[frame + 1];\r\n                            if (!nextMap)  {\r\n                                timeline.shrink(bezier);\r\n                                break;\r\n                            }\r\n                            let time2 = getValue(nextMap, \"time\", 0);\r\n                            let newColor = Color.fromString(nextMap.color);\r\n                            let curve = keyMap.curve;\r\n                            if (curve) {\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\r\n                            }\r\n                            time = time2;\r\n                            color = newColor;\r\n                            keyMap = nextMap;\r\n                        }\r\n\r\n                        timelines.push(timeline);\r\n\r\n                    } else if (timelineName == \"alpha\") {\r\n                        timelines.push(readTimeline1(timelineMap, new AlphaTimeline(timelineMap.length, timelineMap.length, slotIndex), 0, 1));\r\n                    } else if (timelineName == \"rgba2\") {\r\n                        let timeline = new RGBA2Timeline(timelineMap.length, timelineMap.length * 7, slotIndex);\r\n\r\n                        let keyMap = timelineMap[0];\r\n                        let time = getValue(keyMap, \"time\", 0);\r\n                        let color = Color.fromString(keyMap.light);\r\n                        let color2 = Color.fromString(keyMap.dark);\r\n\r\n                        for (let frame = 0, bezier = 0;; frame++) {\r\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color.a, color2.r, color2.g, color2.b);\r\n                            let nextMap = timelineMap[frame + 1];\r\n                            if (!nextMap)  {\r\n                                timeline.shrink(bezier);\r\n                                break;\r\n                            }\r\n                            let time2 = getValue(nextMap, \"time\", 0);\r\n                            let newColor = Color.fromString(nextMap.light);\r\n                            let newColor2 = Color.fromString(nextMap.dark);\r\n                            let curve = keyMap.curve;\r\n                            if (curve) {\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.r, newColor2.r, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.g, newColor2.g, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 6, time, time2, color2.b, newColor2.b, 1);\r\n                            }\r\n                            time = time2;\r\n                            color = newColor;\r\n                            color2 = newColor2;\r\n                            keyMap = nextMap;\r\n                        }\r\n\r\n                        timelines.push(timeline);\r\n\r\n                    } else if (timelineName == \"rgb2\") {\r\n                        let timeline = new RGB2Timeline(timelineMap.length, timelineMap.length * 6, slotIndex);\r\n\r\n                        let keyMap = timelineMap[0];\r\n                        let time = getValue(keyMap, \"time\", 0);\r\n                        let color = Color.fromString(keyMap.light);\r\n                        let color2 = Color.fromString(keyMap.dark);\r\n\r\n                        for (let frame = 0, bezier = 0;; frame++) {\r\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color2.r, color2.g, color2.b);\r\n                            let nextMap = timelineMap[frame + 1];\r\n                            if (!nextMap)  {\r\n                                timeline.shrink(bezier);\r\n                                break;\r\n                            }\r\n                            let time2 = getValue(nextMap, \"time\", 0);\r\n                            let newColor = Color.fromString(nextMap.light);\r\n                            let newColor2 = Color.fromString(nextMap.dark);\r\n                            let curve = keyMap.curve;\r\n                            if (curve) {\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color2.r, newColor2.r, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.g, newColor2.g, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.b, newColor2.b, 1);\r\n                            }\r\n                            time = time2;\r\n                            color = newColor;\r\n                            color2 = newColor2;\r\n                            keyMap = nextMap;\r\n                        }\r\n\r\n                        timelines.push(timeline);\r\n                    } else\r\n                        throw new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bone timelines.\r\n        if (map.bones) {\r\n            for (let boneName in map.bones) {\r\n                let boneMap = map.bones[boneName];\r\n                let boneIndex = skeletonData.findBoneIndex(boneName);\r\n                if (boneIndex == -1) throw new Error(\"Bone not found: \" + boneName);\r\n                for (let timelineName in boneMap) {\r\n                    let timelineMap = boneMap[timelineName];\r\n                    if (timelineMap.length == 0) continue;\r\n\r\n                    if (timelineName === \"rotate\") {\r\n                        timelines.push(readTimeline1(timelineMap, new RotateTimeline(timelineMap.length, timelineMap.length, boneIndex), 0, 1));\r\n                    } else if (timelineName === \"translate\") {\r\n                        let timeline = new TranslateTimeline(timelineMap.length, timelineMap.length << 1, boneIndex);\r\n                        timelines.push(readTimeline2(timelineMap, timeline, \"x\", \"y\", 0, scale));\r\n                    } else if (timelineName === \"translatex\") {\r\n                        let timeline = new TranslateXTimeline(timelineMap.length, timelineMap.length, boneIndex);\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\r\n                    } else if (timelineName === \"translatey\") {\r\n                        let timeline = new TranslateYTimeline(timelineMap.length, timelineMap.length, boneIndex);\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\r\n                    } else if (timelineName === \"scale\") {\r\n                        let timeline = new ScaleTimeline(timelineMap.length, timelineMap.length << 1, boneIndex);\r\n                        timelines.push(readTimeline2(timelineMap, timeline, \"x\", \"y\", 1, 1));\r\n                    } else if (timelineName === \"scalex\") {\r\n                        let timeline = new ScaleXTimeline(timelineMap.length, timelineMap.length, boneIndex);\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\r\n                    } else if (timelineName === \"scaley\") {\r\n                        let timeline = new ScaleYTimeline(timelineMap.length, timelineMap.length, boneIndex);\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\r\n                    } else if (timelineName === \"shear\") {\r\n                        let timeline = new ShearTimeline(timelineMap.length, timelineMap.length << 1, boneIndex);\r\n                        timelines.push(readTimeline2(timelineMap, timeline, \"x\", \"y\", 0, 1));\r\n                    } else if (timelineName === \"shearx\") {\r\n                        let timeline = new ShearXTimeline(timelineMap.length, timelineMap.length, boneIndex);\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\r\n                    } else if (timelineName === \"sheary\") {\r\n                        let timeline = new ShearYTimeline(timelineMap.length, timelineMap.length, boneIndex);\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // IK constraint timelines.\r\n        if (map.ik) {\r\n            for (let constraintName in map.ik) {\r\n                let constraintMap = map.ik[constraintName];\r\n                let keyMap = constraintMap[0];\r\n                if (!keyMap) continue;\r\n\r\n                let constraint = skeletonData.findIkConstraint(constraintName);\r\n                let constraintIndex = skeletonData.ikConstraints.indexOf(constraint);\r\n                let timeline = new IkConstraintTimeline(constraintMap.length, constraintMap.length << 1, constraintIndex);\r\n\r\n                let time = getValue(keyMap, \"time\", 0);\r\n                let mix = getValue(keyMap, \"mix\", 1);\r\n                let softness = getValue(keyMap, \"softness\", 0) * scale;\r\n\r\n                for (let frame = 0, bezier = 0;; frame++) {\r\n                    timeline.setFrame(frame, time, mix, softness, getValue(keyMap, \"bendPositive\", true) ? 1 : -1, getValue(keyMap, \"compress\", false), getValue(keyMap, \"stretch\", false));\r\n                    let nextMap = constraintMap[frame + 1];\r\n                    if (!nextMap) {\r\n                        timeline.shrink(bezier);\r\n                        break;\r\n                    }\r\n\r\n                    let time2 = getValue(nextMap, \"time\", 0);\r\n                    let mix2 = getValue(nextMap, \"mix\", 1);\r\n                    let softness2 = getValue(nextMap, \"softness\", 0) * scale;\r\n                    let curve = keyMap.curve;\r\n                    if (curve) {\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mix, mix2, 1);\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, softness, softness2, scale);\r\n                    }\r\n\r\n                    time = time2;\r\n                    mix = mix2;\r\n                    softness = softness2;\r\n                    keyMap = nextMap;\r\n                }\r\n                timelines.push(timeline);\r\n            }\r\n        }\r\n\r\n        // Transform constraint timelines.\r\n        if (map.transform) {\r\n            for (let constraintName in map.transform) {\r\n                let timelineMap = map.transform[constraintName];\r\n                let keyMap = timelineMap[0];\r\n                if (!keyMap) continue;\r\n\r\n                let constraint = skeletonData.findTransformConstraint(constraintName);\r\n                let constraintIndex = skeletonData.transformConstraints.indexOf(constraint);\r\n                let timeline = new TransformConstraintTimeline(timelineMap.length, timelineMap.length << 2, constraintIndex);\r\n\r\n                let time = getValue(keyMap, \"time\", 0);\r\n                let mixRotate = getValue(keyMap, \"mixRotate\", 1);\r\n                let mixX = getValue(keyMap, \"mixX\", 1);\r\n                let mixY = getValue(keyMap, \"mixY\", mixX);\r\n                let mixScaleX = getValue(keyMap, \"mixScaleX\", 1);\r\n                let mixScaleY = getValue(keyMap, \"mixScaleY\", mixScaleX);\r\n                let mixShearY = getValue(keyMap, \"mixShearY\", 1);\r\n\r\n                for (let frame = 0, bezier = 0;; frame++) {\r\n                    timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\r\n                    let nextMap = timelineMap[frame + 1];\r\n                    if (!nextMap) {\r\n                        timeline.shrink(bezier);\r\n                        break;\r\n                    }\r\n\r\n                    let time2 = getValue(nextMap, \"time\", 0);\r\n                    let mixRotate2 = getValue(nextMap, \"mixRotate\", 1);\r\n                    let mixX2 = getValue(nextMap, \"mixX\", 1);\r\n                    let mixY2 = getValue(nextMap, \"mixY\", mixX2);\r\n                    let mixScaleX2 = getValue(nextMap, \"mixScaleX\", 1);\r\n                    let mixScaleY2 = getValue(nextMap, \"mixScaleY\", mixScaleX2);\r\n                    let mixShearY2 = getValue(nextMap, \"mixShearY\", 1);\r\n                    let curve = keyMap.curve;\r\n                    if (curve) {\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, mixShearY, mixShearY2, 1);\r\n                    }\r\n\r\n                    time = time2;\r\n                    mixRotate = mixRotate2;\r\n                    mixX = mixX2;\r\n                    mixY = mixY2;\r\n                    mixScaleX = mixScaleX2;\r\n                    mixScaleY = mixScaleY2;\r\n                    mixScaleX = mixScaleX2;\r\n                    keyMap = nextMap;\r\n                }\r\n                timelines.push(timeline);\r\n            }\r\n        }\r\n\r\n        // Path constraint timelines.\r\n        if (map.path) {\r\n            for (let constraintName in map.path) {\r\n                let constraintMap = map.path[constraintName];\r\n                let constraintIndex = skeletonData.findPathConstraintIndex(constraintName);\r\n                if (constraintIndex == -1) throw new Error(\"Path constraint not found: \" + constraintName);\r\n                let constraint = skeletonData.pathConstraints[constraintIndex];\r\n                for (let timelineName in constraintMap) {\r\n                    let timelineMap = constraintMap[timelineName];\r\n                    let keyMap = timelineMap[0];\r\n                    if (!keyMap) continue;\r\n\r\n                    if (timelineName === \"position\") {\r\n                        let timeline = new PathConstraintPositionTimeline(timelineMap.length, timelineMap.length, constraintIndex);\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, constraint.positionMode == PositionMode.Fixed ? scale : 1));\r\n                    } else if (timelineName === \"spacing\") {\r\n                        let timeline = new PathConstraintSpacingTimeline(timelineMap.length, timelineMap.length, constraintIndex);\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, constraint.spacingMode == SpacingMode.Length || constraint.spacingMode == SpacingMode.Fixed ? scale : 1));\r\n                    } else if (timelineName === \"mix\") {\r\n                        let timeline = new PathConstraintMixTimeline(timelineMap.size, timelineMap.size * 3, constraintIndex);\r\n                        let time = getValue(keyMap, \"time\", 0);\r\n                        let mixRotate = getValue(keyMap, \"mixRotate\", 1);\r\n                        let mixX = getValue(keyMap, \"mixX\", 1);\r\n                        let mixY = getValue(keyMap, \"mixY\", mixX);\r\n                        for (let frame = 0, bezier = 0;; frame++) {\r\n                            timeline.setFrame(frame, time, mixRotate, mixX, mixY);\r\n                            let nextMap = timelineMap[frame + 1];\r\n                            if (!nextMap) {\r\n                                timeline.shrink(bezier);\r\n                                break;\r\n                            }\r\n                            let time2 = getValue(nextMap, \"time\", 0);\r\n                            let mixRotate2 = getValue(nextMap, \"mixRotate\", 1);\r\n                            let mixX2 = getValue(nextMap, \"mixX\", 1);\r\n                            let mixY2 = getValue(nextMap, \"mixY\", mixX2);\r\n                            let curve = keyMap.curve;\r\n                            if (curve) {\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\r\n                            }\r\n                            time = time2;\r\n                            mixRotate = mixRotate2;\r\n                            mixX = mixX2;\r\n                            mixY = mixY2;\r\n                            keyMap = nextMap;\r\n                        }\r\n                        timelines.push(timeline);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Deform timelines.\r\n        if (map.deform) {\r\n            for (let deformName in map.deform) {\r\n                let deformMap = map.deform[deformName];\r\n                let skin = skeletonData.findSkin(deformName);\r\n                if (skin == null) {\r\n                   if (settings.FAIL_ON_NON_EXISTING_SKIN) {\r\n                       throw new Error(\"Skin not found: \" + deformName);\r\n                   } else {\r\n                       continue;\r\n                   }\r\n                }\r\n                for (let slotName in deformMap) {\r\n                    let slotMap = deformMap[slotName];\r\n                    let slotIndex = skeletonData.findSlotIndex(slotName);\r\n                    if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotMap.name);\r\n                    for (let timelineName in slotMap) {\r\n                        let timelineMap = slotMap[timelineName];\r\n                        let keyMap = timelineMap[0];\r\n                        if (!keyMap) continue;\r\n\r\n                        let attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\r\n                        if (attachment == null) throw new Error(\"Deform attachment not found: \" + timelineMap.name);\r\n                        let weighted = attachment.bones != null;\r\n                        let vertices = attachment.vertices;\r\n                        let deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n\r\n                        let timeline = new DeformTimeline(timelineMap.length, timelineMap.length, slotIndex, attachment);\r\n                        let time = getValue(keyMap, \"time\", 0);\r\n                        for (let frame = 0, bezier = 0;; frame++) {\r\n                            let deform: ArrayLike<number>;\r\n                            let verticesValue: Array<Number> = getValue(keyMap, \"vertices\", null);\r\n                            if (!verticesValue)\r\n                                deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\r\n                            else {\r\n                                deform = Utils.newFloatArray(deformLength);\r\n                                let start = <number>getValue(keyMap, \"offset\", 0);\r\n                                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\r\n                                if (scale != 1) {\r\n                                    for (let i = start, n = i + verticesValue.length; i < n; i++)\r\n                                        deform[i] *= scale;\r\n                                }\r\n                                if (!weighted) {\r\n                                    for (let i = 0; i < deformLength; i++)\r\n                                        deform[i] += vertices[i];\r\n                                }\r\n                            }\r\n\r\n                            timeline.setFrame(frame, time, deform);\r\n                            let nextMap = timelineMap[frame + 1];\r\n                            if (!nextMap) {\r\n                                timeline.shrink(bezier);\r\n                                break;\r\n                            }\r\n                            let time2 = getValue(nextMap, \"time\", 0);\r\n                            let curve = keyMap.curve;\r\n                            if (curve) bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, 0, 1, 1);\r\n                            time = time2;\r\n                            keyMap = nextMap;\r\n                        }\r\n                        timelines.push(timeline);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Draw order timelines.\r\n        if (map.drawOrder) {\r\n            let timeline = new DrawOrderTimeline(map.drawOrder.length);\r\n            let slotCount = skeletonData.slots.length;\r\n            let frame = 0;\r\n            for (let i = 0; i < map.drawOrder.length; i++, frame++) {\r\n                let drawOrderMap = map.drawOrder[i];\r\n                let drawOrder: Array<number> = null;\r\n                let offsets = getValue(drawOrderMap, \"offsets\", null);\r\n                if (offsets) {\r\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\r\n                    let unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\r\n                    let originalIndex = 0, unchangedIndex = 0;\r\n                    for (let ii = 0; ii < offsets.length; ii++) {\r\n                        let offsetMap = offsets[ii];\r\n                        let slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\r\n                        // Collect unchanged items.\r\n                        while (originalIndex != slotIndex)\r\n                            unchanged[unchangedIndex++] = originalIndex++;\r\n                        // Set changed items.\r\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\r\n                    }\r\n                    // Collect remaining unchanged items.\r\n                    while (originalIndex < slotCount)\r\n                        unchanged[unchangedIndex++] = originalIndex++;\r\n                    // Fill in unchanged items.\r\n                    for (let ii = slotCount - 1; ii >= 0; ii--)\r\n                        if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\r\n                }\r\n                timeline.setFrame(frame, getValue(drawOrderMap, \"time\", 0), drawOrder);\r\n            }\r\n            timelines.push(timeline);\r\n        }\r\n\r\n        // Event timelines.\r\n        if (map.events) {\r\n            let timeline = new EventTimeline(map.events.length);\r\n            let frame = 0;\r\n            for (let i = 0; i < map.events.length; i++, frame++) {\r\n                let eventMap = map.events[i];\r\n                let eventData = skeletonData.findEvent(eventMap.name);\r\n                let event = new Event(Utils.toSinglePrecision(getValue(eventMap, \"time\", 0)), eventData);\r\n                event.intValue = getValue(eventMap, \"int\", eventData.intValue);\r\n                event.floatValue = getValue(eventMap, \"float\", eventData.floatValue);\r\n                event.stringValue = getValue(eventMap, \"string\", eventData.stringValue);\r\n                if (event.data.audioPath) {\r\n                    event.volume = getValue(eventMap, \"volume\", 1);\r\n                    event.balance = getValue(eventMap, \"balance\", 0);\r\n                }\r\n                timeline.setFrame(frame, event);\r\n            }\r\n            timelines.push(timeline);\r\n        }\r\n\r\n        let duration = 0;\r\n        for (let i = 0, n = timelines.length; i < n; i++)\r\n            duration = Math.max(duration, timelines[i].getDuration());\r\n        if (isNaN(duration)) {\r\n            throw new Error(\"Error while parsing animation, duration is NaN\");\r\n        }\r\n\r\n        skeletonData.animations.push(new Animation(name, timelines, duration));\r\n    }\r\n    static blendModeFromString (str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == \"normal\") return BLEND_MODES.NORMAL;\r\n        if (str == \"additive\") return BLEND_MODES.ADD;\r\n        if (str == \"multiply\") return BLEND_MODES.MULTIPLY;\r\n        if (str == \"screen\") return BLEND_MODES.SCREEN;\r\n        throw new Error(`Unknown blend mode: ${str}`);\r\n    }\r\n}\r\n\r\nclass LinkedMesh {\r\n    parent: string; skin: string;\r\n    slotIndex: number;\r\n    mesh: MeshAttachment;\r\n    inheritDeform: boolean;\r\n\r\n    constructor (mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\r\n        this.mesh = mesh;\r\n        this.skin = skin;\r\n        this.slotIndex = slotIndex;\r\n        this.parent = parent;\r\n        this.inheritDeform = inheritDeform;\r\n    }\r\n}\r\n\r\nfunction readTimeline1 (keys: any[], timeline: CurveTimeline1, defaultValue: number, scale: number) {\r\n    let keyMap = keys[0];\r\n    let time = getValue(keyMap, \"time\", 0);\r\n    let value = getValue(keyMap, \"value\", defaultValue) * scale;\r\n    let bezier = 0;\r\n    for (let frame = 0;; frame++) {\r\n        timeline.setFrame(frame, time, value);\r\n        let nextMap = keys[frame + 1];\r\n        if (!nextMap) {\r\n            timeline.shrink(bezier);\r\n            return timeline;\r\n        }\r\n        let time2 = getValue(nextMap, \"time\", 0);\r\n        let value2 = getValue(nextMap, \"value\", defaultValue) * scale;\r\n        if (keyMap.curve) bezier = readCurve(keyMap.curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);\r\n        time = time2;\r\n        value = value2;\r\n        keyMap = nextMap;\r\n    }\r\n}\r\n\r\nfunction readTimeline2 (keys: any[], timeline: CurveTimeline2, name1: string, name2: string, defaultValue: number, scale: number) {\r\n    let keyMap = keys[0];\r\n    let time = getValue(keyMap, \"time\", 0);\r\n    let value1 = getValue(keyMap, name1, defaultValue) * scale;\r\n    let value2 = getValue(keyMap, name2, defaultValue) * scale;\r\n    let bezier = 0;\r\n    for (let frame = 0;; frame++) {\r\n        timeline.setFrame(frame, time, value1, value2);\r\n        let nextMap = keys[frame + 1];\r\n        if (!nextMap) {\r\n            timeline.shrink(bezier);\r\n            return timeline;\r\n        }\r\n        let time2 = getValue(nextMap, \"time\", 0);\r\n        let nvalue1 = getValue(nextMap, name1, defaultValue) * scale;\r\n        let nvalue2 = getValue(nextMap, name2, defaultValue) * scale;\r\n        let curve = keyMap.curve;\r\n        if (curve) {\r\n            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);\r\n            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);\r\n        }\r\n        time = time2;\r\n        value1 = nvalue1;\r\n        value2 = nvalue2;\r\n        keyMap = nextMap;\r\n    }\r\n}\r\n\r\nfunction readCurve (curve: any, timeline: CurveTimeline, bezier: number, frame: number, value: number, time1: number, time2: number,\r\n                    value1: number, value2: number, scale: number) {\r\n    if (curve == \"stepped\") {\r\n        timeline.setStepped(frame);\r\n        return bezier;\r\n    }\r\n    let i = value << 2;\r\n    let cx1 = curve[i];\r\n    let cy1 = curve[i + 1] * scale;\r\n    let cx2 = curve[i + 2];\r\n    let cy2 = curve[i + 3] * scale;\r\n    timeline.setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);\r\n    return bezier + 1;\r\n}\r\n\r\nfunction getValue (map: any, property: string, defaultValue: any) {\r\n    return map[property] !== undefined ? map[property] : defaultValue;\r\n}\r\n","import {SpineBase} from '@pixi-spine/base';\r\nimport {Skeleton} from \"./core/Skeleton\";\r\nimport {SkeletonData} from \"./core/SkeletonData\";\r\nimport {AnimationState} from \"./core/AnimationState\";\r\nimport {AnimationStateData} from \"./core/AnimationStateData\";\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Spine extends SpineBase<Skeleton, SkeletonData, AnimationState, AnimationStateData> {\r\n    createSkeleton(spineData: SkeletonData) {\r\n        this.skeleton = new Skeleton(spineData);\r\n        this.skeleton.updateWorldTransform();\r\n        this.stateData = new AnimationStateData(spineData);\r\n        this.state = new AnimationState(this.stateData);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}