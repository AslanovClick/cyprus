{"ast":null,"code":"/* eslint-disable */\n\n/*!\n * @pixi-spine/base - v3.0.5\n * Compiled Wed, 14 Jul 2021 08:35:21 UTC\n *\n * @pixi-spine/base is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n * \n * Copyright 2019-2020, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved\n */\nimport { SCALE_MODES, MIPMAP_MODES, ALPHA_MODES, DRAW_MODES } from '@pixi/constants';\nimport { Texture } from '@pixi/core';\nimport { Rectangle, Transform, Polygon } from '@pixi/math';\nimport { Container } from '@pixi/display';\nimport { Sprite } from '@pixi/sprite';\nimport { SimpleMesh } from '@pixi/mesh-extras';\nimport { Graphics } from '@pixi/graphics';\nimport { rgb2hex, hex2rgb } from '@pixi/utils';\n/**\r\n * @public\r\n */\n\nvar AttachmentType;\n\n(function (AttachmentType) {\n  const Region = 0;\n  AttachmentType[AttachmentType[\"Region\"] = Region] = \"Region\";\n  const BoundingBox = Region + 1;\n  AttachmentType[AttachmentType[\"BoundingBox\"] = BoundingBox] = \"BoundingBox\";\n  const Mesh = BoundingBox + 1;\n  AttachmentType[AttachmentType[\"Mesh\"] = Mesh] = \"Mesh\";\n  const LinkedMesh = Mesh + 1;\n  AttachmentType[AttachmentType[\"LinkedMesh\"] = LinkedMesh] = \"LinkedMesh\";\n  const Path = LinkedMesh + 1;\n  AttachmentType[AttachmentType[\"Path\"] = Path] = \"Path\";\n  const Point = Path + 1;\n  AttachmentType[AttachmentType[\"Point\"] = Point] = \"Point\";\n  const Clipping = Point + 1;\n  AttachmentType[AttachmentType[\"Clipping\"] = Clipping] = \"Clipping\";\n})(AttachmentType || (AttachmentType = {}));\n/**\r\n * @public\r\n */\n\n\nclass BinaryInput {\n  constructor(data, strings = new Array(), index = 0, buffer = new DataView(data.buffer)) {\n    this.strings = strings;\n    this.index = index;\n    this.buffer = buffer;\n  }\n\n  readByte() {\n    return this.buffer.getInt8(this.index++);\n  }\n\n  readUnsignedByte() {\n    return this.buffer.getUint8(this.index++);\n  }\n\n  readShort() {\n    let value = this.buffer.getInt16(this.index);\n    this.index += 2;\n    return value;\n  }\n\n  readInt32() {\n    let value = this.buffer.getInt32(this.index);\n    this.index += 4;\n    return value;\n  }\n\n  readInt(optimizePositive) {\n    let b = this.readByte();\n    let result = b & 0x7F;\n\n    if ((b & 0x80) != 0) {\n      b = this.readByte();\n      result |= (b & 0x7F) << 7;\n\n      if ((b & 0x80) != 0) {\n        b = this.readByte();\n        result |= (b & 0x7F) << 14;\n\n        if ((b & 0x80) != 0) {\n          b = this.readByte();\n          result |= (b & 0x7F) << 21;\n\n          if ((b & 0x80) != 0) {\n            b = this.readByte();\n            result |= (b & 0x7F) << 28;\n          }\n        }\n      }\n    }\n\n    return optimizePositive ? result : result >>> 1 ^ -(result & 1);\n  }\n\n  readStringRef() {\n    let index = this.readInt(true);\n    return index == 0 ? null : this.strings[index - 1];\n  }\n\n  readString() {\n    let byteCount = this.readInt(true);\n\n    switch (byteCount) {\n      case 0:\n        return null;\n\n      case 1:\n        return \"\";\n    }\n\n    byteCount--;\n    let chars = \"\";\n\n    for (let i = 0; i < byteCount;) {\n      let b = this.readByte();\n\n      switch (b >> 4) {\n        case 12:\n        case 13:\n          chars += String.fromCharCode((b & 0x1F) << 6 | this.readByte() & 0x3F);\n          i += 2;\n          break;\n\n        case 14:\n          chars += String.fromCharCode((b & 0x0F) << 12 | (this.readByte() & 0x3F) << 6 | this.readByte() & 0x3F);\n          i += 3;\n          break;\n\n        default:\n          chars += String.fromCharCode(b);\n          i++;\n      }\n    }\n\n    return chars;\n  }\n\n  readFloat() {\n    let value = this.buffer.getFloat32(this.index);\n    this.index += 4;\n    return value;\n  }\n\n  readBoolean() {\n    return this.readByte() != 0;\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nfunction filterFromString(text) {\n  switch (text.toLowerCase()) {\n    case \"nearest\":\n      return TextureFilter.Nearest;\n\n    case \"linear\":\n      return TextureFilter.Linear;\n\n    case \"mipmap\":\n      return TextureFilter.MipMap;\n\n    case \"mipmapnearestnearest\":\n      return TextureFilter.MipMapNearestNearest;\n\n    case \"mipmaplinearnearest\":\n      return TextureFilter.MipMapLinearNearest;\n\n    case \"mipmapnearestlinear\":\n      return TextureFilter.MipMapNearestLinear;\n\n    case \"mipmaplinearlinear\":\n      return TextureFilter.MipMapLinearLinear;\n\n    default:\n      throw new Error(`Unknown texture filter ${text}`);\n  }\n}\n/**\r\n * @public\r\n */\n\n\nfunction wrapFromString(text) {\n  switch (text.toLowerCase()) {\n    case \"mirroredtepeat\":\n      return TextureWrap.MirroredRepeat;\n\n    case \"clamptoedge\":\n      return TextureWrap.ClampToEdge;\n\n    case \"repeat\":\n      return TextureWrap.Repeat;\n\n    default:\n      throw new Error(`Unknown texture wrap ${text}`);\n  }\n}\n/**\r\n * @public\r\n */\n\n\nvar TextureFilter;\n\n(function (TextureFilter) {\n  const Nearest = 9728;\n  TextureFilter[TextureFilter[\"Nearest\"] = Nearest] = \"Nearest\"; // WebGLRenderingContext.NEAREST\n\n  const Linear = 9729;\n  TextureFilter[TextureFilter[\"Linear\"] = Linear] = \"Linear\"; // WebGLRenderingContext.LINEAR\n\n  const MipMap = 9987;\n  TextureFilter[TextureFilter[\"MipMap\"] = MipMap] = \"MipMap\"; // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\n\n  const MipMapNearestNearest = 9984;\n  TextureFilter[TextureFilter[\"MipMapNearestNearest\"] = MipMapNearestNearest] = \"MipMapNearestNearest\"; // WebGLRenderingContext.NEAREST_MIPMAP_NEAREST\n\n  const MipMapLinearNearest = 9985;\n  TextureFilter[TextureFilter[\"MipMapLinearNearest\"] = MipMapLinearNearest] = \"MipMapLinearNearest\"; // WebGLRenderingContext.LINEAR_MIPMAP_NEAREST\n\n  const MipMapNearestLinear = 9986;\n  TextureFilter[TextureFilter[\"MipMapNearestLinear\"] = MipMapNearestLinear] = \"MipMapNearestLinear\"; // WebGLRenderingContext.NEAREST_MIPMAP_LINEAR\n\n  const MipMapLinearLinear = 9987;\n  TextureFilter[TextureFilter[\"MipMapLinearLinear\"] = MipMapLinearLinear] = \"MipMapLinearLinear\"; // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\n})(TextureFilter || (TextureFilter = {}));\n/**\r\n * @public\r\n */\n\n\nvar TextureWrap;\n\n(function (TextureWrap) {\n  const MirroredRepeat = 33648;\n  TextureWrap[TextureWrap[\"MirroredRepeat\"] = MirroredRepeat] = \"MirroredRepeat\"; // WebGLRenderingContext.MIRRORED_REPEAT\n\n  const ClampToEdge = 33071;\n  TextureWrap[TextureWrap[\"ClampToEdge\"] = ClampToEdge] = \"ClampToEdge\"; // WebGLRenderingContext.CLAMP_TO_EDGE\n\n  const Repeat = 10497;\n  TextureWrap[TextureWrap[\"Repeat\"] = Repeat] = \"Repeat\"; // WebGLRenderingContext.REPEAT\n})(TextureWrap || (TextureWrap = {}));\n/**\r\n * @public\r\n */\n\n\nclass TextureRegion {\n  constructor() {\n    TextureRegion.prototype.__init.call(this);\n\n    TextureRegion.prototype.__init2.call(this);\n\n    TextureRegion.prototype.__init3.call(this);\n  } //thats for overrides\n\n\n  __init() {\n    this.size = null;\n  }\n\n  __init2() {\n    this.names = null;\n  }\n\n  __init3() {\n    this.values = null;\n  }\n\n  get width() {\n    const tex = this.texture;\n\n    if (tex.trim) {\n      return tex.trim.width;\n    }\n\n    return tex.orig.width;\n  }\n\n  get height() {\n    const tex = this.texture;\n\n    if (tex.trim) {\n      return tex.trim.height;\n    }\n\n    return tex.orig.height;\n  }\n\n  get u() {\n    return this.texture._uvs.x0;\n  }\n\n  get v() {\n    return this.texture._uvs.y0;\n  }\n\n  get u2() {\n    return this.texture._uvs.x2;\n  }\n\n  get v2() {\n    return this.texture._uvs.y2;\n  }\n\n  get offsetX() {\n    const tex = this.texture;\n    return tex.trim ? tex.trim.x : 0;\n  }\n\n  get offsetY() {\n    // console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\n    return this.spineOffsetY;\n  }\n\n  get pixiOffsetY() {\n    const tex = this.texture;\n    return tex.trim ? tex.trim.y : 0;\n  }\n\n  get spineOffsetY() {\n    let tex = this.texture;\n    return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\n  }\n\n  get originalWidth() {\n    return this.texture.orig.width;\n  }\n\n  get originalHeight() {\n    return this.texture.orig.height;\n  }\n\n  get x() {\n    return this.texture.frame.x;\n  }\n\n  get y() {\n    return this.texture.frame.y;\n  }\n\n  get rotate() {\n    return this.texture.rotate !== 0;\n  }\n\n  get degrees() {\n    return (360 - this.texture.rotate * 45) % 360;\n  }\n\n}\n\nclass RegionFields {\n  constructor() {\n    RegionFields.prototype.__init.call(this);\n\n    RegionFields.prototype.__init2.call(this);\n\n    RegionFields.prototype.__init3.call(this);\n\n    RegionFields.prototype.__init4.call(this);\n\n    RegionFields.prototype.__init5.call(this);\n\n    RegionFields.prototype.__init6.call(this);\n\n    RegionFields.prototype.__init7.call(this);\n\n    RegionFields.prototype.__init8.call(this);\n\n    RegionFields.prototype.__init9.call(this);\n\n    RegionFields.prototype.__init10.call(this);\n  }\n\n  __init() {\n    this.x = 0;\n  }\n\n  __init2() {\n    this.y = 0;\n  }\n\n  __init3() {\n    this.width = 0;\n  }\n\n  __init4() {\n    this.height = 0;\n  }\n\n  __init5() {\n    this.offsetX = 0;\n  }\n\n  __init6() {\n    this.offsetY = 0;\n  }\n\n  __init7() {\n    this.originalWidth = 0;\n  }\n\n  __init8() {\n    this.originalHeight = 0;\n  }\n\n  __init9() {\n    this.rotate = 0;\n  }\n\n  __init10() {\n    this.index = 0;\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass TextureAtlas {\n  __init11() {\n    this.pages = new Array();\n  }\n\n  __init12() {\n    this.regions = new Array();\n  }\n\n  constructor(atlasText, textureLoader, callback) {\n    TextureAtlas.prototype.__init11.call(this);\n\n    TextureAtlas.prototype.__init12.call(this);\n\n    if (atlasText) {\n      this.addSpineAtlas(atlasText, textureLoader, callback);\n    }\n  }\n\n  addTexture(name, texture) {\n    let pages = this.pages;\n    let page = null;\n\n    for (let i = 0; i < pages.length; i++) {\n      if (pages[i].baseTexture === texture.baseTexture) {\n        page = pages[i];\n        break;\n      }\n    }\n\n    if (page === null) {\n      page = new TextureAtlasPage();\n      page.name = 'texturePage';\n      let baseTexture = texture.baseTexture;\n      page.width = baseTexture.realWidth;\n      page.height = baseTexture.realHeight;\n      page.baseTexture = baseTexture; //those fields are not relevant in Pixi\n\n      page.minFilter = page.magFilter = TextureFilter.Nearest;\n      page.uWrap = TextureWrap.ClampToEdge;\n      page.vWrap = TextureWrap.ClampToEdge;\n      pages.push(page);\n    }\n\n    let region = new TextureAtlasRegion();\n    region.name = name;\n    region.page = page;\n    region.texture = texture;\n    region.index = -1;\n    this.regions.push(region);\n    return region;\n  }\n\n  addTextureHash(textures, stripExtension) {\n    for (let key in textures) {\n      if (textures.hasOwnProperty(key)) {\n        this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\n      }\n    }\n  }\n\n  addSpineAtlas(atlasText, textureLoader, callback) {\n    return this.load(atlasText, textureLoader, callback);\n  }\n\n  load(atlasText, textureLoader, callback) {\n    if (textureLoader == null) throw new Error(\"textureLoader cannot be null.\");\n    let reader = new TextureAtlasReader(atlasText);\n    let entry = new Array(4);\n    let page = null;\n    let pageFields = {};\n    let region = null;\n\n    pageFields[\"size\"] = () => {\n      page.width = parseInt(entry[1]);\n      page.height = parseInt(entry[2]);\n    };\n\n    pageFields[\"format\"] = () => {// page.format = Format[tuple[0]]; we don't need format in WebGL\n    };\n\n    pageFields[\"filter\"] = () => {\n      page.minFilter = filterFromString(entry[1]);\n      page.magFilter = filterFromString(entry[2]);\n    };\n\n    pageFields[\"repeat\"] = () => {\n      if (entry[1].indexOf('x') != -1) page.uWrap = TextureWrap.Repeat;\n      if (entry[1].indexOf('y') != -1) page.vWrap = TextureWrap.Repeat;\n    };\n\n    pageFields[\"pma\"] = () => {\n      page.pma = entry[1] == \"true\";\n    };\n\n    let regionFields = {};\n\n    regionFields[\"xy\"] = () => {\n      // Deprecated, use bounds.\n      region.x = parseInt(entry[1]);\n      region.y = parseInt(entry[2]);\n    };\n\n    regionFields[\"size\"] = () => {\n      // Deprecated, use bounds.\n      region.width = parseInt(entry[1]);\n      region.height = parseInt(entry[2]);\n    };\n\n    regionFields[\"bounds\"] = () => {\n      region.x = parseInt(entry[1]);\n      region.y = parseInt(entry[2]);\n      region.width = parseInt(entry[3]);\n      region.height = parseInt(entry[4]);\n    };\n\n    regionFields[\"offset\"] = () => {\n      // Deprecated, use offsets.\n      region.offsetX = parseInt(entry[1]);\n      region.offsetY = parseInt(entry[2]);\n    };\n\n    regionFields[\"orig\"] = () => {\n      // Deprecated, use offsets.\n      region.originalWidth = parseInt(entry[1]);\n      region.originalHeight = parseInt(entry[2]);\n    };\n\n    regionFields[\"offsets\"] = () => {\n      region.offsetX = parseInt(entry[1]);\n      region.offsetY = parseInt(entry[2]);\n      region.originalWidth = parseInt(entry[3]);\n      region.originalHeight = parseInt(entry[4]);\n    };\n\n    regionFields[\"rotate\"] = () => {\n      let rotateValue = entry[1];\n      let rotate = 0;\n\n      if (rotateValue.toLocaleLowerCase() == \"true\") {\n        rotate = 6;\n      } else if (rotateValue.toLocaleLowerCase() == \"false\") {\n        rotate = 0;\n      } else {\n        rotate = (720 - parseFloat(rotateValue)) % 360 / 45;\n      }\n\n      region.rotate = rotate;\n    };\n\n    regionFields[\"index\"] = () => {\n      region.index = parseInt(entry[1]);\n    };\n\n    let line = reader.readLine(); // Ignore empty lines before first entry.\n\n    while (line != null && line.trim().length == 0) line = reader.readLine(); // Header entries.\n\n\n    while (true) {\n      if (line == null || line.trim().length == 0) break;\n      if (reader.readEntry(entry, line) == 0) break; // Silently ignore all header fields.\n\n      line = reader.readLine();\n    }\n\n    let iterateParser = () => {\n      while (true) {\n        if (line == null) {\n          return callback && callback(this);\n        }\n\n        if (line.trim().length == 0) {\n          page = null;\n          line = reader.readLine();\n        } else if (page === null) {\n          page = new TextureAtlasPage();\n          page.name = line.trim();\n\n          while (true) {\n            if (reader.readEntry(entry, line = reader.readLine()) == 0) break;\n            let field = pageFields[entry[0]];\n            if (field) field();\n          }\n\n          this.pages.push(page);\n          textureLoader(page.name, texture => {\n            if (texture === null) {\n              this.pages.splice(this.pages.indexOf(page), 1);\n              return callback && callback(null);\n            }\n\n            page.baseTexture = texture; //TODO: set scaleMode and mipmapMode from spine\n\n            if (page.pma) {\n              texture.alphaMode = ALPHA_MODES.PMA;\n            }\n\n            if (!texture.valid) {\n              texture.setSize(page.width, page.height);\n            }\n\n            this.pages.push(page);\n            page.setFilters();\n\n            if (!page.width || !page.height) {\n              page.width = texture.realWidth;\n              page.height = texture.realHeight;\n\n              if (!page.width || !page.height) {\n                console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\n              }\n            }\n\n            iterateParser();\n          });\n          this.pages.push(page);\n          break;\n        } else {\n          region = new RegionFields();\n          let atlasRegion = new TextureAtlasRegion();\n          atlasRegion.name = line;\n          atlasRegion.page = page;\n          let names = null;\n          let values = null;\n\n          while (true) {\n            let count = reader.readEntry(entry, line = reader.readLine());\n            if (count == 0) break;\n            let field = regionFields[entry[0]];\n            if (field) field();else {\n              if (names == null) {\n                names = [];\n                values = [];\n              }\n\n              names.push(entry[0]);\n              let entryValues = [];\n\n              for (let i = 0; i < count; i++) entryValues.push(parseInt(entry[i + 1]));\n\n              values.push(entryValues);\n            }\n          }\n\n          if (region.originalWidth == 0 && region.originalHeight == 0) {\n            region.originalWidth = region.width;\n            region.originalHeight = region.height;\n          }\n\n          let resolution = page.baseTexture.resolution;\n          region.x /= resolution;\n          region.y /= resolution;\n          region.width /= resolution;\n          region.height /= resolution;\n          region.originalWidth /= resolution;\n          region.originalHeight /= resolution;\n          region.offsetX /= resolution;\n          region.offsetY /= resolution;\n          const swapWH = region.rotate % 4 !== 0;\n          let frame = new Rectangle(region.x, region.y, swapWH ? region.height : region.width, swapWH ? region.width : region.height);\n          let orig = new Rectangle(0, 0, region.originalWidth, region.originalHeight);\n          let trim = new Rectangle(region.offsetX, region.originalHeight - region.height - region.offsetY, region.width, region.height);\n          atlasRegion.texture = new Texture(atlasRegion.page.baseTexture, frame, orig, trim, region.rotate);\n          atlasRegion.index = region.index;\n          atlasRegion.texture.updateUvs();\n          this.regions.push(atlasRegion);\n        }\n      }\n    };\n\n    iterateParser();\n  }\n\n  findRegion(name) {\n    for (let i = 0; i < this.regions.length; i++) {\n      if (this.regions[i].name == name) {\n        return this.regions[i];\n      }\n    }\n\n    return null;\n  }\n\n  dispose() {\n    for (let i = 0; i < this.pages.length; i++) {\n      this.pages[i].baseTexture.dispose();\n    }\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass TextureAtlasReader {\n  __init13() {\n    this.index = 0;\n  }\n\n  constructor(text) {\n    TextureAtlasReader.prototype.__init13.call(this);\n\n    this.lines = text.split(/\\r\\n|\\r|\\n/);\n  }\n\n  readLine() {\n    if (this.index >= this.lines.length) return null;\n    return this.lines[this.index++];\n  }\n\n  readEntry(entry, line) {\n    if (line == null) return 0;\n    line = line.trim();\n    if (line.length == 0) return 0;\n    let colon = line.indexOf(':');\n    if (colon == -1) return 0;\n    entry[0] = line.substr(0, colon).trim();\n\n    for (let i = 1, lastMatch = colon + 1;; i++) {\n      let comma = line.indexOf(',', lastMatch);\n\n      if (comma == -1) {\n        entry[i] = line.substr(lastMatch).trim();\n        return i;\n      }\n\n      entry[i] = line.substr(lastMatch, comma - lastMatch).trim();\n      lastMatch = comma + 1;\n      if (i == 4) return 4;\n    }\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass TextureAtlasPage {\n  constructor() {\n    TextureAtlasPage.prototype.__init14.call(this);\n\n    TextureAtlasPage.prototype.__init15.call(this);\n\n    TextureAtlasPage.prototype.__init16.call(this);\n\n    TextureAtlasPage.prototype.__init17.call(this);\n  }\n\n  __init14() {\n    this.minFilter = TextureFilter.Nearest;\n  }\n\n  __init15() {\n    this.magFilter = TextureFilter.Nearest;\n  }\n\n  __init16() {\n    this.uWrap = TextureWrap.ClampToEdge;\n  }\n\n  __init17() {\n    this.vWrap = TextureWrap.ClampToEdge;\n  }\n\n  setFilters() {\n    let tex = this.baseTexture;\n    let filter = this.minFilter;\n\n    if (filter == TextureFilter.Linear) {\n      tex.scaleMode = SCALE_MODES.LINEAR;\n    } else if (this.minFilter == TextureFilter.Nearest) {\n      tex.scaleMode = SCALE_MODES.NEAREST;\n    } else {\n      tex.mipmap = MIPMAP_MODES.POW2;\n\n      if (filter == TextureFilter.MipMapNearestNearest) {\n        tex.scaleMode = SCALE_MODES.NEAREST;\n      } else {\n        tex.scaleMode = SCALE_MODES.LINEAR;\n      }\n    }\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass TextureAtlasRegion extends TextureRegion {}\n\nlet fround_polyfill = function (array) {\n  return function (x) {\n    return array[0] = x, array[0];\n  };\n}(new Float32Array(1));\n\nlet fround = Math.fround || fround_polyfill;\n/**\r\n * @public\r\n */\n\n/**\r\n * @public\r\n */\n\nclass IntSet {\n  constructor() {\n    IntSet.prototype.__init.call(this);\n  }\n\n  __init() {\n    this.array = new Array();\n  }\n\n  add(value) {\n    let contains = this.contains(value);\n    this.array[value | 0] = value | 0;\n    return !contains;\n  }\n\n  contains(value) {\n    return this.array[value | 0] != undefined;\n  }\n\n  remove(value) {\n    this.array[value | 0] = undefined;\n  }\n\n  clear() {\n    this.array.length = 0;\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass StringSet {\n  constructor() {\n    StringSet.prototype.__init2.call(this);\n\n    StringSet.prototype.__init3.call(this);\n  }\n\n  __init2() {\n    this.entries = {};\n  }\n\n  __init3() {\n    this.size = 0;\n  }\n\n  add(value) {\n    let contains = this.entries[value];\n    this.entries[value] = true;\n\n    if (!contains) {\n      this.size++;\n      return true;\n    }\n\n    return false;\n  }\n\n  addAll(values) {\n    let oldSize = this.size;\n\n    for (var i = 0, n = values.length; i < n; i++) this.add(values[i]);\n\n    return oldSize != this.size;\n  }\n\n  contains(value) {\n    return this.entries[value];\n  }\n\n  clear() {\n    this.entries = {};\n    this.size = 0;\n  }\n\n}\n/**\r\n * @public\r\n */\n\n/**\r\n * @public\r\n */\n\n\nclass Color {\n  static __initStatic() {\n    this.WHITE = new Color(1, 1, 1, 1);\n  }\n\n  static __initStatic2() {\n    this.RED = new Color(1, 0, 0, 1);\n  }\n\n  static __initStatic3() {\n    this.GREEN = new Color(0, 1, 0, 1);\n  }\n\n  static __initStatic4() {\n    this.BLUE = new Color(0, 0, 1, 1);\n  }\n\n  static __initStatic5() {\n    this.MAGENTA = new Color(1, 0, 1, 1);\n  }\n\n  constructor(r = 0, g = 0, b = 0, a = 0) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n  }\n\n  set(r, g, b, a) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n    return this.clamp();\n  }\n\n  setFromColor(c) {\n    this.r = c.r;\n    this.g = c.g;\n    this.b = c.b;\n    this.a = c.a;\n    return this;\n  }\n\n  setFromString(hex) {\n    hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\n    this.r = parseInt(hex.substr(0, 2), 16) / 255;\n    this.g = parseInt(hex.substr(2, 2), 16) / 255;\n    this.b = parseInt(hex.substr(4, 2), 16) / 255;\n    this.a = hex.length != 8 ? 1 : parseInt(hex.substr(6, 2), 16) / 255;\n    return this;\n  }\n\n  add(r, g, b, a) {\n    this.r += r;\n    this.g += g;\n    this.b += b;\n    this.a += a;\n    return this.clamp();\n  }\n\n  clamp() {\n    if (this.r < 0) this.r = 0;else if (this.r > 1) this.r = 1;\n    if (this.g < 0) this.g = 0;else if (this.g > 1) this.g = 1;\n    if (this.b < 0) this.b = 0;else if (this.b > 1) this.b = 1;\n    if (this.a < 0) this.a = 0;else if (this.a > 1) this.a = 1;\n    return this;\n  }\n\n  static rgba8888ToColor(color, value) {\n    color.r = ((value & 0xff000000) >>> 24) / 255;\n    color.g = ((value & 0x00ff0000) >>> 16) / 255;\n    color.b = ((value & 0x0000ff00) >>> 8) / 255;\n    color.a = (value & 0x000000ff) / 255;\n  }\n\n  static rgb888ToColor(color, value) {\n    color.r = ((value & 0x00ff0000) >>> 16) / 255;\n    color.g = ((value & 0x0000ff00) >>> 8) / 255;\n    color.b = (value & 0x000000ff) / 255;\n  }\n\n  static fromString(hex) {\n    return new Color().setFromString(hex);\n  }\n\n}\n\nColor.__initStatic();\n\nColor.__initStatic2();\n\nColor.__initStatic3();\n\nColor.__initStatic4();\n\nColor.__initStatic5();\n/**\r\n * @public\r\n */\n\n\nclass MathUtils {\n  static __initStatic6() {\n    this.PI = 3.1415927;\n  }\n\n  static __initStatic7() {\n    this.PI2 = MathUtils.PI * 2;\n  }\n\n  static __initStatic8() {\n    this.radiansToDegrees = 180 / MathUtils.PI;\n  }\n\n  static __initStatic9() {\n    this.radDeg = MathUtils.radiansToDegrees;\n  }\n\n  static __initStatic10() {\n    this.degreesToRadians = MathUtils.PI / 180;\n  }\n\n  static __initStatic11() {\n    this.degRad = MathUtils.degreesToRadians;\n  }\n\n  static clamp(value, min, max) {\n    if (value < min) return min;\n    if (value > max) return max;\n    return value;\n  }\n\n  static cosDeg(degrees) {\n    return Math.cos(degrees * MathUtils.degRad);\n  }\n\n  static sinDeg(degrees) {\n    return Math.sin(degrees * MathUtils.degRad);\n  }\n\n  static signum(value) {\n    return value > 0 ? 1 : value < 0 ? -1 : 0;\n  }\n\n  static toInt(x) {\n    return x > 0 ? Math.floor(x) : Math.ceil(x);\n  }\n\n  static cbrt(x) {\n    let y = Math.pow(Math.abs(x), 1 / 3);\n    return x < 0 ? -y : y;\n  }\n\n  static randomTriangular(min, max) {\n    return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\n  }\n\n  static randomTriangularWith(min, max, mode) {\n    let u = Math.random();\n    let d = max - min;\n    if (u <= (mode - min) / d) return min + Math.sqrt(u * d * (mode - min));\n    return max - Math.sqrt((1 - u) * d * (max - mode));\n  }\n\n}\n\nMathUtils.__initStatic6();\n\nMathUtils.__initStatic7();\n\nMathUtils.__initStatic8();\n\nMathUtils.__initStatic9();\n\nMathUtils.__initStatic10();\n\nMathUtils.__initStatic11();\n/**\r\n * @public\r\n */\n\n\nclass Interpolation {\n  apply(start, end, a) {\n    return start + (end - start) * this.applyInternal(a);\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass Pow extends Interpolation {\n  __init4() {\n    this.power = 2;\n  }\n\n  constructor(power) {\n    super();\n\n    Pow.prototype.__init4.call(this);\n\n    this.power = power;\n  }\n\n  applyInternal(a) {\n    if (a <= 0.5) return Math.pow(a * 2, this.power) / 2;\n    return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass PowOut extends Pow {\n  constructor(power) {\n    super(power);\n  }\n\n  applyInternal(a) {\n    return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass Utils {\n  static __initStatic12() {\n    this.SUPPORTS_TYPED_ARRAYS = typeof Float32Array !== \"undefined\";\n  }\n\n  static arrayCopy(source, sourceStart, dest, destStart, numElements) {\n    for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\n      dest[j] = source[i];\n    }\n  }\n\n  static arrayFill(array, fromIndex, toIndex, value) {\n    for (let i = fromIndex; i < toIndex; i++) array[i] = value;\n  }\n\n  static setArraySize(array, size, value = 0) {\n    let oldSize = array.length;\n    if (oldSize == size) return array;\n    array.length = size;\n\n    if (oldSize < size) {\n      for (let i = oldSize; i < size; i++) array[i] = value;\n    }\n\n    return array;\n  }\n\n  static ensureArrayCapacity(array, size, value = 0) {\n    if (array.length >= size) return array;\n    return Utils.setArraySize(array, size, value);\n  }\n\n  static newArray(size, defaultValue) {\n    let array = new Array(size);\n\n    for (let i = 0; i < size; i++) array[i] = defaultValue;\n\n    return array;\n  }\n\n  static newFloatArray(size) {\n    if (Utils.SUPPORTS_TYPED_ARRAYS) return new Float32Array(size);else {\n      let array = new Array(size);\n\n      for (let i = 0; i < array.length; i++) array[i] = 0;\n\n      return array;\n    }\n  }\n\n  static newShortArray(size) {\n    if (Utils.SUPPORTS_TYPED_ARRAYS) return new Int16Array(size);else {\n      let array = new Array(size);\n\n      for (let i = 0; i < array.length; i++) array[i] = 0;\n\n      return array;\n    }\n  }\n\n  static toFloatArray(array) {\n    return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\n  }\n\n  static toSinglePrecision(value) {\n    return Utils.SUPPORTS_TYPED_ARRAYS ? fround(value) : value;\n  } // This function is used to fix WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n\n\n  static webkit602BugfixHelper(alpha, blend) {}\n\n  static contains(array, element, identity = true) {\n    for (let i = 0; i < array.length; i++) if (array[i] == element) return true;\n\n    return false;\n  }\n\n  static enumValue(type, name) {\n    return type[name[0].toUpperCase() + name.slice(1)];\n  }\n\n}\n\nUtils.__initStatic12();\n/**\r\n * @public\r\n */\n\n\nclass DebugUtils {\n  static logBones(skeleton) {\n    for (let i = 0; i < skeleton.bones.length; i++) {\n      let bone = skeleton.bones[i];\n      let mat = bone.matrix;\n      console.log(bone.data.name + \", \" + mat.a + \", \" + mat.b + \", \" + mat.c + \", \" + mat.d + \", \" + mat.tx + \", \" + mat.ty);\n    }\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass Pool {\n  __init5() {\n    this.items = new Array();\n  }\n\n  constructor(instantiator) {\n    Pool.prototype.__init5.call(this);\n\n    this.instantiator = instantiator;\n  }\n\n  obtain() {\n    return this.items.length > 0 ? this.items.pop() : this.instantiator();\n  }\n\n  free(item) {\n    if (item.reset) item.reset();\n    this.items.push(item);\n  }\n\n  freeAll(items) {\n    for (let i = 0; i < items.length; i++) this.free(items[i]);\n  }\n\n  clear() {\n    this.items.length = 0;\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass Vector2 {\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  set(x, y) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  length() {\n    let x = this.x;\n    let y = this.y;\n    return Math.sqrt(x * x + y * y);\n  }\n\n  normalize() {\n    let len = this.length();\n\n    if (len != 0) {\n      this.x /= len;\n      this.y /= len;\n    }\n\n    return this;\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass TimeKeeper {\n  constructor() {\n    TimeKeeper.prototype.__init6.call(this);\n\n    TimeKeeper.prototype.__init7.call(this);\n\n    TimeKeeper.prototype.__init8.call(this);\n\n    TimeKeeper.prototype.__init9.call(this);\n\n    TimeKeeper.prototype.__init10.call(this);\n\n    TimeKeeper.prototype.__init11.call(this);\n\n    TimeKeeper.prototype.__init12.call(this);\n  }\n\n  __init6() {\n    this.maxDelta = 0.064;\n  }\n\n  __init7() {\n    this.framesPerSecond = 0;\n  }\n\n  __init8() {\n    this.delta = 0;\n  }\n\n  __init9() {\n    this.totalTime = 0;\n  }\n\n  __init10() {\n    this.lastTime = Date.now() / 1000;\n  }\n\n  __init11() {\n    this.frameCount = 0;\n  }\n\n  __init12() {\n    this.frameTime = 0;\n  }\n\n  update() {\n    let now = Date.now() / 1000;\n    this.delta = now - this.lastTime;\n    this.frameTime += this.delta;\n    this.totalTime += this.delta;\n    if (this.delta > this.maxDelta) this.delta = this.maxDelta;\n    this.lastTime = now;\n    this.frameCount++;\n\n    if (this.frameTime > 1) {\n      this.framesPerSecond = this.frameCount / this.frameTime;\n      this.frameTime = 0;\n      this.frameCount = 0;\n    }\n  }\n\n}\n/**\r\n * @public\r\n */\n\n/**\r\n * @public\r\n */\n\n\nclass WindowedMean {\n  __init13() {\n    this.addedValues = 0;\n  }\n\n  __init14() {\n    this.lastValue = 0;\n  }\n\n  __init15() {\n    this.mean = 0;\n  }\n\n  __init16() {\n    this.dirty = true;\n  }\n\n  constructor(windowSize = 32) {\n    WindowedMean.prototype.__init13.call(this);\n\n    WindowedMean.prototype.__init14.call(this);\n\n    WindowedMean.prototype.__init15.call(this);\n\n    WindowedMean.prototype.__init16.call(this);\n\n    this.values = new Array(windowSize);\n  }\n\n  hasEnoughData() {\n    return this.addedValues >= this.values.length;\n  }\n\n  addValue(value) {\n    if (this.addedValues < this.values.length) this.addedValues++;\n    this.values[this.lastValue++] = value;\n    if (this.lastValue > this.values.length - 1) this.lastValue = 0;\n    this.dirty = true;\n  }\n\n  getMean() {\n    if (this.hasEnoughData()) {\n      if (this.dirty) {\n        let mean = 0;\n\n        for (let i = 0; i < this.values.length; i++) mean += this.values[i];\n\n        this.mean = mean / this.values.length;\n        this.dirty = false;\n      }\n\n      return this.mean;\n    }\n\n    return 0;\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nlet settings = {\n  yDown: true,\n\n  /**\r\n   * pixi-spine gives option to not fail at certain parsing errors\r\n   * spine-ts fails here\r\n   */\n  FAIL_ON_NON_EXISTING_SKIN: false,\n\n  /**\r\n   * past Spine.globalAutoUpdate\r\n   */\n  GLOBAL_AUTO_UPDATE: true,\n\n  /**\r\n   * past Spine.globalDelayLimit\r\n   */\n  GLOBAL_DELAY_LIMIT: 0\n};\nlet tempRgb = [0, 0, 0];\n/**\r\n * @public\r\n */\n\n/**\r\n * @public\r\n */\n\nclass SpineSprite extends Sprite {\n  constructor(...args) {\n    super(...args);\n\n    SpineSprite.prototype.__init.call(this);\n\n    SpineSprite.prototype.__init2.call(this);\n  }\n\n  __init() {\n    this.region = null;\n  }\n\n  __init2() {\n    this.attachment = null;\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nclass SpineMesh extends SimpleMesh {\n  __init3() {\n    this.region = null;\n  }\n\n  __init4() {\n    this.attachment = null;\n  }\n\n  constructor(texture, vertices, uvs, indices, drawMode) {\n    super(texture, vertices, uvs, indices, drawMode);\n\n    SpineMesh.prototype.__init3.call(this);\n\n    SpineMesh.prototype.__init4.call(this);\n  }\n\n}\n/**\r\n * A class that enables the you to import and run your spine animations in pixi.\r\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\r\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\r\n *\r\n * ```js\r\n * let spineAnimation = new spine(spineData);\r\n * ```\r\n *\r\n * @public\r\n * @class\r\n * @extends Container\r\n * @memberof spine\r\n * @param spineData {object} The spine data loaded from a spine atlas.\r\n */\n\n\nclass SpineBase extends Container {\n  constructor(spineData) {\n    super();\n\n    if (!spineData) {\n      throw new Error('The spineData param is required.');\n    }\n\n    if (typeof spineData === \"string\") {\n      throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n    }\n    /**\r\n     * The spineData object\r\n     *\r\n     * @member {object}\r\n     */\n\n\n    this.spineData = spineData;\n    /**\r\n     * A spine Skeleton object\r\n     *\r\n     * @member {object}\r\n     */\n\n    this.createSkeleton(spineData);\n    /**\r\n     * An array of containers\r\n     *\r\n     * @member {Container[]}\r\n     */\n\n    this.slotContainers = [];\n    this.tempClipContainers = [];\n\n    for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\n      let slot = this.skeleton.slots[i];\n      let attachment = slot.getAttachment();\n      let slotContainer = this.newContainer();\n      this.slotContainers.push(slotContainer);\n      this.addChild(slotContainer);\n      this.tempClipContainers.push(null);\n\n      if (!attachment) {\n        continue;\n      }\n\n      if (attachment.type === AttachmentType.Region) {\n        let spriteName = attachment.region.name;\n        let sprite = this.createSprite(slot, attachment, spriteName);\n        slot.currentSprite = sprite;\n        slot.currentSpriteName = spriteName;\n        slotContainer.addChild(sprite);\n      } else if (attachment.type === AttachmentType.Mesh) {\n        let mesh = this.createMesh(slot, attachment);\n        slot.currentMesh = mesh;\n        slot.currentMeshId = attachment.id;\n        slot.currentMeshName = attachment.name;\n        slotContainer.addChild(mesh);\n      } else if (attachment.type === AttachmentType.Clipping) {\n        this.createGraphics(slot, attachment);\n        slotContainer.addChild(slot.clippingContainer);\n        slotContainer.addChild(slot.currentGraphics);\n      }\n    }\n    /**\r\n     * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\r\n     *\r\n     * @member {number}\r\n     * @memberof spine.Spine#\r\n     */\n\n\n    this.tintRgb = new Float32Array([1, 1, 1]);\n    this.autoUpdate = true;\n    this.visible = true;\n  }\n  /**\r\n   * If this flag is set to true, the spine animation will be automatically updated every\r\n   * time the object id drawn. The down side of this approach is that the delta time is\r\n   * automatically calculated and you could miss out on cool effects like slow motion,\r\n   * pause, skip ahead and the sorts. Most of these effects can be achieved even with\r\n   * autoUpdate enabled but are harder to achieve.\r\n   *\r\n   * @member {boolean}\r\n   * @memberof spine.Spine#\r\n   * @default true\r\n   */\n\n\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      this.updateTransform = value ? SpineBase.prototype.autoUpdateTransform : Container.prototype.updateTransform;\n    }\n  }\n  /**\r\n   * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\r\n   *\r\n   * @member {number}\r\n   * @memberof spine.Spine#\r\n   * @default 0xFFFFFF\r\n   */\n\n\n  get tint() {\n    return rgb2hex(this.tintRgb);\n  }\n\n  set tint(value) {\n    this.tintRgb = hex2rgb(value, this.tintRgb);\n  }\n  /**\r\n   * Limit value for the update dt with Spine.globalDelayLimit\r\n   * that can be overridden with localDelayLimit\r\n   * @return {number} - Maximum processed dt value for the update\r\n   */\n\n\n  get delayLimit() {\n    let limit = typeof this.localDelayLimit !== \"undefined\" ? this.localDelayLimit : settings.GLOBAL_DELAY_LIMIT; // If limit is 0, this means there is no limit for the delay\n\n    return limit || Number.MAX_VALUE;\n  }\n  /**\r\n   * Update the spine skeleton and its animations by delta time (dt)\r\n   *\r\n   * @param dt {number} Delta time. Time by which the animation should be updated\r\n   */\n\n\n  update(dt) {\n    // Limit delta value to avoid animation jumps\n    let delayLimit = this.delayLimit;\n    if (dt > delayLimit) dt = delayLimit;\n    this.state.update(dt);\n    this.state.apply(this.skeleton); //check we haven't been destroyed via a spine event callback in state update\n\n    if (!this.skeleton) return;\n    this.skeleton.updateWorldTransform();\n    let slots = this.skeleton.slots; // in case pixi has double tint\n\n    let globalClr = this.color;\n    let light = null,\n        dark = null;\n\n    if (globalClr) {\n      light = globalClr.light;\n      dark = globalClr.dark;\n    } else {\n      light = this.tintRgb;\n    } // let thack = false;\n\n\n    for (let i = 0, n = slots.length; i < n; i++) {\n      let slot = slots[i];\n      let attachment = slot.getAttachment();\n      let slotContainer = this.slotContainers[i];\n\n      if (!attachment) {\n        slotContainer.visible = false;\n        continue;\n      }\n\n      let spriteColor = null;\n      let attColor = attachment.color;\n\n      switch (attachment.type) {\n        case AttachmentType.Region:\n          let region = attachment.region;\n\n          if (region) {\n            if (slot.currentMesh) {\n              slot.currentMesh.visible = false;\n              slot.currentMesh = null;\n              slot.currentMeshId = undefined;\n              slot.currentMeshName = undefined;\n            }\n\n            let ar = region;\n\n            if (!slot.currentSpriteName || slot.currentSpriteName !== ar.name) {\n              let spriteName = ar.name;\n\n              if (slot.currentSprite) {\n                slot.currentSprite.visible = false;\n              }\n\n              slot.sprites = slot.sprites || {};\n\n              if (slot.sprites[spriteName] !== undefined) {\n                slot.sprites[spriteName].visible = true;\n              } else {\n                let sprite = this.createSprite(slot, attachment, spriteName);\n                slotContainer.addChild(sprite);\n              }\n\n              slot.currentSprite = slot.sprites[spriteName];\n              slot.currentSpriteName = spriteName; // force sprite update when attachment name is same.\n              // issues https://github.com/pixijs/pixi-spine/issues/318\n            } else if (slot.currentSpriteName === ar.name && !slot.hackRegion) {\n              this.setSpriteRegion(attachment, slot.currentSprite, region);\n            }\n          }\n\n          let transform = slotContainer.transform;\n          transform.setFromMatrix(slot.bone.matrix);\n\n          if (slot.currentSprite.color) {\n            //YAY! double - tint!\n            spriteColor = slot.currentSprite.color;\n          } else {\n            tempRgb[0] = light[0] * slot.color.r * attColor.r;\n            tempRgb[1] = light[1] * slot.color.g * attColor.g;\n            tempRgb[2] = light[2] * slot.color.b * attColor.b;\n            slot.currentSprite.tint = rgb2hex(tempRgb);\n          }\n\n          slot.currentSprite.blendMode = slot.blendMode;\n          break;\n\n        case AttachmentType.Mesh:\n          if (slot.currentSprite) {\n            //TODO: refactor this thing, switch it on and off for container\n            slot.currentSprite.visible = false;\n            slot.currentSprite = null;\n            slot.currentSpriteName = undefined; //TODO: refactor this shit\n\n            const transform = new Transform();\n            transform._parentID = -1;\n            transform._worldID = slotContainer.transform._worldID;\n            slotContainer.transform = transform;\n          }\n\n          const id = attachment.id;\n\n          if (!slot.currentMeshId || slot.currentMeshId !== id) {\n            let meshId = id;\n\n            if (slot.currentMesh) {\n              slot.currentMesh.visible = false;\n            }\n\n            slot.meshes = slot.meshes || {};\n\n            if (slot.meshes[meshId] !== undefined) {\n              slot.meshes[meshId].visible = true;\n            } else {\n              let mesh = this.createMesh(slot, attachment);\n              slotContainer.addChild(mesh);\n            }\n\n            slot.currentMesh = slot.meshes[meshId];\n            slot.currentMeshName = attachment.name;\n            slot.currentMeshId = meshId;\n          }\n\n          attachment.computeWorldVerticesOld(slot, slot.currentMesh.vertices);\n\n          if (slot.currentMesh.color) {\n            // pixi-heaven\n            spriteColor = slot.currentMesh.color;\n          } else {\n            tempRgb[0] = light[0] * slot.color.r * attColor.r;\n            tempRgb[1] = light[1] * slot.color.g * attColor.g;\n            tempRgb[2] = light[2] * slot.color.b * attColor.b;\n            slot.currentMesh.tint = rgb2hex(tempRgb);\n          }\n\n          slot.currentMesh.blendMode = slot.blendMode;\n          break;\n\n        case AttachmentType.Clipping:\n          if (!slot.currentGraphics) {\n            this.createGraphics(slot, attachment);\n            slotContainer.addChild(slot.clippingContainer);\n            slotContainer.addChild(slot.currentGraphics);\n          }\n\n          this.updateGraphics(slot, attachment);\n          slotContainer.alpha = 1.0;\n          slotContainer.visible = true;\n          continue;\n\n        default:\n          slotContainer.visible = false;\n          continue;\n      }\n\n      slotContainer.visible = true; // pixi has double tint\n\n      if (spriteColor) {\n        let r0 = slot.color.r * attColor.r;\n        let g0 = slot.color.g * attColor.g;\n        let b0 = slot.color.b * attColor.b; //YAY! double-tint!\n\n        spriteColor.setLight(light[0] * r0 + dark[0] * (1.0 - r0), light[1] * g0 + dark[1] * (1.0 - g0), light[2] * b0 + dark[2] * (1.0 - b0));\n\n        if (slot.darkColor) {\n          r0 = slot.darkColor.r;\n          g0 = slot.darkColor.g;\n          b0 = slot.darkColor.b;\n        } else {\n          r0 = 0.0;\n          g0 = 0.0;\n          b0 = 0.0;\n        }\n\n        spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));\n      }\n\n      slotContainer.alpha = slot.color.a;\n    } //== this is clipping implementation ===\n    //TODO: remove parent hacks when pixi masks allow it\n\n\n    let drawOrder = this.skeleton.drawOrder;\n    let clippingAttachment = null;\n    let clippingContainer = null;\n\n    for (let i = 0, n = drawOrder.length; i < n; i++) {\n      let slot = slots[drawOrder[i].data.index];\n      let slotContainer = this.slotContainers[drawOrder[i].data.index];\n\n      if (!clippingContainer) {\n        //Adding null check as it is possible for slotContainer.parent to be null in the event of a spine being disposed off in its loop callback\n        if (slotContainer.parent !== null && slotContainer.parent !== this) {\n          slotContainer.parent.removeChild(slotContainer); //silend add hack\n\n          slotContainer.parent = this;\n        }\n      }\n\n      if (slot.currentGraphics && slot.getAttachment()) {\n        clippingContainer = slot.clippingContainer;\n        clippingAttachment = slot.getAttachment();\n        clippingContainer.children.length = 0;\n        this.children[i] = slotContainer;\n\n        if (clippingAttachment.endSlot === slot.data) {\n          clippingAttachment.endSlot = null;\n        }\n      } else {\n        if (clippingContainer) {\n          let c = this.tempClipContainers[i];\n\n          if (!c) {\n            c = this.tempClipContainers[i] = this.newContainer();\n            c.visible = false;\n          }\n\n          this.children[i] = c; //silent remove hack\n\n          slotContainer.parent = null;\n          clippingContainer.addChild(slotContainer);\n\n          if (clippingAttachment.endSlot == slot.data) {\n            clippingContainer.renderable = true;\n            clippingContainer = null;\n            clippingAttachment = null;\n          }\n        } else {\n          this.children[i] = slotContainer;\n        }\n      }\n    }\n  }\n\n  setSpriteRegion(attachment, sprite, region) {\n    // prevent setters calling when attachment and region is same\n    if (sprite.attachment === attachment && sprite.region === region) {\n      return;\n    }\n\n    sprite.region = region;\n    sprite.attachment = attachment;\n    sprite.texture = region.texture;\n    sprite.rotation = attachment.rotation * MathUtils.degRad;\n    sprite.position.x = attachment.x;\n    sprite.position.y = attachment.y;\n    sprite.alpha = attachment.color.a;\n\n    if (!region.size) {\n      sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;\n      sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;\n    } else {\n      //hacked!\n      sprite.scale.x = region.size.width / region.originalWidth;\n      sprite.scale.y = -region.size.height / region.originalHeight;\n    }\n  }\n\n  setMeshRegion(attachment, mesh, region) {\n    if (mesh.attachment === attachment && mesh.region === region) {\n      return;\n    }\n\n    mesh.region = region;\n    mesh.attachment = attachment;\n    mesh.texture = region.texture;\n    region.texture.updateUvs();\n    mesh.uvBuffer.update(attachment.regionUVs);\n  }\n  /**\r\n   * When autoupdate is set to yes this function is used as pixi's updateTransform function\r\n   *\r\n   * @private\r\n   */\n\n\n  autoUpdateTransform() {\n    if (settings.GLOBAL_AUTO_UPDATE) {\n      this.lastTime = this.lastTime || Date.now();\n      let timeDelta = (Date.now() - this.lastTime) * 0.001;\n      this.lastTime = Date.now();\n      this.update(timeDelta);\n    } else {\n      this.lastTime = 0;\n    }\n\n    Container.prototype.updateTransform.call(this);\n  }\n\n  /**\r\n   * Create a new sprite to be used with core.RegionAttachment\r\n   *\r\n   * @param slot {spine.Slot} The slot to which the attachment is parented\r\n   * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n   * @private\r\n   */\n  createSprite(slot, attachment, defName) {\n    let region = attachment.region;\n\n    if (slot.hackAttachment === attachment) {\n      region = slot.hackRegion;\n    }\n\n    let texture = region.texture;\n    let sprite = this.newSprite(texture);\n    sprite.anchor.set(0.5);\n    this.setSpriteRegion(attachment, sprite, attachment.region);\n    slot.sprites = slot.sprites || {};\n    slot.sprites[defName] = sprite;\n    return sprite;\n  }\n\n  /**\r\n   * Creates a Strip from the spine data\r\n   * @param slot {spine.Slot} The slot to which the attachment is parented\r\n   * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n   * @private\r\n   */\n  createMesh(slot, attachment) {\n    let region = attachment.region;\n\n    if (slot.hackAttachment === attachment) {\n      region = slot.hackRegion;\n      slot.hackAttachment = null;\n      slot.hackRegion = null;\n    }\n\n    let strip = this.newMesh(region.texture, new Float32Array(attachment.regionUVs.length), attachment.regionUVs, new Uint16Array(attachment.triangles), DRAW_MODES.TRIANGLES);\n\n    if (typeof strip._canvasPadding !== \"undefined\") {\n      strip._canvasPadding = 1.5;\n    }\n\n    strip.alpha = attachment.color.a;\n    strip.region = attachment.region;\n    this.setMeshRegion(attachment, strip, region);\n    slot.meshes = slot.meshes || {};\n    slot.meshes[attachment.id] = strip;\n    return strip;\n  }\n\n  static __initStatic() {\n    this.clippingPolygon = [];\n  } //@ts-ignore\n\n\n  createGraphics(slot, clip) {\n    let graphics = this.newGraphics();\n    let poly = new Polygon([]);\n    graphics.clear();\n    graphics.beginFill(0xffffff, 1);\n    graphics.drawPolygon(poly);\n    graphics.renderable = false;\n    slot.currentGraphics = graphics;\n    slot.clippingContainer = this.newContainer();\n    slot.clippingContainer.mask = slot.currentGraphics;\n    return graphics;\n  }\n\n  updateGraphics(slot, clip) {\n    let geom = slot.currentGraphics.geometry;\n    let vertices = geom.graphicsData[0].shape.points;\n    let n = clip.worldVerticesLength;\n    vertices.length = n;\n    clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n    geom.invalidate();\n  }\n  /**\r\n   * Changes texture in attachment in specific slot.\r\n   *\r\n   * PIXI runtime feature, it was made to satisfy our users.\r\n   *\r\n   * @param slotIndex {number}\r\n   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n   * @returns {boolean} Success flag\r\n   */\n\n\n  hackTextureBySlotIndex(slotIndex, texture = null, size = null) {\n    let slot = this.skeleton.slots[slotIndex];\n\n    if (!slot) {\n      return false;\n    }\n\n    let attachment = slot.getAttachment();\n    let region = attachment.region;\n\n    if (texture) {\n      region = new TextureRegion();\n      region.texture = texture;\n      region.size = size;\n      slot.hackRegion = region;\n      slot.hackAttachment = attachment;\n    } else {\n      slot.hackRegion = null;\n      slot.hackAttachment = null;\n    }\n\n    if (slot.currentSprite && slot.currentSprite.region != region) {\n      this.setSpriteRegion(attachment, slot.currentSprite, region);\n      slot.currentSprite.region = region;\n    } else if (slot.currentMesh && slot.currentMesh.region != region) {\n      this.setMeshRegion(attachment, slot.currentMesh, region);\n    }\n\n    return true;\n  }\n  /**\r\n   * Changes texture in attachment in specific slot.\r\n   *\r\n   * PIXI runtime feature, it was made to satisfy our users.\r\n   *\r\n   * @param slotName {string}\r\n   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n   * @returns {boolean} Success flag\r\n   */\n\n\n  hackTextureBySlotName(slotName, texture = null, size = null) {\n    let index = this.skeleton.findSlotIndex(slotName);\n\n    if (index == -1) {\n      return false;\n    }\n\n    return this.hackTextureBySlotIndex(index, texture, size);\n  }\n  /**\r\n   * Changes texture of an attachment\r\n   *\r\n   * PIXI runtime feature, it was made to satisfy our users.\r\n   *\r\n   * @param slotName {string}\r\n   * @param attachmentName {string}\r\n   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n   * @returns {boolean} Success flag\r\n   */\n\n\n  hackTextureAttachment(slotName, attachmentName, texture, size = null) {\n    // changes the texture of an attachment at the skeleton level\n    const slotIndex = this.skeleton.findSlotIndex(slotName);\n    const attachment = this.skeleton.getAttachmentByName(slotName, attachmentName);\n    attachment.region.texture = texture;\n    const slot = this.skeleton.slots[slotIndex];\n\n    if (!slot) {\n      return false;\n    } // gets the currently active attachment in this slot\n\n\n    const currentAttachment = slot.getAttachment();\n\n    if (attachmentName === currentAttachment.name) {\n      // if the attachment we are changing is currently active, change the the live texture\n      let region = attachment.region;\n\n      if (texture) {\n        region = new TextureRegion();\n        region.texture = texture;\n        region.size = size;\n        slot.hackRegion = region;\n        slot.hackAttachment = currentAttachment;\n      } else {\n        slot.hackRegion = null;\n        slot.hackAttachment = null;\n      }\n\n      if (slot.currentSprite && slot.currentSprite.region != region) {\n        this.setSpriteRegion(currentAttachment, slot.currentSprite, region);\n        slot.currentSprite.region = region;\n      } else if (slot.currentMesh && slot.currentMesh.region != region) {\n        this.setMeshRegion(currentAttachment, slot.currentMesh, region);\n      }\n\n      return true;\n    }\n\n    return false;\n  } //those methods can be overriden to spawn different classes\n\n\n  newContainer() {\n    return new Container();\n  }\n\n  newSprite(tex) {\n    return new SpineSprite(tex);\n  }\n\n  newGraphics() {\n    return new Graphics();\n  }\n\n  newMesh(texture, vertices, uvs, indices, drawMode) {\n    return new SpineMesh(texture, vertices, uvs, indices, drawMode);\n  }\n\n  transformHack() {\n    return 1;\n  }\n  /**\r\n   * Hack for pixi-display and pixi-lights. Every attachment name ending with a suffix will be added to different layer\r\n   * @param nameSuffix\r\n   * @param group\r\n   * @param outGroup\r\n   */\n\n\n  hackAttachmentGroups(nameSuffix, group, outGroup) {\n    if (!nameSuffix) {\n      return undefined;\n    }\n\n    const list_d = [],\n          list_n = [];\n\n    for (let i = 0, len = this.skeleton.slots.length; i < len; i++) {\n      const slot = this.skeleton.slots[i];\n      const name = slot.currentSpriteName || slot.currentMeshName || \"\";\n      const target = slot.currentSprite || slot.currentMesh;\n\n      if (name.endsWith(nameSuffix)) {\n        target.parentGroup = group;\n        list_n.push(target);\n      } else if (outGroup && target) {\n        target.parentGroup = outGroup;\n        list_d.push(target);\n      }\n    }\n\n    return [list_d, list_n];\n  }\n\n  destroy(options) {\n    for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\n      let slot = this.skeleton.slots[i];\n\n      for (let name in slot.meshes) {\n        slot.meshes[name].destroy(options);\n      }\n\n      slot.meshes = null;\n\n      for (let name in slot.sprites) {\n        slot.sprites[name].destroy(options);\n      }\n\n      slot.sprites = null;\n    }\n\n    for (let i = 0, n = this.slotContainers.length; i < n; i++) {\n      this.slotContainers[i].destroy(options);\n    }\n\n    this.spineData = null;\n    this.skeleton = null;\n    this.slotContainers = null;\n    this.stateData = null;\n    this.state = null;\n    this.tempClipContainers = null;\n    super.destroy(options);\n  }\n\n}\n\nSpineBase.__initStatic();\n/**\r\n * The visibility of the spine object. If false the object will not be drawn,\r\n * the updateTransform function will not be called, and the spine will not be automatically updated.\r\n *\r\n * @member {boolean}\r\n * @memberof spine.Spine#\r\n * @default true\r\n */\n\n\nObject.defineProperty(SpineBase.prototype, 'visible', {\n  get: function () {\n    return this._visible;\n  },\n  set: function (value) {\n    if (value !== this._visible) {\n      this._visible = value;\n\n      if (value) {\n        this.lastTime = 0;\n      }\n    }\n  }\n});\nexport { AttachmentType, BinaryInput, Color, DebugUtils, IntSet, Interpolation, MathUtils, Pool, Pow, PowOut, SpineBase, SpineMesh, SpineSprite, StringSet, TextureAtlas, TextureAtlasPage, TextureAtlasRegion, TextureFilter, TextureRegion, TextureWrap, TimeKeeper, Utils, Vector2, WindowedMean, filterFromString, settings, wrapFromString };","map":{"version":3,"sources":["../src/core/AttachmentType.ts","../src/core/BinaryInput.ts","../src/core/TextureRegion.ts","../src/core/TextureAtlas.ts","../src/core/Utils.ts","../src/settings.ts","../src/SpineBase.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;;;;;AAEA,QAAA,MAAA,GAAA,CAAA;AAAA,EAAA,cAAA,CAAA,cAAA,CAAA,QAAA,CAAA,GAAA,MAAA,CAAA,GAAA,QAAA;AAAA,QAAA,WAAA,GAAA,MAAA,GAAA,CAAA;AAAA,EAAA,cAAA,CAAA,cAAA,CAAA,aAAA,CAAA,GAAA,WAAA,CAAA,GAAA,aAAA;AAAA,QAAA,IAAA,GAAA,WAAA,GAAA,CAAA;AAAA,EAAA,cAAA,CAAA,cAAA,CAAA,MAAA,CAAA,GAAA,IAAA,CAAA,GAAA,MAAA;AAAA,QAAA,UAAA,GAAA,IAAA,GAAA,CAAA;AAAA,EAAA,cAAA,CAAA,cAAA,CAAA,YAAA,CAAA,GAAA,UAAA,CAAA,GAAA,YAAA;AAAA,QAAA,IAAA,GAAA,UAAA,GAAA,CAAA;AAAA,EAAA,cAAA,CAAA,cAAA,CAAA,MAAA,CAAA,GAAA,IAAA,CAAA,GAAA,MAAA;AAAA,QAAA,KAAA,GAAA,IAAA,GAAA,CAAA;AAAA,EAAA,cAAA,CAAA,cAAA,CAAA,OAAA,CAAA,GAAA,KAAA,CAAA,GAAA,OAAA;AAAA,QAAA,QAAA,GAAA,KAAA,GAAA,CAAA;AAAA,EAAA,cAAA,CAAA,cAAA,CAAA,UAAA,CAAA,GAAA,QAAA,CAAA,GAAA,UAAA;AACA,C,EAAA,cAAA,KAAA,cAAA,GAAA,EAAA,C;ACNA;AACA;AACA;;;;AAEA,EAAA,WAAA,CAAA,IAAA,EAAA,OAAA,GAAA,IAAA,KAAA,EAAA,EAAA,KAAA,GAAA,CAAA,EAAA,MAAA,GAAA,IAAA,QAAA,CAAA,IAAA,CAAA,MAAA,CAAA,EAAA;AAAA,SAAA,OAAA,GAAA,OAAA;AAAA,SAAA,KAAA,GAAA,KAAA;AAAA,SAAA,MAAA,GAAA,MAAA;AAEA;;AAEA,EAAA,QAAA,GAAA;AACA,WAAA,KAAA,MAAA,CAAA,OAAA,CAAA,KAAA,KAAA,EAAA,CAAA;AACA;;AAEA,EAAA,gBAAA,GAAA;AACA,WAAA,KAAA,MAAA,CAAA,QAAA,CAAA,KAAA,KAAA,EAAA,CAAA;AACA;;AAEA,EAAA,SAAA,GAAA;AACA,QAAA,KAAA,GAAA,KAAA,MAAA,CAAA,QAAA,CAAA,KAAA,KAAA,CAAA;AACA,SAAA,KAAA,IAAA,CAAA;AACA,WAAA,KAAA;AACA;;AAEA,EAAA,SAAA,GAAA;AACA,QAAA,KAAA,GAAA,KAAA,MAAA,CAAA,QAAA,CAAA,KAAA,KAAA,CAAA;AACA,SAAA,KAAA,IAAA,CAAA;AACA,WAAA,KAAA;AACA;;AAEA,EAAA,OAAA,CAAA,gBAAA,EAAA;AACA,QAAA,CAAA,GAAA,KAAA,QAAA,EAAA;AACA,QAAA,MAAA,GAAA,CAAA,GAAA,IAAA;;AACA,QAAA,CAAA,CAAA,GAAA,IAAA,KAAA,CAAA,EAAA;AACA,MAAA,CAAA,GAAA,KAAA,QAAA,EAAA;AACA,MAAA,MAAA,IAAA,CAAA,CAAA,GAAA,IAAA,KAAA,CAAA;;AACA,UAAA,CAAA,CAAA,GAAA,IAAA,KAAA,CAAA,EAAA;AACA,QAAA,CAAA,GAAA,KAAA,QAAA,EAAA;AACA,QAAA,MAAA,IAAA,CAAA,CAAA,GAAA,IAAA,KAAA,EAAA;;AACA,YAAA,CAAA,CAAA,GAAA,IAAA,KAAA,CAAA,EAAA;AACA,UAAA,CAAA,GAAA,KAAA,QAAA,EAAA;AACA,UAAA,MAAA,IAAA,CAAA,CAAA,GAAA,IAAA,KAAA,EAAA;;AACA,cAAA,CAAA,CAAA,GAAA,IAAA,KAAA,CAAA,EAAA;AACA,YAAA,CAAA,GAAA,KAAA,QAAA,EAAA;AACA,YAAA,MAAA,IAAA,CAAA,CAAA,GAAA,IAAA,KAAA,EAAA;AACA;AACA;AACA;AACA;;AACA,WAAA,gBAAA,GAAA,MAAA,GAAA,MAAA,KAAA,CAAA,GAAA,EAAA,MAAA,GAAA,CAAA,CAAA;AACA;;AAEA,EAAA,aAAA,GAAA;AACA,QAAA,KAAA,GAAA,KAAA,OAAA,CAAA,IAAA,CAAA;AACA,WAAA,KAAA,IAAA,CAAA,GAAA,IAAA,GAAA,KAAA,OAAA,CAAA,KAAA,GAAA,CAAA,CAAA;AACA;;AAEA,EAAA,UAAA,GAAA;AACA,QAAA,SAAA,GAAA,KAAA,OAAA,CAAA,IAAA,CAAA;;AACA,YAAA,SAAA;AACA,WAAA,CAAA;AACA,eAAA,IAAA;;AACA,WAAA,CAAA;AACA,eAAA,EAAA;AAJA;;AAMA,IAAA,SAAA;AACA,QAAA,KAAA,GAAA,EAAA;;AACA,SAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,SAAA,GAAA;AACA,UAAA,CAAA,GAAA,KAAA,QAAA,EAAA;;AACA,cAAA,CAAA,IAAA,CAAA;AACA,aAAA,EAAA;AACA,aAAA,EAAA;AACA,UAAA,KAAA,IAAA,MAAA,CAAA,YAAA,CAAA,CAAA,CAAA,GAAA,IAAA,KAAA,CAAA,GAAA,KAAA,QAAA,KAAA,IAAA,CAAA;AACA,UAAA,CAAA,IAAA,CAAA;AACA;;AACA,aAAA,EAAA;AACA,UAAA,KAAA,IAAA,MAAA,CAAA,YAAA,CAAA,CAAA,CAAA,GAAA,IAAA,KAAA,EAAA,GAAA,CAAA,KAAA,QAAA,KAAA,IAAA,KAAA,CAAA,GAAA,KAAA,QAAA,KAAA,IAAA,CAAA;AACA,UAAA,CAAA,IAAA,CAAA;AACA;;AACA;AACA,UAAA,KAAA,IAAA,MAAA,CAAA,YAAA,CAAA,CAAA,CAAA;AACA,UAAA,CAAA;AAZA;AAcA;;AACA,WAAA,KAAA;AACA;;AAEA,EAAA,SAAA,GAAA;AACA,QAAA,KAAA,GAAA,KAAA,MAAA,CAAA,UAAA,CAAA,KAAA,KAAA,CAAA;AACA,SAAA,KAAA,IAAA,CAAA;AACA,WAAA,KAAA;AACA;;AAEA,EAAA,WAAA,GAAA;AACA,WAAA,KAAA,QAAA,MAAA,CAAA;AACA;;;ACzFA;AACA;AACA;;;;AAEA,UAAA,IAAA,CAAA,WAAA,EAAA;AACA,SAAA,SAAA;AAAA,aAAA,aAAA,CAAA,OAAA;;AACA,SAAA,QAAA;AAAA,aAAA,aAAA,CAAA,MAAA;;AACA,SAAA,QAAA;AAAA,aAAA,aAAA,CAAA,MAAA;;AACA,SAAA,sBAAA;AAAA,aAAA,aAAA,CAAA,oBAAA;;AACA,SAAA,qBAAA;AAAA,aAAA,aAAA,CAAA,mBAAA;;AACA,SAAA,qBAAA;AAAA,aAAA,aAAA,CAAA,mBAAA;;AACA,SAAA,oBAAA;AAAA,aAAA,aAAA,CAAA,kBAAA;;AACA;AAAA,YAAA,IAAA,KAAA,CAAA,0BAAA,IAAA,EAAA,CAAA;AARA;AAUA;AAEA;AACA;AACA;;;;AAEA,UAAA,IAAA,CAAA,WAAA,EAAA;AACA,SAAA,gBAAA;AAAA,aAAA,WAAA,CAAA,cAAA;;AACA,SAAA,aAAA;AAAA,aAAA,WAAA,CAAA,WAAA;;AACA,SAAA,QAAA;AAAA,aAAA,WAAA,CAAA,MAAA;;AACA;AAAA,YAAA,IAAA,KAAA,CAAA,wBAAA,IAAA,EAAA,CAAA;AAJA;AAMA;AAEA;AACA;AACA;;;;;;AAEA,QAAA,OAAA,GAAA,IAAA;AAAA,EAAA,aAAA,CAAA,aAAA,CAAA,SAAA,CAAA,GAAA,OAAA,CAAA,GAAA,SAAA,C,CAAA;;AACA,QAAA,MAAA,GAAA,IAAA;AAAA,EAAA,aAAA,CAAA,aAAA,CAAA,QAAA,CAAA,GAAA,MAAA,CAAA,GAAA,QAAA,C,CAAA;;AACA,QAAA,MAAA,GAAA,IAAA;AAAA,EAAA,aAAA,CAAA,aAAA,CAAA,QAAA,CAAA,GAAA,MAAA,CAAA,GAAA,QAAA,C,CAAA;;AACA,QAAA,oBAAA,GAAA,IAAA;AAAA,EAAA,aAAA,CAAA,aAAA,CAAA,sBAAA,CAAA,GAAA,oBAAA,CAAA,GAAA,sBAAA,C,CAAA;;AACA,QAAA,mBAAA,GAAA,IAAA;AAAA,EAAA,aAAA,CAAA,aAAA,CAAA,qBAAA,CAAA,GAAA,mBAAA,CAAA,GAAA,qBAAA,C,CAAA;;AACA,QAAA,mBAAA,GAAA,IAAA;AAAA,EAAA,aAAA,CAAA,aAAA,CAAA,qBAAA,CAAA,GAAA,mBAAA,CAAA,GAAA,qBAAA,C,CAAA;;AACA,QAAA,kBAAA,GAAA,IAAA;AAAA,EAAA,aAAA,CAAA,aAAA,CAAA,oBAAA,CAAA,GAAA,kBAAA,CAAA,GAAA,oBAAA,C,CAAA;AACA,C,EAAA,aAAA,KAAA,aAAA,GAAA,EAAA,C;AAEA;AACA;AACA;;;;;;AAEA,QAAA,cAAA,GAAA,KAAA;AAAA,EAAA,WAAA,CAAA,WAAA,CAAA,gBAAA,CAAA,GAAA,cAAA,CAAA,GAAA,gBAAA,C,CAAA;;AACA,QAAA,WAAA,GAAA,KAAA;AAAA,EAAA,WAAA,CAAA,WAAA,CAAA,aAAA,CAAA,GAAA,WAAA,CAAA,GAAA,aAAA,C,CAAA;;AACA,QAAA,MAAA,GAAA,KAAA;AAAA,EAAA,WAAA,CAAA,WAAA,CAAA,QAAA,CAAA,GAAA,MAAA,CAAA,GAAA,QAAA,C,CAAA;AACA,C,EAAA,WAAA,KAAA,WAAA,GAAA,EAAA,C;AAEA;AACA;AACA;;;;;;;;;;IAIA;;;AACA,EAAA,MAAA,GAAA;AAAA,SAAA,IAAA,GAAA,IAAA;AAAA;;AAEA,EAAA,OAAA,GAAA;AAAA,SAAA,KAAA,GAAA,IAAA;AAAA;;AACA,EAAA,OAAA,GAAA;AAAA,SAAA,MAAA,GAAA,IAAA;AAAA;;AAEA,MAAA,KAAA,GAAA;AACA,UAAA,GAAA,GAAA,KAAA,OAAA;;AACA,QAAA,GAAA,CAAA,IAAA,EAAA;AACA,aAAA,GAAA,CAAA,IAAA,CAAA,KAAA;AACA;;AACA,WAAA,GAAA,CAAA,IAAA,CAAA,KAAA;AACA;;AAEA,MAAA,MAAA,GAAA;AACA,UAAA,GAAA,GAAA,KAAA,OAAA;;AACA,QAAA,GAAA,CAAA,IAAA,EAAA;AACA,aAAA,GAAA,CAAA,IAAA,CAAA,MAAA;AACA;;AACA,WAAA,GAAA,CAAA,IAAA,CAAA,MAAA;AACA;;AAEA,MAAA,CAAA,GAAA;AACA,WAAA,KAAA,OAAA,CAAA,IAAA,CAAA,EAAA;AACA;;AAEA,MAAA,CAAA,GAAA;AACA,WAAA,KAAA,OAAA,CAAA,IAAA,CAAA,EAAA;AACA;;AAEA,MAAA,EAAA,GAAA;AACA,WAAA,KAAA,OAAA,CAAA,IAAA,CAAA,EAAA;AACA;;AAEA,MAAA,EAAA,GAAA;AACA,WAAA,KAAA,OAAA,CAAA,IAAA,CAAA,EAAA;AACA;;AAEA,MAAA,OAAA,GAAA;AACA,UAAA,GAAA,GAAA,KAAA,OAAA;AACA,WAAA,GAAA,CAAA,IAAA,GAAA,GAAA,CAAA,IAAA,CAAA,CAAA,GAAA,CAAA;AACA;;AAEA,MAAA,OAAA,GAAA;AACA;AACA,WAAA,KAAA,YAAA;AACA;;AAEA,MAAA,WAAA,GAAA;AACA,UAAA,GAAA,GAAA,KAAA,OAAA;AACA,WAAA,GAAA,CAAA,IAAA,GAAA,GAAA,CAAA,IAAA,CAAA,CAAA,GAAA,CAAA;AACA;;AAEA,MAAA,YAAA,GAAA;AACA,QAAA,GAAA,GAAA,KAAA,OAAA;AACA,WAAA,KAAA,cAAA,GAAA,KAAA,MAAA,IAAA,GAAA,CAAA,IAAA,GAAA,GAAA,CAAA,IAAA,CAAA,CAAA,GAAA,CAAA,CAAA;AACA;;AAEA,MAAA,aAAA,GAAA;AACA,WAAA,KAAA,OAAA,CAAA,IAAA,CAAA,KAAA;AACA;;AAEA,MAAA,cAAA,GAAA;AACA,WAAA,KAAA,OAAA,CAAA,IAAA,CAAA,MAAA;AACA;;AAEA,MAAA,CAAA,GAAA;AACA,WAAA,KAAA,OAAA,CAAA,KAAA,CAAA,CAAA;AACA;;AAEA,MAAA,CAAA,GAAA;AACA,WAAA,KAAA,OAAA,CAAA,KAAA,CAAA,CAAA;AACA;;AAEA,MAAA,MAAA,GAAA;AACA,WAAA,KAAA,OAAA,CAAA,MAAA,KAAA,CAAA;AACA;;AAEA,MAAA,OAAA,GAAA;AACA,WAAA,CAAA,MAAA,KAAA,OAAA,CAAA,MAAA,GAAA,EAAA,IAAA,GAAA;AACA;;;;ACpIA,MAAA,YAAA,CAAA;AAAA,EAAA,WAAA,GAAA;AAAA,IAAA,YAAA,CAAA,SAAA,CAAA,MAAA,CAAA,IAAA,CAAA,IAAA;;AAAA,IAAA,YAAA,CAAA,SAAA,CAAA,OAAA,CAAA,IAAA,CAAA,IAAA;;AAAA,IAAA,YAAA,CAAA,SAAA,CAAA,OAAA,CAAA,IAAA,CAAA,IAAA;;AAAA,IAAA,YAAA,CAAA,SAAA,CAAA,OAAA,CAAA,IAAA,CAAA,IAAA;;AAAA,IAAA,YAAA,CAAA,SAAA,CAAA,OAAA,CAAA,IAAA,CAAA,IAAA;;AAAA,IAAA,YAAA,CAAA,SAAA,CAAA,OAAA,CAAA,IAAA,CAAA,IAAA;;AAAA,IAAA,YAAA,CAAA,SAAA,CAAA,OAAA,CAAA,IAAA,CAAA,IAAA;;AAAA,IAAA,YAAA,CAAA,SAAA,CAAA,OAAA,CAAA,IAAA,CAAA,IAAA;;AAAA,IAAA,YAAA,CAAA,SAAA,CAAA,OAAA,CAAA,IAAA,CAAA,IAAA;;AAAA,IAAA,YAAA,CAAA,SAAA,CAAA,QAAA,CAAA,IAAA,CAAA,IAAA;AAAA;;AACA,EAAA,MAAA,GAAA;AAAA,SAAA,CAAA,GAAA,CAAA;AAAA;;AACA,EAAA,OAAA,GAAA;AAAA,SAAA,CAAA,GAAA,CAAA;AAAA;;AACA,EAAA,OAAA,GAAA;AAAA,SAAA,KAAA,GAAA,CAAA;AAAA;;AACA,EAAA,OAAA,GAAA;AAAA,SAAA,MAAA,GAAA,CAAA;AAAA;;AACA,EAAA,OAAA,GAAA;AAAA,SAAA,OAAA,GAAA,CAAA;AAAA;;AACA,EAAA,OAAA,GAAA;AAAA,SAAA,OAAA,GAAA,CAAA;AAAA;;AACA,EAAA,OAAA,GAAA;AAAA,SAAA,aAAA,GAAA,CAAA;AAAA;;AACA,EAAA,OAAA,GAAA;AAAA,SAAA,cAAA,GAAA,CAAA;AAAA;;AACA,EAAA,OAAA,GAAA;AAAA,SAAA,MAAA,GAAA,CAAA;AAAA;;AACA,EAAA,QAAA,GAAA;AAAA,SAAA,KAAA,GAAA,CAAA;AAAA;;AAVA;AAYA;AACA;AACA;;;;AAEA,EAAA,QAAA,GAAA;AAAA,SAAA,KAAA,GAAA,IAAA,KAAA,EAAA;AAAA;;AACA,EAAA,QAAA,GAAA;AAAA,SAAA,OAAA,GAAA,IAAA,KAAA,EAAA;AAAA;;AAEA,EAAA,WAAA,CAAA,SAAA,EAAA,aAAA,EAAA,QAAA,EAAA;AAAA,IAAA,YAAA,CAAA,SAAA,CAAA,QAAA,CAAA,IAAA,CAAA,IAAA;;AAAA,IAAA,YAAA,CAAA,SAAA,CAAA,QAAA,CAAA,IAAA,CAAA,IAAA;;AACA,QAAA,SAAA,EAAA;AACA,WAAA,aAAA,CAAA,SAAA,EAAA,aAAA,EAAA,QAAA;AACA;AACA;;AAEA,EAAA,UAAA,CAAA,IAAA,EAAA,OAAA,EAAA;AACA,QAAA,KAAA,GAAA,KAAA,KAAA;AACA,QAAA,IAAA,GAAA,IAAA;;AACA,SAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,KAAA,CAAA,MAAA,EAAA,CAAA,EAAA,EAAA;AACA,UAAA,KAAA,CAAA,CAAA,CAAA,CAAA,WAAA,KAAA,OAAA,CAAA,WAAA,EAAA;AACA,QAAA,IAAA,GAAA,KAAA,CAAA,CAAA,CAAA;AACA;AACA;AACA;;AACA,QAAA,IAAA,KAAA,IAAA,EAAA;AACA,MAAA,IAAA,GAAA,IAAA,gBAAA,EAAA;AACA,MAAA,IAAA,CAAA,IAAA,GAAA,aAAA;AACA,UAAA,WAAA,GAAA,OAAA,CAAA,WAAA;AACA,MAAA,IAAA,CAAA,KAAA,GAAA,WAAA,CAAA,SAAA;AACA,MAAA,IAAA,CAAA,MAAA,GAAA,WAAA,CAAA,UAAA;AACA,MAAA,IAAA,CAAA,WAAA,GAAA,WAAA,CANA,CAOA;;AACA,MAAA,IAAA,CAAA,SAAA,GAAA,IAAA,CAAA,SAAA,GAAA,aAAA,CAAA,OAAA;AACA,MAAA,IAAA,CAAA,KAAA,GAAA,WAAA,CAAA,WAAA;AACA,MAAA,IAAA,CAAA,KAAA,GAAA,WAAA,CAAA,WAAA;AACA,MAAA,KAAA,CAAA,IAAA,CAAA,IAAA;AACA;;AACA,QAAA,MAAA,GAAA,IAAA,kBAAA,EAAA;AACA,IAAA,MAAA,CAAA,IAAA,GAAA,IAAA;AACA,IAAA,MAAA,CAAA,IAAA,GAAA,IAAA;AACA,IAAA,MAAA,CAAA,OAAA,GAAA,OAAA;AACA,IAAA,MAAA,CAAA,KAAA,GAAA,CAAA,CAAA;AACA,SAAA,OAAA,CAAA,IAAA,CAAA,MAAA;AACA,WAAA,MAAA;AACA;;AAEA,EAAA,cAAA,CAAA,QAAA,EAAA,cAAA,EAAA;AACA,SAAA,IAAA,GAAA,IAAA,QAAA,EAAA;AACA,UAAA,QAAA,CAAA,cAAA,CAAA,GAAA,CAAA,EAAA;AACA,aAAA,UAAA,CAAA,cAAA,IAAA,GAAA,CAAA,OAAA,CAAA,GAAA,MAAA,CAAA,CAAA,GAAA,GAAA,CAAA,MAAA,CAAA,CAAA,EAAA,GAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,GAAA,EAAA,QAAA,CAAA,GAAA,CAAA;AACA;AACA;AACA;;AAEA,EAAA,aAAA,CAAA,SAAA,EAAA,aAAA,EAAA,QAAA,EAAA;AACA,WAAA,KAAA,IAAA,CAAA,SAAA,EAAA,aAAA,EAAA,QAAA,CAAA;AACA;;AAEA,EAAA,IAAA,CAAA,SAAA,EAAA,aAAA,EAAA,QAAA,EAAA;AACA,QAAA,aAAA,IAAA,IAAA,EACA,MAAA,IAAA,KAAA,CAAA,+BAAA,CAAA;AAEA,QAAA,MAAA,GAAA,IAAA,kBAAA,CAAA,SAAA,CAAA;AACA,QAAA,KAAA,GAAA,IAAA,KAAA,CAAA,CAAA,CAAA;AACA,QAAA,IAAA,GAAA,IAAA;AACA,QAAA,UAAA,GAAA,EAAA;AACA,QAAA,MAAA,GAAA,IAAA;;AACA,IAAA,UAAA,CAAA,MAAA,CAAA,GAAA,MAAA;AACA,MAAA,IAAA,CAAA,KAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,MAAA,IAAA,CAAA,MAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,KAHA;;AAIA,IAAA,UAAA,CAAA,QAAA,CAAA,GAAA,MAAA,CACA;AACA,KAFA;;AAGA,IAAA,UAAA,CAAA,QAAA,CAAA,GAAA,MAAA;AACA,MAAA,IAAA,CAAA,SAAA,GAAA,gBAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,MAAA,IAAA,CAAA,SAAA,GAAA,gBAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,KAHA;;AAIA,IAAA,UAAA,CAAA,QAAA,CAAA,GAAA,MAAA;AACA,UAAA,KAAA,CAAA,CAAA,CAAA,CAAA,OAAA,CAAA,GAAA,KAAA,CAAA,CAAA,EAAA,IAAA,CAAA,KAAA,GAAA,WAAA,CAAA,MAAA;AACA,UAAA,KAAA,CAAA,CAAA,CAAA,CAAA,OAAA,CAAA,GAAA,KAAA,CAAA,CAAA,EAAA,IAAA,CAAA,KAAA,GAAA,WAAA,CAAA,MAAA;AACA,KAHA;;AAIA,IAAA,UAAA,CAAA,KAAA,CAAA,GAAA,MAAA;AACA,MAAA,IAAA,CAAA,GAAA,GAAA,KAAA,CAAA,CAAA,CAAA,IAAA,MAAA;AACA,KAFA;;AAIA,QAAA,YAAA,GAAA,EAAA;;AACA,IAAA,YAAA,CAAA,IAAA,CAAA,GAAA,MAAA;AAAA;AACA,MAAA,MAAA,CAAA,CAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,MAAA,MAAA,CAAA,CAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,KAHA;;AAIA,IAAA,YAAA,CAAA,MAAA,CAAA,GAAA,MAAA;AAAA;AACA,MAAA,MAAA,CAAA,KAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,MAAA,MAAA,CAAA,MAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,KAHA;;AAIA,IAAA,YAAA,CAAA,QAAA,CAAA,GAAA,MAAA;AACA,MAAA,MAAA,CAAA,CAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,MAAA,MAAA,CAAA,CAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,MAAA,MAAA,CAAA,KAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,MAAA,MAAA,CAAA,MAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,KALA;;AAMA,IAAA,YAAA,CAAA,QAAA,CAAA,GAAA,MAAA;AAAA;AACA,MAAA,MAAA,CAAA,OAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,MAAA,MAAA,CAAA,OAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,KAHA;;AAIA,IAAA,YAAA,CAAA,MAAA,CAAA,GAAA,MAAA;AAAA;AACA,MAAA,MAAA,CAAA,aAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,MAAA,MAAA,CAAA,cAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,KAHA;;AAIA,IAAA,YAAA,CAAA,SAAA,CAAA,GAAA,MAAA;AACA,MAAA,MAAA,CAAA,OAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,MAAA,MAAA,CAAA,OAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,MAAA,MAAA,CAAA,aAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,MAAA,MAAA,CAAA,cAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,KALA;;AAMA,IAAA,YAAA,CAAA,QAAA,CAAA,GAAA,MAAA;AACA,UAAA,WAAA,GAAA,KAAA,CAAA,CAAA,CAAA;AACA,UAAA,MAAA,GAAA,CAAA;;AACA,UAAA,WAAA,CAAA,iBAAA,MAAA,MAAA,EAAA;AACA,QAAA,MAAA,GAAA,CAAA;AACA,OAFA,MAEA,IAAA,WAAA,CAAA,iBAAA,MAAA,OAAA,EAAA;AACA,QAAA,MAAA,GAAA,CAAA;AACA,OAFA,MAEA;AACA,QAAA,MAAA,GAAA,CAAA,MAAA,UAAA,CAAA,WAAA,CAAA,IAAA,GAAA,GAAA,EAAA;AACA;;AACA,MAAA,MAAA,CAAA,MAAA,GAAA,MAAA;AACA,KAXA;;AAYA,IAAA,YAAA,CAAA,OAAA,CAAA,GAAA,MAAA;AACA,MAAA,MAAA,CAAA,KAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,KAFA;;AAIA,QAAA,IAAA,GAAA,MAAA,CAAA,QAAA,EAAA,CAzEA,CA0EA;;AACA,WAAA,IAAA,IAAA,IAAA,IAAA,IAAA,CAAA,IAAA,GAAA,MAAA,IAAA,CAAA,EACA,IAAA,GAAA,MAAA,CAAA,QAAA,EAAA,CA5EA,CA6EA;;;AACA,WAAA,IAAA,EAAA;AACA,UAAA,IAAA,IAAA,IAAA,IAAA,IAAA,CAAA,IAAA,GAAA,MAAA,IAAA,CAAA,EAAA;AACA,UAAA,MAAA,CAAA,SAAA,CAAA,KAAA,EAAA,IAAA,KAAA,CAAA,EAAA,MAFA,CAEA;;AACA,MAAA,IAAA,GAAA,MAAA,CAAA,QAAA,EAAA;AACA;;AAEA,QAAA,aAAA,GAAA,MAAA;AACA,aAAA,IAAA,EAAA;AACA,YAAA,IAAA,IAAA,IAAA,EAAA;AACA,iBAAA,QAAA,IAAA,QAAA,CAAA,IAAA,CAAA;AACA;;AACA,YAAA,IAAA,CAAA,IAAA,GAAA,MAAA,IAAA,CAAA,EAAA;AACA,UAAA,IAAA,GAAA,IAAA;AACA,UAAA,IAAA,GAAA,MAAA,CAAA,QAAA,EAAA;AACA,SAHA,MAGA,IAAA,IAAA,KAAA,IAAA,EAAA;AACA,UAAA,IAAA,GAAA,IAAA,gBAAA,EAAA;AACA,UAAA,IAAA,CAAA,IAAA,GAAA,IAAA,CAAA,IAAA,EAAA;;AAEA,iBAAA,IAAA,EAAA;AACA,gBAAA,MAAA,CAAA,SAAA,CAAA,KAAA,EAAA,IAAA,GAAA,MAAA,CAAA,QAAA,EAAA,KAAA,CAAA,EAAA;AACA,gBAAA,KAAA,GAAA,UAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,gBAAA,KAAA,EAAA,KAAA;AACA;;AACA,eAAA,KAAA,CAAA,IAAA,CAAA,IAAA;AAEA,UAAA,aAAA,CAAA,IAAA,CAAA,IAAA,EAAA,OAAA,IAAA;AACA,gBAAA,OAAA,KAAA,IAAA,EAAA;AACA,mBAAA,KAAA,CAAA,MAAA,CAAA,KAAA,KAAA,CAAA,OAAA,CAAA,IAAA,CAAA,EAAA,CAAA;AACA,qBAAA,QAAA,IAAA,QAAA,CAAA,IAAA,CAAA;AACA;;AACA,YAAA,IAAA,CAAA,WAAA,GAAA,OAAA,CALA,CAMA;;AACA,gBAAA,IAAA,CAAA,GAAA,EAAA;AACA,cAAA,OAAA,CAAA,SAAA,GAAA,WAAA,CAAA,GAAA;AACA;;AACA,gBAAA,CAAA,OAAA,CAAA,KAAA,EAAA;AACA,cAAA,OAAA,CAAA,OAAA,CAAA,IAAA,CAAA,KAAA,EAAA,IAAA,CAAA,MAAA;AACA;;AACA,iBAAA,KAAA,CAAA,IAAA,CAAA,IAAA;AACA,YAAA,IAAA,CAAA,UAAA;;AAEA,gBAAA,CAAA,IAAA,CAAA,KAAA,IAAA,CAAA,IAAA,CAAA,MAAA,EAAA;AACA,cAAA,IAAA,CAAA,KAAA,GAAA,OAAA,CAAA,SAAA;AACA,cAAA,IAAA,CAAA,MAAA,GAAA,OAAA,CAAA,UAAA;;AACA,kBAAA,CAAA,IAAA,CAAA,KAAA,IAAA,CAAA,IAAA,CAAA,MAAA,EAAA;AACA,gBAAA,OAAA,CAAA,GAAA,CAAA,4BAAA,IAAA,CAAA,IAAA,GAAA,kIAAA;AACA;AACA;;AACA,YAAA,aAAA;AACA,WAxBA,CAAA;AAyBA,eAAA,KAAA,CAAA,IAAA,CAAA,IAAA;AACA;AACA,SAtCA,MAsCA;AACA,UAAA,MAAA,GAAA,IAAA,YAAA,EAAA;AACA,cAAA,WAAA,GAAA,IAAA,kBAAA,EAAA;AACA,UAAA,WAAA,CAAA,IAAA,GAAA,IAAA;AACA,UAAA,WAAA,CAAA,IAAA,GAAA,IAAA;AACA,cAAA,KAAA,GAAA,IAAA;AACA,cAAA,MAAA,GAAA,IAAA;;AACA,iBAAA,IAAA,EAAA;AACA,gBAAA,KAAA,GAAA,MAAA,CAAA,SAAA,CAAA,KAAA,EAAA,IAAA,GAAA,MAAA,CAAA,QAAA,EAAA,CAAA;AACA,gBAAA,KAAA,IAAA,CAAA,EAAA;AACA,gBAAA,KAAA,GAAA,YAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA,gBAAA,KAAA,EACA,KAAA,GADA,KAEA;AACA,kBAAA,KAAA,IAAA,IAAA,EAAA;AACA,gBAAA,KAAA,GAAA,EAAA;AACA,gBAAA,MAAA,GAAA,EAAA;AACA;;AACA,cAAA,KAAA,CAAA,IAAA,CAAA,KAAA,CAAA,CAAA,CAAA;AACA,kBAAA,WAAA,GAAA,EAAA;;AACA,mBAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,KAAA,EAAA,CAAA,EAAA,EACA,WAAA,CAAA,IAAA,CAAA,QAAA,CAAA,KAAA,CAAA,CAAA,GAAA,CAAA,CAAA,CAAA;;AACA,cAAA,MAAA,CAAA,IAAA,CAAA,WAAA;AACA;AACA;;AACA,cAAA,MAAA,CAAA,aAAA,IAAA,CAAA,IAAA,MAAA,CAAA,cAAA,IAAA,CAAA,EAAA;AACA,YAAA,MAAA,CAAA,aAAA,GAAA,MAAA,CAAA,KAAA;AACA,YAAA,MAAA,CAAA,cAAA,GAAA,MAAA,CAAA,MAAA;AACA;;AAEA,cAAA,UAAA,GAAA,IAAA,CAAA,WAAA,CAAA,UAAA;AACA,UAAA,MAAA,CAAA,CAAA,IAAA,UAAA;AACA,UAAA,MAAA,CAAA,CAAA,IAAA,UAAA;AACA,UAAA,MAAA,CAAA,KAAA,IAAA,UAAA;AACA,UAAA,MAAA,CAAA,MAAA,IAAA,UAAA;AACA,UAAA,MAAA,CAAA,aAAA,IAAA,UAAA;AACA,UAAA,MAAA,CAAA,cAAA,IAAA,UAAA;AACA,UAAA,MAAA,CAAA,OAAA,IAAA,UAAA;AACA,UAAA,MAAA,CAAA,OAAA,IAAA,UAAA;AAEA,gBAAA,MAAA,GAAA,MAAA,CAAA,MAAA,GAAA,CAAA,KAAA,CAAA;AACA,cAAA,KAAA,GAAA,IAAA,SAAA,CAAA,MAAA,CAAA,CAAA,EAAA,MAAA,CAAA,CAAA,EAAA,MAAA,GAAA,MAAA,CAAA,MAAA,GAAA,MAAA,CAAA,KAAA,EAAA,MAAA,GAAA,MAAA,CAAA,KAAA,GAAA,MAAA,CAAA,MAAA,CAAA;AAEA,cAAA,IAAA,GAAA,IAAA,SAAA,CAAA,CAAA,EAAA,CAAA,EAAA,MAAA,CAAA,aAAA,EAAA,MAAA,CAAA,cAAA,CAAA;AACA,cAAA,IAAA,GAAA,IAAA,SAAA,CAAA,MAAA,CAAA,OAAA,EAAA,MAAA,CAAA,cAAA,GAAA,MAAA,CAAA,MAAA,GAAA,MAAA,CAAA,OAAA,EAAA,MAAA,CAAA,KAAA,EAAA,MAAA,CAAA,MAAA,CAAA;AAEA,UAAA,WAAA,CAAA,OAAA,GAAA,IAAA,OAAA,CAAA,WAAA,CAAA,IAAA,CAAA,WAAA,EAAA,KAAA,EAAA,IAAA,EAAA,IAAA,EAAA,MAAA,CAAA,MAAA,CAAA;AACA,UAAA,WAAA,CAAA,KAAA,GAAA,MAAA,CAAA,KAAA;AACA,UAAA,WAAA,CAAA,OAAA,CAAA,SAAA;AAEA,eAAA,OAAA,CAAA,IAAA,CAAA,WAAA;AACA;AACA;AACA,KAnGA;;AAqGA,IAAA,aAAA;AACA;;AAEA,EAAA,UAAA,CAAA,IAAA,EAAA;AACA,SAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,KAAA,OAAA,CAAA,MAAA,EAAA,CAAA,EAAA,EAAA;AACA,UAAA,KAAA,OAAA,CAAA,CAAA,EAAA,IAAA,IAAA,IAAA,EAAA;AACA,eAAA,KAAA,OAAA,CAAA,CAAA,CAAA;AACA;AACA;;AACA,WAAA,IAAA;AACA;;AAEA,EAAA,OAAA,GAAA;AACA,SAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,KAAA,KAAA,CAAA,MAAA,EAAA,CAAA,EAAA,EAAA;AACA,WAAA,KAAA,CAAA,CAAA,EAAA,WAAA,CAAA,OAAA;AACA;AACA;;;AAGA;AACA;AACA;;;AACA,MAAA,kBAAA,CAAA;AAEA,EAAA,QAAA,GAAA;AAAA,SAAA,KAAA,GAAA,CAAA;AAAA;;AAEA,EAAA,WAAA,CAAA,IAAA,EAAA;AAAA,IAAA,kBAAA,CAAA,SAAA,CAAA,QAAA,CAAA,IAAA,CAAA,IAAA;;AACA,SAAA,KAAA,GAAA,IAAA,CAAA,KAAA,CAAA,YAAA,CAAA;AACA;;AAEA,EAAA,QAAA,GAAA;AACA,QAAA,KAAA,KAAA,IAAA,KAAA,KAAA,CAAA,MAAA,EACA,OAAA,IAAA;AACA,WAAA,KAAA,KAAA,CAAA,KAAA,KAAA,EAAA,CAAA;AACA;;AAEA,EAAA,SAAA,CAAA,KAAA,EAAA,IAAA,EAAA;AACA,QAAA,IAAA,IAAA,IAAA,EAAA,OAAA,CAAA;AACA,IAAA,IAAA,GAAA,IAAA,CAAA,IAAA,EAAA;AACA,QAAA,IAAA,CAAA,MAAA,IAAA,CAAA,EAAA,OAAA,CAAA;AAEA,QAAA,KAAA,GAAA,IAAA,CAAA,OAAA,CAAA,GAAA,CAAA;AACA,QAAA,KAAA,IAAA,CAAA,CAAA,EAAA,OAAA,CAAA;AACA,IAAA,KAAA,CAAA,CAAA,CAAA,GAAA,IAAA,CAAA,MAAA,CAAA,CAAA,EAAA,KAAA,EAAA,IAAA,EAAA;;AACA,SAAA,IAAA,CAAA,GAAA,CAAA,EAAA,SAAA,GAAA,KAAA,GAAA,CAAA,GAAA,CAAA,EAAA,EAAA;AACA,UAAA,KAAA,GAAA,IAAA,CAAA,OAAA,CAAA,GAAA,EAAA,SAAA,CAAA;;AACA,UAAA,KAAA,IAAA,CAAA,CAAA,EAAA;AACA,QAAA,KAAA,CAAA,CAAA,CAAA,GAAA,IAAA,CAAA,MAAA,CAAA,SAAA,EAAA,IAAA,EAAA;AACA,eAAA,CAAA;AACA;;AACA,MAAA,KAAA,CAAA,CAAA,CAAA,GAAA,IAAA,CAAA,MAAA,CAAA,SAAA,EAAA,KAAA,GAAA,SAAA,EAAA,IAAA,EAAA;AACA,MAAA,SAAA,GAAA,KAAA,GAAA,CAAA;AACA,UAAA,CAAA,IAAA,CAAA,EAAA,OAAA,CAAA;AACA;AACA;;AAhCA;AAmCA;AACA;AACA;;;;;;;;;;;;;;AAGA,EAAA,QAAA,GAAA;AAAA,SAAA,SAAA,GAAA,aAAA,CAAA,OAAA;AAAA;;AACA,EAAA,QAAA,GAAA;AAAA,SAAA,SAAA,GAAA,aAAA,CAAA,OAAA;AAAA;;AACA,EAAA,QAAA,GAAA;AAAA,SAAA,KAAA,GAAA,WAAA,CAAA,WAAA;AAAA;;AACA,EAAA,QAAA,GAAA;AAAA,SAAA,KAAA,GAAA,WAAA,CAAA,WAAA;AAAA;;AAMA,EAAA,UAAA,GAAA;AACA,QAAA,GAAA,GAAA,KAAA,WAAA;AACA,QAAA,MAAA,GAAA,KAAA,SAAA;;AACA,QAAA,MAAA,IAAA,aAAA,CAAA,MAAA,EAAA;AACA,MAAA,GAAA,CAAA,SAAA,GAAA,WAAA,CAAA,MAAA;AACA,KAFA,MAEA,IAAA,KAAA,SAAA,IAAA,aAAA,CAAA,OAAA,EAAA;AACA,MAAA,GAAA,CAAA,SAAA,GAAA,WAAA,CAAA,OAAA;AACA,KAFA,MAEA;AACA,MAAA,GAAA,CAAA,MAAA,GAAA,YAAA,CAAA,IAAA;;AACA,UAAA,MAAA,IAAA,aAAA,CAAA,oBAAA,EAAA;AACA,QAAA,GAAA,CAAA,SAAA,GAAA,WAAA,CAAA,OAAA;AACA,OAFA,MAEA;AACA,QAAA,GAAA,CAAA,SAAA,GAAA,WAAA,CAAA,MAAA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;;AC7VA,IAAA,eAAA,GAAA,UAAA,KAAA,EAAA;AACA,SAAA,UAAA,CAAA,EAAA;AACA,WAAA,KAAA,CAAA,CAAA,CAAA,GAAA,CAAA,EAAA,KAAA,CAAA,CAAA,CAAA;AACA,GAFA;AAGA,CAJA,CAIA,IAAA,YAAA,CAAA,CAAA,CAJA,CAAA;;AAMA,IAAA,MAAA,GACA,IAAA,CAAA,MAAA,IAAA,eADA;AAEA;AACA;AACA;;AAKA;AACA;AACA;;;;;;;AAEA,EAAA,MAAA,GAAA;AAAA,SAAA,KAAA,GAAA,IAAA,KAAA,EAAA;AAAA;;AAEA,EAAA,GAAA,CAAA,KAAA,EAAA;AACA,QAAA,QAAA,GAAA,KAAA,QAAA,CAAA,KAAA,CAAA;AACA,SAAA,KAAA,CAAA,KAAA,GAAA,CAAA,IAAA,KAAA,GAAA,CAAA;AACA,WAAA,CAAA,QAAA;AACA;;AAEA,EAAA,QAAA,CAAA,KAAA,EAAA;AACA,WAAA,KAAA,KAAA,CAAA,KAAA,GAAA,CAAA,KAAA,SAAA;AACA;;AAEA,EAAA,MAAA,CAAA,KAAA,EAAA;AACA,SAAA,KAAA,CAAA,KAAA,GAAA,CAAA,IAAA,SAAA;AACA;;AAEA,EAAA,KAAA,GAAA;AACA,SAAA,KAAA,CAAA,MAAA,GAAA,CAAA;AACA;;;AAGA;AACA;AACA;;;;;;;;;;AAEA,EAAA,OAAA,GAAA;AAAA,SAAA,OAAA,GAAA,EAAA;AAAA;;AACA,EAAA,OAAA,GAAA;AAAA,SAAA,IAAA,GAAA,CAAA;AAAA;;AAEA,EAAA,GAAA,CAAA,KAAA,EAAA;AACA,QAAA,QAAA,GAAA,KAAA,OAAA,CAAA,KAAA,CAAA;AACA,SAAA,OAAA,CAAA,KAAA,IAAA,IAAA;;AACA,QAAA,CAAA,QAAA,EAAA;AACA,WAAA,IAAA;AACA,aAAA,IAAA;AACA;;AACA,WAAA,KAAA;AACA;;AAEA,EAAA,MAAA,CAAA,MAAA,EAAA;AACA,QAAA,OAAA,GAAA,KAAA,IAAA;;AACA,SAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,MAAA,CAAA,MAAA,EAAA,CAAA,GAAA,CAAA,EAAA,CAAA,EAAA,EACA,KAAA,GAAA,CAAA,MAAA,CAAA,CAAA,CAAA;;AACA,WAAA,OAAA,IAAA,KAAA,IAAA;AACA;;AAEA,EAAA,QAAA,CAAA,KAAA,EAAA;AACA,WAAA,KAAA,OAAA,CAAA,KAAA,CAAA;AACA;;AAEA,EAAA,KAAA,GAAA;AACA,SAAA,OAAA,GAAA,EAAA;AACA,SAAA,IAAA,GAAA,CAAA;AACA;;;AAGA;AACA;AACA;;AAYA;AACA;AACA;;;;AAEA,SAAA,YAAA,GAAA;AAAA,SAAA,KAAA,GAAA,IAAA,KAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA;AAAA;;AACA,SAAA,aAAA,GAAA;AAAA,SAAA,GAAA,GAAA,IAAA,KAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA;AAAA;;AACA,SAAA,aAAA,GAAA;AAAA,SAAA,KAAA,GAAA,IAAA,KAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA;AAAA;;AACA,SAAA,aAAA,GAAA;AAAA,SAAA,IAAA,GAAA,IAAA,KAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA;AAAA;;AACA,SAAA,aAAA,GAAA;AAAA,SAAA,OAAA,GAAA,IAAA,KAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA;AAAA;;AAEA,EAAA,WAAA,CAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,CAAA,EAAA;AAAA,SAAA,CAAA,GAAA,CAAA;AAAA,SAAA,CAAA,GAAA,CAAA;AAAA,SAAA,CAAA,GAAA,CAAA;AAAA,SAAA,CAAA,GAAA,CAAA;AACA;;AAEA,EAAA,GAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA;AACA,SAAA,CAAA,GAAA,CAAA;AACA,SAAA,CAAA,GAAA,CAAA;AACA,SAAA,CAAA,GAAA,CAAA;AACA,SAAA,CAAA,GAAA,CAAA;AACA,WAAA,KAAA,KAAA,EAAA;AACA;;AAEA,EAAA,YAAA,CAAA,CAAA,EAAA;AACA,SAAA,CAAA,GAAA,CAAA,CAAA,CAAA;AACA,SAAA,CAAA,GAAA,CAAA,CAAA,CAAA;AACA,SAAA,CAAA,GAAA,CAAA,CAAA,CAAA;AACA,SAAA,CAAA,GAAA,CAAA,CAAA,CAAA;AACA,WAAA,IAAA;AACA;;AAEA,EAAA,aAAA,CAAA,GAAA,EAAA;AACA,IAAA,GAAA,GAAA,GAAA,CAAA,MAAA,CAAA,CAAA,KAAA,GAAA,GAAA,GAAA,CAAA,MAAA,CAAA,CAAA,CAAA,GAAA,GAAA;AACA,SAAA,CAAA,GAAA,QAAA,CAAA,GAAA,CAAA,MAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,EAAA,CAAA,GAAA,GAAA;AACA,SAAA,CAAA,GAAA,QAAA,CAAA,GAAA,CAAA,MAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,EAAA,CAAA,GAAA,GAAA;AACA,SAAA,CAAA,GAAA,QAAA,CAAA,GAAA,CAAA,MAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,EAAA,CAAA,GAAA,GAAA;AACA,SAAA,CAAA,GAAA,GAAA,CAAA,MAAA,IAAA,CAAA,GAAA,CAAA,GAAA,QAAA,CAAA,GAAA,CAAA,MAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,EAAA,CAAA,GAAA,GAAA;AACA,WAAA,IAAA;AACA;;AAEA,EAAA,GAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA;AACA,SAAA,CAAA,IAAA,CAAA;AACA,SAAA,CAAA,IAAA,CAAA;AACA,SAAA,CAAA,IAAA,CAAA;AACA,SAAA,CAAA,IAAA,CAAA;AACA,WAAA,KAAA,KAAA,EAAA;AACA;;AAEA,EAAA,KAAA,GAAA;AACA,QAAA,KAAA,CAAA,GAAA,CAAA,EAAA,KAAA,CAAA,GAAA,CAAA,CAAA,KACA,IAAA,KAAA,CAAA,GAAA,CAAA,EAAA,KAAA,CAAA,GAAA,CAAA;AAEA,QAAA,KAAA,CAAA,GAAA,CAAA,EAAA,KAAA,CAAA,GAAA,CAAA,CAAA,KACA,IAAA,KAAA,CAAA,GAAA,CAAA,EAAA,KAAA,CAAA,GAAA,CAAA;AAEA,QAAA,KAAA,CAAA,GAAA,CAAA,EAAA,KAAA,CAAA,GAAA,CAAA,CAAA,KACA,IAAA,KAAA,CAAA,GAAA,CAAA,EAAA,KAAA,CAAA,GAAA,CAAA;AAEA,QAAA,KAAA,CAAA,GAAA,CAAA,EAAA,KAAA,CAAA,GAAA,CAAA,CAAA,KACA,IAAA,KAAA,CAAA,GAAA,CAAA,EAAA,KAAA,CAAA,GAAA,CAAA;AACA,WAAA,IAAA;AACA;;AAEA,SAAA,eAAA,CAAA,KAAA,EAAA,KAAA,EAAA;AACA,IAAA,KAAA,CAAA,CAAA,GAAA,CAAA,CAAA,KAAA,GAAA,UAAA,MAAA,EAAA,IAAA,GAAA;AACA,IAAA,KAAA,CAAA,CAAA,GAAA,CAAA,CAAA,KAAA,GAAA,UAAA,MAAA,EAAA,IAAA,GAAA;AACA,IAAA,KAAA,CAAA,CAAA,GAAA,CAAA,CAAA,KAAA,GAAA,UAAA,MAAA,CAAA,IAAA,GAAA;AACA,IAAA,KAAA,CAAA,CAAA,GAAA,CAAA,KAAA,GAAA,UAAA,IAAA,GAAA;AACA;;AAEA,SAAA,aAAA,CAAA,KAAA,EAAA,KAAA,EAAA;AACA,IAAA,KAAA,CAAA,CAAA,GAAA,CAAA,CAAA,KAAA,GAAA,UAAA,MAAA,EAAA,IAAA,GAAA;AACA,IAAA,KAAA,CAAA,CAAA,GAAA,CAAA,CAAA,KAAA,GAAA,UAAA,MAAA,CAAA,IAAA,GAAA;AACA,IAAA,KAAA,CAAA,CAAA,GAAA,CAAA,KAAA,GAAA,UAAA,IAAA,GAAA;AACA;;AAEA,SAAA,UAAA,CAAA,GAAA,EAAA;AACA,WAAA,IAAA,KAAA,GAAA,aAAA,CAAA,GAAA,CAAA;AACA;;;;AACA,KAAA,CAAA,YAAA;;AAAA,KAAA,CAAA,aAAA;;AAAA,KAAA,CAAA,aAAA;;AAAA,KAAA,CAAA,aAAA;;AAAA,KAAA,CAAA,aAAA;AAEA;AACA;AACA;;;;AAEA,SAAA,aAAA,GAAA;AAAA,SAAA,EAAA,GAAA,SAAA;AAAA;;AACA,SAAA,aAAA,GAAA;AAAA,SAAA,GAAA,GAAA,SAAA,CAAA,EAAA,GAAA,CAAA;AAAA;;AACA,SAAA,aAAA,GAAA;AAAA,SAAA,gBAAA,GAAA,MAAA,SAAA,CAAA,EAAA;AAAA;;AACA,SAAA,aAAA,GAAA;AAAA,SAAA,MAAA,GAAA,SAAA,CAAA,gBAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,gBAAA,GAAA,SAAA,CAAA,EAAA,GAAA,GAAA;AAAA;;AACA,SAAA,cAAA,GAAA;AAAA,SAAA,MAAA,GAAA,SAAA,CAAA,gBAAA;AAAA;;AAEA,SAAA,KAAA,CAAA,KAAA,EAAA,GAAA,EAAA,GAAA,EAAA;AACA,QAAA,KAAA,GAAA,GAAA,EAAA,OAAA,GAAA;AACA,QAAA,KAAA,GAAA,GAAA,EAAA,OAAA,GAAA;AACA,WAAA,KAAA;AACA;;AAEA,SAAA,MAAA,CAAA,OAAA,EAAA;AACA,WAAA,IAAA,CAAA,GAAA,CAAA,OAAA,GAAA,SAAA,CAAA,MAAA,CAAA;AACA;;AAEA,SAAA,MAAA,CAAA,OAAA,EAAA;AACA,WAAA,IAAA,CAAA,GAAA,CAAA,OAAA,GAAA,SAAA,CAAA,MAAA,CAAA;AACA;;AAEA,SAAA,MAAA,CAAA,KAAA,EAAA;AACA,WAAA,KAAA,GAAA,CAAA,GAAA,CAAA,GAAA,KAAA,GAAA,CAAA,GAAA,CAAA,CAAA,GAAA,CAAA;AACA;;AAEA,SAAA,KAAA,CAAA,CAAA,EAAA;AACA,WAAA,CAAA,GAAA,CAAA,GAAA,IAAA,CAAA,KAAA,CAAA,CAAA,CAAA,GAAA,IAAA,CAAA,IAAA,CAAA,CAAA,CAAA;AACA;;AAEA,SAAA,IAAA,CAAA,CAAA,EAAA;AACA,QAAA,CAAA,GAAA,IAAA,CAAA,GAAA,CAAA,IAAA,CAAA,GAAA,CAAA,CAAA,CAAA,EAAA,IAAA,CAAA,CAAA;AACA,WAAA,CAAA,GAAA,CAAA,GAAA,CAAA,CAAA,GAAA,CAAA;AACA;;AAEA,SAAA,gBAAA,CAAA,GAAA,EAAA,GAAA,EAAA;AACA,WAAA,SAAA,CAAA,oBAAA,CAAA,GAAA,EAAA,GAAA,EAAA,CAAA,GAAA,GAAA,GAAA,IAAA,GAAA,CAAA;AACA;;AAEA,SAAA,oBAAA,CAAA,GAAA,EAAA,GAAA,EAAA,IAAA,EAAA;AACA,QAAA,CAAA,GAAA,IAAA,CAAA,MAAA,EAAA;AACA,QAAA,CAAA,GAAA,GAAA,GAAA,GAAA;AACA,QAAA,CAAA,IAAA,CAAA,IAAA,GAAA,GAAA,IAAA,CAAA,EAAA,OAAA,GAAA,GAAA,IAAA,CAAA,IAAA,CAAA,CAAA,GAAA,CAAA,IAAA,IAAA,GAAA,GAAA,CAAA,CAAA;AACA,WAAA,GAAA,GAAA,IAAA,CAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA,IAAA,GAAA,GAAA,IAAA,CAAA,CAAA;AACA;;;;AACA,SAAA,CAAA,aAAA;;AAAA,SAAA,CAAA,aAAA;;AAAA,SAAA,CAAA,aAAA;;AAAA,SAAA,CAAA,aAAA;;AAAA,SAAA,CAAA,cAAA;;AAAA,SAAA,CAAA,cAAA;AAEA;AACA;AACA;;;;AAGA,EAAA,KAAA,CAAA,KAAA,EAAA,GAAA,EAAA,CAAA,EAAA;AACA,WAAA,KAAA,GAAA,CAAA,GAAA,GAAA,KAAA,IAAA,KAAA,aAAA,CAAA,CAAA,CAAA;AACA;;;AAGA;AACA;AACA;;;;AAEA,EAAA,OAAA,GAAA;AAAA,SAAA,KAAA,GAAA,CAAA;AAAA;;AAEA,EAAA,WAAA,CAAA,KAAA,EAAA;AACA;;AAAA,IAAA,GAAA,CAAA,SAAA,CAAA,OAAA,CAAA,IAAA,CAAA,IAAA;;AACA,SAAA,KAAA,GAAA,KAAA;AACA;;AAEA,EAAA,aAAA,CAAA,CAAA,EAAA;AACA,QAAA,CAAA,IAAA,GAAA,EAAA,OAAA,IAAA,CAAA,GAAA,CAAA,CAAA,GAAA,CAAA,EAAA,KAAA,KAAA,IAAA,CAAA;AACA,WAAA,IAAA,CAAA,GAAA,CAAA,CAAA,CAAA,GAAA,CAAA,IAAA,CAAA,EAAA,KAAA,KAAA,KAAA,KAAA,KAAA,GAAA,CAAA,IAAA,CAAA,GAAA,CAAA,CAAA,GAAA,CAAA,IAAA,CAAA;AACA;;;AAGA;AACA;AACA;;;;AAEA,EAAA,WAAA,CAAA,KAAA,EAAA;AACA,UAAA,KAAA;AACA;;AAEA,EAAA,aAAA,CAAA,CAAA,EAAA;AACA,WAAA,IAAA,CAAA,GAAA,CAAA,CAAA,GAAA,CAAA,EAAA,KAAA,KAAA,KAAA,KAAA,KAAA,GAAA,CAAA,IAAA,CAAA,GAAA,CAAA,CAAA,GAAA,CAAA,IAAA,CAAA;AACA;;;AAGA;AACA;AACA;;;;AAEA,SAAA,cAAA,GAAA;AAAA,SAAA,qBAAA,GAAA,OAAA,YAAA,KAAA,WAAA;AAAA;;AAEA,SAAA,SAAA,CAAA,MAAA,EAAA,WAAA,EAAA,IAAA,EAAA,SAAA,EAAA,WAAA,EAAA;AACA,SAAA,IAAA,CAAA,GAAA,WAAA,EAAA,CAAA,GAAA,SAAA,EAAA,CAAA,GAAA,WAAA,GAAA,WAAA,EAAA,CAAA,IAAA,CAAA,EAAA,EAAA;AACA,MAAA,IAAA,CAAA,CAAA,CAAA,GAAA,MAAA,CAAA,CAAA,CAAA;AACA;AACA;;AAEA,SAAA,SAAA,CAAA,KAAA,EAAA,SAAA,EAAA,OAAA,EAAA,KAAA,EAAA;AACA,SAAA,IAAA,CAAA,GAAA,SAAA,EAAA,CAAA,GAAA,OAAA,EAAA,CAAA,EAAA,EACA,KAAA,CAAA,CAAA,CAAA,GAAA,KAAA;AACA;;AAEA,SAAA,YAAA,CAAA,KAAA,EAAA,IAAA,EAAA,KAAA,GAAA,CAAA,EAAA;AACA,QAAA,OAAA,GAAA,KAAA,CAAA,MAAA;AACA,QAAA,OAAA,IAAA,IAAA,EAAA,OAAA,KAAA;AACA,IAAA,KAAA,CAAA,MAAA,GAAA,IAAA;;AACA,QAAA,OAAA,GAAA,IAAA,EAAA;AACA,WAAA,IAAA,CAAA,GAAA,OAAA,EAAA,CAAA,GAAA,IAAA,EAAA,CAAA,EAAA,EAAA,KAAA,CAAA,CAAA,CAAA,GAAA,KAAA;AACA;;AACA,WAAA,KAAA;AACA;;AAEA,SAAA,mBAAA,CAAA,KAAA,EAAA,IAAA,EAAA,KAAA,GAAA,CAAA,EAAA;AACA,QAAA,KAAA,CAAA,MAAA,IAAA,IAAA,EAAA,OAAA,KAAA;AACA,WAAA,KAAA,CAAA,YAAA,CAAA,KAAA,EAAA,IAAA,EAAA,KAAA,CAAA;AACA;;AAEA,SAAA,QAAA,CAAA,IAAA,EAAA,YAAA,EAAA;AACA,QAAA,KAAA,GAAA,IAAA,KAAA,CAAA,IAAA,CAAA;;AACA,SAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,IAAA,EAAA,CAAA,EAAA,EAAA,KAAA,CAAA,CAAA,CAAA,GAAA,YAAA;;AACA,WAAA,KAAA;AACA;;AAEA,SAAA,aAAA,CAAA,IAAA,EAAA;AACA,QAAA,KAAA,CAAA,qBAAA,EACA,OAAA,IAAA,YAAA,CAAA,IAAA,CAAA,CADA,KAEA;AACA,UAAA,KAAA,GAAA,IAAA,KAAA,CAAA,IAAA,CAAA;;AACA,WAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,KAAA,CAAA,MAAA,EAAA,CAAA,EAAA,EAAA,KAAA,CAAA,CAAA,CAAA,GAAA,CAAA;;AACA,aAAA,KAAA;AACA;AACA;;AAEA,SAAA,aAAA,CAAA,IAAA,EAAA;AACA,QAAA,KAAA,CAAA,qBAAA,EACA,OAAA,IAAA,UAAA,CAAA,IAAA,CAAA,CADA,KAEA;AACA,UAAA,KAAA,GAAA,IAAA,KAAA,CAAA,IAAA,CAAA;;AACA,WAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,KAAA,CAAA,MAAA,EAAA,CAAA,EAAA,EAAA,KAAA,CAAA,CAAA,CAAA,GAAA,CAAA;;AACA,aAAA,KAAA;AACA;AACA;;AAEA,SAAA,YAAA,CAAA,KAAA,EAAA;AACA,WAAA,KAAA,CAAA,qBAAA,GAAA,IAAA,YAAA,CAAA,KAAA,CAAA,GAAA,KAAA;AACA;;AAEA,SAAA,iBAAA,CAAA,KAAA,EAAA;AACA,WAAA,KAAA,CAAA,qBAAA,GAAA,MAAA,CAAA,KAAA,CAAA,GAAA,KAAA;AACA,G,CAEA;;;AACA,SAAA,qBAAA,CAAA,KAAA,EAAA,KAAA,EAAA,CAEA;;AAEA,SAAA,QAAA,CAAA,KAAA,EAAA,OAAA,EAAA,QAAA,GAAA,IAAA,EAAA;AACA,SAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,KAAA,CAAA,MAAA,EAAA,CAAA,EAAA,EACA,IAAA,KAAA,CAAA,CAAA,CAAA,IAAA,OAAA,EAAA,OAAA,IAAA;;AACA,WAAA,KAAA;AACA;;AAEA,SAAA,SAAA,CAAA,IAAA,EAAA,IAAA,EAAA;AACA,WAAA,IAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,WAAA,KAAA,IAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;AACA;;;;AACA,KAAA,CAAA,cAAA;AAEA;AACA;AACA;;;;AAEA,SAAA,QAAA,CAAA,QAAA,EAAA;AACA,SAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,QAAA,CAAA,KAAA,CAAA,MAAA,EAAA,CAAA,EAAA,EAAA;AACA,UAAA,IAAA,GAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA;AACA,UAAA,GAAA,GAAA,IAAA,CAAA,MAAA;AACA,MAAA,OAAA,CAAA,GAAA,CAAA,IAAA,CAAA,IAAA,CAAA,IAAA,GAAA,IAAA,GAAA,GAAA,CAAA,CAAA,GAAA,IAAA,GAAA,GAAA,CAAA,CAAA,GAAA,IAAA,GAAA,GAAA,CAAA,CAAA,GAAA,IAAA,GAAA,GAAA,CAAA,CAAA,GAAA,IAAA,GAAA,GAAA,CAAA,EAAA,GAAA,IAAA,GAAA,GAAA,CAAA,EAAA;AACA;AACA;;;AAGA;AACA;AACA;;;;AAEA,EAAA,OAAA,GAAA;AAAA,SAAA,KAAA,GAAA,IAAA,KAAA,EAAA;AAAA;;AAGA,EAAA,WAAA,CAAA,YAAA,EAAA;AAAA,IAAA,IAAA,CAAA,SAAA,CAAA,OAAA,CAAA,IAAA,CAAA,IAAA;;AACA,SAAA,YAAA,GAAA,YAAA;AACA;;AAEA,EAAA,MAAA,GAAA;AACA,WAAA,KAAA,KAAA,CAAA,MAAA,GAAA,CAAA,GAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAA,KAAA,YAAA,EAAA;AACA;;AAEA,EAAA,IAAA,CAAA,IAAA,EAAA;AACA,QAAA,IAAA,CAAA,KAAA,EAAA,IAAA,CAAA,KAAA;AACA,SAAA,KAAA,CAAA,IAAA,CAAA,IAAA;AACA;;AAEA,EAAA,OAAA,CAAA,KAAA,EAAA;AACA,SAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,KAAA,CAAA,MAAA,EAAA,CAAA,EAAA,EACA,KAAA,IAAA,CAAA,KAAA,CAAA,CAAA,CAAA;AACA;;AAEA,EAAA,KAAA,GAAA;AACA,SAAA,KAAA,CAAA,MAAA,GAAA,CAAA;AACA;;;AAGA;AACA;AACA;;;;AAEA,EAAA,WAAA,CAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,CAAA,EAAA;AAAA,SAAA,CAAA,GAAA,CAAA;AAAA,SAAA,CAAA,GAAA,CAAA;AACA;;AAEA,EAAA,GAAA,CAAA,CAAA,EAAA,CAAA,EAAA;AACA,SAAA,CAAA,GAAA,CAAA;AACA,SAAA,CAAA,GAAA,CAAA;AACA,WAAA,IAAA;AACA;;AAEA,EAAA,MAAA,GAAA;AACA,QAAA,CAAA,GAAA,KAAA,CAAA;AACA,QAAA,CAAA,GAAA,KAAA,CAAA;AACA,WAAA,IAAA,CAAA,IAAA,CAAA,CAAA,GAAA,CAAA,GAAA,CAAA,GAAA,CAAA,CAAA;AACA;;AAEA,EAAA,SAAA,GAAA;AACA,QAAA,GAAA,GAAA,KAAA,MAAA,EAAA;;AACA,QAAA,GAAA,IAAA,CAAA,EAAA;AACA,WAAA,CAAA,IAAA,GAAA;AACA,WAAA,CAAA,IAAA,GAAA;AACA;;AACA,WAAA,IAAA;AACA;;;AAGA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AAEA,EAAA,OAAA,GAAA;AAAA,SAAA,QAAA,GAAA,KAAA;AAAA;;AACA,EAAA,OAAA,GAAA;AAAA,SAAA,eAAA,GAAA,CAAA;AAAA;;AACA,EAAA,OAAA,GAAA;AAAA,SAAA,KAAA,GAAA,CAAA;AAAA;;AACA,EAAA,OAAA,GAAA;AAAA,SAAA,SAAA,GAAA,CAAA;AAAA;;AAEA,EAAA,QAAA,GAAA;AAAA,SAAA,QAAA,GAAA,IAAA,CAAA,GAAA,KAAA,IAAA;AAAA;;AACA,EAAA,QAAA,GAAA;AAAA,SAAA,UAAA,GAAA,CAAA;AAAA;;AACA,EAAA,QAAA,GAAA;AAAA,SAAA,SAAA,GAAA,CAAA;AAAA;;AAEA,EAAA,MAAA,GAAA;AACA,QAAA,GAAA,GAAA,IAAA,CAAA,GAAA,KAAA,IAAA;AACA,SAAA,KAAA,GAAA,GAAA,GAAA,KAAA,QAAA;AACA,SAAA,SAAA,IAAA,KAAA,KAAA;AACA,SAAA,SAAA,IAAA,KAAA,KAAA;AACA,QAAA,KAAA,KAAA,GAAA,KAAA,QAAA,EAAA,KAAA,KAAA,GAAA,KAAA,QAAA;AACA,SAAA,QAAA,GAAA,GAAA;AAEA,SAAA,UAAA;;AACA,QAAA,KAAA,SAAA,GAAA,CAAA,EAAA;AACA,WAAA,eAAA,GAAA,KAAA,UAAA,GAAA,KAAA,SAAA;AACA,WAAA,SAAA,GAAA,CAAA;AACA,WAAA,UAAA,GAAA,CAAA;AACA;AACA;;;AAGA;AACA;AACA;;AAMA;AACA;AACA;;;;AAGA,EAAA,QAAA,GAAA;AAAA,SAAA,WAAA,GAAA,CAAA;AAAA;;AACA,EAAA,QAAA,GAAA;AAAA,SAAA,SAAA,GAAA,CAAA;AAAA;;AACA,EAAA,QAAA,GAAA;AAAA,SAAA,IAAA,GAAA,CAAA;AAAA;;AACA,EAAA,QAAA,GAAA;AAAA,SAAA,KAAA,GAAA,IAAA;AAAA;;AAEA,EAAA,WAAA,CAAA,UAAA,GAAA,EAAA,EAAA;AAAA,IAAA,YAAA,CAAA,SAAA,CAAA,QAAA,CAAA,IAAA,CAAA,IAAA;;AAAA,IAAA,YAAA,CAAA,SAAA,CAAA,QAAA,CAAA,IAAA,CAAA,IAAA;;AAAA,IAAA,YAAA,CAAA,SAAA,CAAA,QAAA,CAAA,IAAA,CAAA,IAAA;;AAAA,IAAA,YAAA,CAAA,SAAA,CAAA,QAAA,CAAA,IAAA,CAAA,IAAA;;AACA,SAAA,MAAA,GAAA,IAAA,KAAA,CAAA,UAAA,CAAA;AACA;;AAEA,EAAA,aAAA,GAAA;AACA,WAAA,KAAA,WAAA,IAAA,KAAA,MAAA,CAAA,MAAA;AACA;;AAEA,EAAA,QAAA,CAAA,KAAA,EAAA;AACA,QAAA,KAAA,WAAA,GAAA,KAAA,MAAA,CAAA,MAAA,EAAA,KAAA,WAAA;AACA,SAAA,MAAA,CAAA,KAAA,SAAA,EAAA,IAAA,KAAA;AACA,QAAA,KAAA,SAAA,GAAA,KAAA,MAAA,CAAA,MAAA,GAAA,CAAA,EAAA,KAAA,SAAA,GAAA,CAAA;AACA,SAAA,KAAA,GAAA,IAAA;AACA;;AAEA,EAAA,OAAA,GAAA;AACA,QAAA,KAAA,aAAA,EAAA,EAAA;AACA,UAAA,KAAA,KAAA,EAAA;AACA,YAAA,IAAA,GAAA,CAAA;;AACA,aAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,KAAA,MAAA,CAAA,MAAA,EAAA,CAAA,EAAA,EACA,IAAA,IAAA,KAAA,MAAA,CAAA,CAAA,CAAA;;AACA,aAAA,IAAA,GAAA,IAAA,GAAA,KAAA,MAAA,CAAA,MAAA;AACA,aAAA,KAAA,GAAA,KAAA;AACA;;AACA,aAAA,KAAA,IAAA;AACA;;AACA,WAAA,CAAA;AACA;;;ACzeA;AACA;AACA;;;;AAEA,EAAA,KAAA,EAAA,I;;AACA;AACA;AACA;AACA;AACA,EAAA,yBAAA,EAAA,K;;AAEA;AACA;AACA;AACA,EAAA,kBAAA,EAAA,I;;AAEA;AACA;AACA;AACA,EAAA,kBAAA,EAAA;;ACMA,IAAA,OAAA,GAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA;AAEA;AACA;AACA;;AAMA;AACA;AACA;;;;;;;;;;;AAEA,EAAA,MAAA,GAAA;AAAA,SAAA,MAAA,GAAA,IAAA;AAAA;;AACA,EAAA,OAAA,GAAA;AAAA,SAAA,UAAA,GAAA,IAAA;AAAA;;;AAGA;AACA;AACA;;;;AAEA,EAAA,OAAA,GAAA;AAAA,SAAA,MAAA,GAAA,IAAA;AAAA;;AACA,EAAA,OAAA,GAAA;AAAA,SAAA,UAAA,GAAA,IAAA;AAAA;;AAEA,EAAA,WAAA,CAAA,OAAA,EAAA,QAAA,EAAA,GAAA,EAAA,OAAA,EAAA,QAAA,EAAA;AACA,UAAA,OAAA,EAAA,QAAA,EAAA,GAAA,EAAA,OAAA,EAAA,QAAA;;AAAA,IAAA,SAAA,CAAA,SAAA,CAAA,OAAA,CAAA,IAAA,CAAA,IAAA;;AAAA,IAAA,SAAA,CAAA,SAAA,CAAA,OAAA,CAAA,IAAA,CAAA,IAAA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;wBAKA,S,CAAA;AAeA,EAAA,WAAA,CAAA,SAAA,EAAA;AACA;;AAEA,QAAA,CAAA,SAAA,EAAA;AACA,YAAA,IAAA,KAAA,CAAA,kCAAA,CAAA;AACA;;AAEA,QAAA,OAAA,SAAA,KAAA,QAAA,EAAA;AACA,YAAA,IAAA,KAAA,CAAA,qGAAA,CAAA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AACA,SAAA,SAAA,GAAA,SAAA;AAEA;AACA;AACA;AACA;AACA;;AACA,SAAA,cAAA,CAAA,SAAA;AAEA;AACA;AACA;AACA;AACA;;AACA,SAAA,cAAA,GAAA,EAAA;AAEA,SAAA,kBAAA,GAAA,EAAA;;AAEA,SAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,KAAA,QAAA,CAAA,KAAA,CAAA,MAAA,EAAA,CAAA,GAAA,CAAA,EAAA,CAAA,EAAA,EAAA;AACA,UAAA,IAAA,GAAA,KAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA;AACA,UAAA,UAAA,GAAA,IAAA,CAAA,aAAA,EAAA;AACA,UAAA,aAAA,GAAA,KAAA,YAAA,EAAA;AACA,WAAA,cAAA,CAAA,IAAA,CAAA,aAAA;AACA,WAAA,QAAA,CAAA,aAAA;AACA,WAAA,kBAAA,CAAA,IAAA,CAAA,IAAA;;AAEA,UAAA,CAAA,UAAA,EAAA;AACA;AACA;;AACA,UAAA,UAAA,CAAA,IAAA,KAAA,cAAA,CAAA,MAAA,EAAA;AACA,YAAA,UAAA,GAAA,UAAA,CAAA,MAAA,CAAA,IAAA;AACA,YAAA,MAAA,GAAA,KAAA,YAAA,CAAA,IAAA,EAAA,UAAA,EAAA,UAAA,CAAA;AACA,QAAA,IAAA,CAAA,aAAA,GAAA,MAAA;AACA,QAAA,IAAA,CAAA,iBAAA,GAAA,UAAA;AACA,QAAA,aAAA,CAAA,QAAA,CAAA,MAAA;AACA,OANA,MAMA,IAAA,UAAA,CAAA,IAAA,KAAA,cAAA,CAAA,IAAA,EAAA;AACA,YAAA,IAAA,GAAA,KAAA,UAAA,CAAA,IAAA,EAAA,UAAA,CAAA;AACA,QAAA,IAAA,CAAA,WAAA,GAAA,IAAA;AACA,QAAA,IAAA,CAAA,aAAA,GAAA,UAAA,CAAA,EAAA;AACA,QAAA,IAAA,CAAA,eAAA,GAAA,UAAA,CAAA,IAAA;AACA,QAAA,aAAA,CAAA,QAAA,CAAA,IAAA;AACA,OANA,MAMA,IAAA,UAAA,CAAA,IAAA,KAAA,cAAA,CAAA,QAAA,EAAA;AACA,aAAA,cAAA,CAAA,IAAA,EAAA,UAAA;AACA,QAAA,aAAA,CAAA,QAAA,CAAA,IAAA,CAAA,iBAAA;AACA,QAAA,aAAA,CAAA,QAAA,CAAA,IAAA,CAAA,eAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAA,OAAA,GAAA,IAAA,YAAA,CAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,CAAA,CAAA;AAEA,SAAA,UAAA,GAAA,IAAA;AACA,SAAA,OAAA,GAAA,IAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAA,UAAA,GAAA;AACA,WAAA,KAAA,WAAA;AACA;;AAEA,MAAA,UAAA,CAAA,KAAA,EAAA;AACA,QAAA,KAAA,KAAA,KAAA,WAAA,EAAA;AACA,WAAA,WAAA,GAAA,KAAA;AACA,WAAA,eAAA,GAAA,KAAA,GAAA,SAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,SAAA,CAAA,SAAA,CAAA,eAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAA,IAAA,GAAA;AACA,WAAA,OAAA,CAAA,KAAA,OAAA,CAAA;AACA;;AAEA,MAAA,IAAA,CAAA,KAAA,EAAA;AACA,SAAA,OAAA,GAAA,OAAA,CAAA,KAAA,EAAA,KAAA,OAAA,CAAA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAA,UAAA,GAAA;AACA,QAAA,KAAA,GAAA,OAAA,KAAA,eAAA,KAAA,WAAA,GACA,KAAA,eADA,GACA,QAAA,CAAA,kBADA,CADA,CAIA;;AACA,WAAA,KAAA,IAAA,MAAA,CAAA,SAAA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AACA,EAAA,MAAA,CAAA,EAAA,EAAA;AACA;AACA,QAAA,UAAA,GAAA,KAAA,UAAA;AACA,QAAA,EAAA,GAAA,UAAA,EAAA,EAAA,GAAA,UAAA;AAEA,SAAA,KAAA,CAAA,MAAA,CAAA,EAAA;AACA,SAAA,KAAA,CAAA,KAAA,CAAA,KAAA,QAAA,EANA,CAQA;;AACA,QAAA,CAAA,KAAA,QAAA,EACA;AAEA,SAAA,QAAA,CAAA,oBAAA;AAEA,QAAA,KAAA,GAAA,KAAA,QAAA,CAAA,KAAA,CAdA,CAgBA;;AACA,QAAA,SAAA,GAAA,IAAA,CAAA,KAAA;AACA,QAAA,KAAA,GAAA,IAAA;AAAA,QAAA,IAAA,GAAA,IAAA;;AAEA,QAAA,SAAA,EAAA;AACA,MAAA,KAAA,GAAA,SAAA,CAAA,KAAA;AACA,MAAA,IAAA,GAAA,SAAA,CAAA,IAAA;AACA,KAHA,MAGA;AACA,MAAA,KAAA,GAAA,KAAA,OAAA;AACA,KAzBA,CA2BA;;;AAEA,SAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,KAAA,CAAA,MAAA,EAAA,CAAA,GAAA,CAAA,EAAA,CAAA,EAAA,EAAA;AACA,UAAA,IAAA,GAAA,KAAA,CAAA,CAAA,CAAA;AACA,UAAA,UAAA,GAAA,IAAA,CAAA,aAAA,EAAA;AACA,UAAA,aAAA,GAAA,KAAA,cAAA,CAAA,CAAA,CAAA;;AAEA,UAAA,CAAA,UAAA,EAAA;AACA,QAAA,aAAA,CAAA,OAAA,GAAA,KAAA;AACA;AACA;;AAEA,UAAA,WAAA,GAAA,IAAA;AAEA,UAAA,QAAA,GAAA,UAAA,CAAA,KAAA;;AACA,cAAA,UAAA,CAAA,IAAA;AACA,aAAA,cAAA,CAAA,MAAA;AACA,cAAA,MAAA,GAAA,UAAA,CAAA,MAAA;;AACA,cAAA,MAAA,EAAA;AACA,gBAAA,IAAA,CAAA,WAAA,EAAA;AACA,cAAA,IAAA,CAAA,WAAA,CAAA,OAAA,GAAA,KAAA;AACA,cAAA,IAAA,CAAA,WAAA,GAAA,IAAA;AACA,cAAA,IAAA,CAAA,aAAA,GAAA,SAAA;AACA,cAAA,IAAA,CAAA,eAAA,GAAA,SAAA;AACA;;AACA,gBAAA,EAAA,GAAA,MAAA;;AACA,gBAAA,CAAA,IAAA,CAAA,iBAAA,IAAA,IAAA,CAAA,iBAAA,KAAA,EAAA,CAAA,IAAA,EAAA;AACA,kBAAA,UAAA,GAAA,EAAA,CAAA,IAAA;;AACA,kBAAA,IAAA,CAAA,aAAA,EAAA;AACA,gBAAA,IAAA,CAAA,aAAA,CAAA,OAAA,GAAA,KAAA;AACA;;AACA,cAAA,IAAA,CAAA,OAAA,GAAA,IAAA,CAAA,OAAA,IAAA,EAAA;;AACA,kBAAA,IAAA,CAAA,OAAA,CAAA,UAAA,MAAA,SAAA,EAAA;AACA,gBAAA,IAAA,CAAA,OAAA,CAAA,UAAA,EAAA,OAAA,GAAA,IAAA;AACA,eAFA,MAEA;AACA,oBAAA,MAAA,GAAA,KAAA,YAAA,CAAA,IAAA,EAAA,UAAA,EAAA,UAAA,CAAA;AACA,gBAAA,aAAA,CAAA,QAAA,CAAA,MAAA;AACA;;AACA,cAAA,IAAA,CAAA,aAAA,GAAA,IAAA,CAAA,OAAA,CAAA,UAAA,CAAA;AACA,cAAA,IAAA,CAAA,iBAAA,GAAA,UAAA,CAbA,CAeA;AACA;AACA,aAjBA,MAiBA,IAAA,IAAA,CAAA,iBAAA,KAAA,EAAA,CAAA,IAAA,IAAA,CAAA,IAAA,CAAA,UAAA,EAAA;AACA,mBAAA,eAAA,CAAA,UAAA,EAAA,IAAA,CAAA,aAAA,EAAA,MAAA;AACA;AACA;;AAEA,cAAA,SAAA,GAAA,aAAA,CAAA,SAAA;AACA,UAAA,SAAA,CAAA,aAAA,CAAA,IAAA,CAAA,IAAA,CAAA,MAAA;;AAEA,cAAA,IAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AACA;AACA,YAAA,WAAA,GAAA,IAAA,CAAA,aAAA,CAAA,KAAA;AACA,WAHA,MAGA;AACA,YAAA,OAAA,CAAA,CAAA,CAAA,GAAA,KAAA,CAAA,CAAA,CAAA,GAAA,IAAA,CAAA,KAAA,CAAA,CAAA,GAAA,QAAA,CAAA,CAAA;AACA,YAAA,OAAA,CAAA,CAAA,CAAA,GAAA,KAAA,CAAA,CAAA,CAAA,GAAA,IAAA,CAAA,KAAA,CAAA,CAAA,GAAA,QAAA,CAAA,CAAA;AACA,YAAA,OAAA,CAAA,CAAA,CAAA,GAAA,KAAA,CAAA,CAAA,CAAA,GAAA,IAAA,CAAA,KAAA,CAAA,CAAA,GAAA,QAAA,CAAA,CAAA;AACA,YAAA,IAAA,CAAA,aAAA,CAAA,IAAA,GAAA,OAAA,CAAA,OAAA,CAAA;AACA;;AACA,UAAA,IAAA,CAAA,aAAA,CAAA,SAAA,GAAA,IAAA,CAAA,SAAA;AACA;;AAEA,aAAA,cAAA,CAAA,IAAA;AACA,cAAA,IAAA,CAAA,aAAA,EAAA;AACA;AACA,YAAA,IAAA,CAAA,aAAA,CAAA,OAAA,GAAA,KAAA;AACA,YAAA,IAAA,CAAA,aAAA,GAAA,IAAA;AACA,YAAA,IAAA,CAAA,iBAAA,GAAA,SAAA,CAJA,CAMA;;AACA,kBAAA,SAAA,GAAA,IAAA,SAAA,EAAA;AACA,YAAA,SAAA,CAAA,SAAA,GAAA,CAAA,CAAA;AACA,YAAA,SAAA,CAAA,QAAA,GAAA,aAAA,CAAA,SAAA,CAAA,QAAA;AACA,YAAA,aAAA,CAAA,SAAA,GAAA,SAAA;AACA;;AACA,gBAAA,EAAA,GAAA,UAAA,CAAA,EAAA;;AACA,cAAA,CAAA,IAAA,CAAA,aAAA,IAAA,IAAA,CAAA,aAAA,KAAA,EAAA,EAAA;AACA,gBAAA,MAAA,GAAA,EAAA;;AACA,gBAAA,IAAA,CAAA,WAAA,EAAA;AACA,cAAA,IAAA,CAAA,WAAA,CAAA,OAAA,GAAA,KAAA;AACA;;AAEA,YAAA,IAAA,CAAA,MAAA,GAAA,IAAA,CAAA,MAAA,IAAA,EAAA;;AAEA,gBAAA,IAAA,CAAA,MAAA,CAAA,MAAA,MAAA,SAAA,EAAA;AACA,cAAA,IAAA,CAAA,MAAA,CAAA,MAAA,EAAA,OAAA,GAAA,IAAA;AACA,aAFA,MAEA;AACA,kBAAA,IAAA,GAAA,KAAA,UAAA,CAAA,IAAA,EAAA,UAAA,CAAA;AACA,cAAA,aAAA,CAAA,QAAA,CAAA,IAAA;AACA;;AAEA,YAAA,IAAA,CAAA,WAAA,GAAA,IAAA,CAAA,MAAA,CAAA,MAAA,CAAA;AACA,YAAA,IAAA,CAAA,eAAA,GAAA,UAAA,CAAA,IAAA;AACA,YAAA,IAAA,CAAA,aAAA,GAAA,MAAA;AACA;;AACA,UAAA,UAAA,CAAA,uBAAA,CAAA,IAAA,EAAA,IAAA,CAAA,WAAA,CAAA,QAAA;;AACA,cAAA,IAAA,CAAA,WAAA,CAAA,KAAA,EAAA;AACA;AACA,YAAA,WAAA,GAAA,IAAA,CAAA,WAAA,CAAA,KAAA;AACA,WAHA,MAGA;AACA,YAAA,OAAA,CAAA,CAAA,CAAA,GAAA,KAAA,CAAA,CAAA,CAAA,GAAA,IAAA,CAAA,KAAA,CAAA,CAAA,GAAA,QAAA,CAAA,CAAA;AACA,YAAA,OAAA,CAAA,CAAA,CAAA,GAAA,KAAA,CAAA,CAAA,CAAA,GAAA,IAAA,CAAA,KAAA,CAAA,CAAA,GAAA,QAAA,CAAA,CAAA;AACA,YAAA,OAAA,CAAA,CAAA,CAAA,GAAA,KAAA,CAAA,CAAA,CAAA,GAAA,IAAA,CAAA,KAAA,CAAA,CAAA,GAAA,QAAA,CAAA,CAAA;AACA,YAAA,IAAA,CAAA,WAAA,CAAA,IAAA,GAAA,OAAA,CAAA,OAAA,CAAA;AACA;;AACA,UAAA,IAAA,CAAA,WAAA,CAAA,SAAA,GAAA,IAAA,CAAA,SAAA;AACA;;AACA,aAAA,cAAA,CAAA,QAAA;AACA,cAAA,CAAA,IAAA,CAAA,eAAA,EAAA;AACA,iBAAA,cAAA,CAAA,IAAA,EAAA,UAAA;AACA,YAAA,aAAA,CAAA,QAAA,CAAA,IAAA,CAAA,iBAAA;AACA,YAAA,aAAA,CAAA,QAAA,CAAA,IAAA,CAAA,eAAA;AACA;;AACA,eAAA,cAAA,CAAA,IAAA,EAAA,UAAA;AACA,UAAA,aAAA,CAAA,KAAA,GAAA,GAAA;AACA,UAAA,aAAA,CAAA,OAAA,GAAA,IAAA;AACA;;AACA;AACA,UAAA,aAAA,CAAA,OAAA,GAAA,KAAA;AACA;AAzGA;;AA2GA,MAAA,aAAA,CAAA,OAAA,GAAA,IAAA,CAxHA,CA0HA;;AACA,UAAA,WAAA,EAAA;AACA,YAAA,EAAA,GAAA,IAAA,CAAA,KAAA,CAAA,CAAA,GAAA,QAAA,CAAA,CAAA;AACA,YAAA,EAAA,GAAA,IAAA,CAAA,KAAA,CAAA,CAAA,GAAA,QAAA,CAAA,CAAA;AACA,YAAA,EAAA,GAAA,IAAA,CAAA,KAAA,CAAA,CAAA,GAAA,QAAA,CAAA,CAAA,CAHA,CAKA;;AACA,QAAA,WAAA,CAAA,QAAA,CACA,KAAA,CAAA,CAAA,CAAA,GAAA,EAAA,GAAA,IAAA,CAAA,CAAA,CAAA,IAAA,MAAA,EAAA,CADA,EAEA,KAAA,CAAA,CAAA,CAAA,GAAA,EAAA,GAAA,IAAA,CAAA,CAAA,CAAA,IAAA,MAAA,EAAA,CAFA,EAGA,KAAA,CAAA,CAAA,CAAA,GAAA,EAAA,GAAA,IAAA,CAAA,CAAA,CAAA,IAAA,MAAA,EAAA,CAHA;;AAKA,YAAA,IAAA,CAAA,SAAA,EAAA;AACA,UAAA,EAAA,GAAA,IAAA,CAAA,SAAA,CAAA,CAAA;AACA,UAAA,EAAA,GAAA,IAAA,CAAA,SAAA,CAAA,CAAA;AACA,UAAA,EAAA,GAAA,IAAA,CAAA,SAAA,CAAA,CAAA;AACA,SAJA,MAIA;AACA,UAAA,EAAA,GAAA,GAAA;AACA,UAAA,EAAA,GAAA,GAAA;AACA,UAAA,EAAA,GAAA,GAAA;AACA;;AACA,QAAA,WAAA,CAAA,OAAA,CACA,KAAA,CAAA,CAAA,CAAA,GAAA,EAAA,GAAA,IAAA,CAAA,CAAA,CAAA,IAAA,IAAA,EAAA,CADA,EAEA,KAAA,CAAA,CAAA,CAAA,GAAA,EAAA,GAAA,IAAA,CAAA,CAAA,CAAA,IAAA,IAAA,EAAA,CAFA,EAGA,KAAA,CAAA,CAAA,CAAA,GAAA,EAAA,GAAA,IAAA,CAAA,CAAA,CAAA,IAAA,IAAA,EAAA,CAHA;AAKA;;AAEA,MAAA,aAAA,CAAA,KAAA,GAAA,IAAA,CAAA,KAAA,CAAA,CAAA;AACA,KApLA,CAsLA;AACA;;;AACA,QAAA,SAAA,GAAA,KAAA,QAAA,CAAA,SAAA;AACA,QAAA,kBAAA,GAAA,IAAA;AACA,QAAA,iBAAA,GAAA,IAAA;;AAEA,SAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,MAAA,EAAA,CAAA,GAAA,CAAA,EAAA,CAAA,EAAA,EAAA;AACA,UAAA,IAAA,GAAA,KAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,KAAA,CAAA;AACA,UAAA,aAAA,GAAA,KAAA,cAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,KAAA,CAAA;;AAEA,UAAA,CAAA,iBAAA,EAAA;AACA;AACA,YAAA,aAAA,CAAA,MAAA,KAAA,IAAA,IAAA,aAAA,CAAA,MAAA,KAAA,IAAA,EAAA;AACA,UAAA,aAAA,CAAA,MAAA,CAAA,WAAA,CAAA,aAAA,EADA,CAEA;;AACA,UAAA,aAAA,CAAA,MAAA,GAAA,IAAA;AACA;AACA;;AACA,UAAA,IAAA,CAAA,eAAA,IAAA,IAAA,CAAA,aAAA,EAAA,EAAA;AACA,QAAA,iBAAA,GAAA,IAAA,CAAA,iBAAA;AACA,QAAA,kBAAA,GAAA,IAAA,CAAA,aAAA,EAAA;AACA,QAAA,iBAAA,CAAA,QAAA,CAAA,MAAA,GAAA,CAAA;AACA,aAAA,QAAA,CAAA,CAAA,IAAA,aAAA;;AAEA,YAAA,kBAAA,CAAA,OAAA,KAAA,IAAA,CAAA,IAAA,EAAA;AACA,UAAA,kBAAA,CAAA,OAAA,GAAA,IAAA;AACA;AAEA,OAVA,MAUA;AACA,YAAA,iBAAA,EAAA;AACA,cAAA,CAAA,GAAA,KAAA,kBAAA,CAAA,CAAA,CAAA;;AACA,cAAA,CAAA,CAAA,EAAA;AACA,YAAA,CAAA,GAAA,KAAA,kBAAA,CAAA,CAAA,IAAA,KAAA,YAAA,EAAA;AACA,YAAA,CAAA,CAAA,OAAA,GAAA,KAAA;AACA;;AACA,eAAA,QAAA,CAAA,CAAA,IAAA,CAAA,CANA,CAQA;;AACA,UAAA,aAAA,CAAA,MAAA,GAAA,IAAA;AACA,UAAA,iBAAA,CAAA,QAAA,CAAA,aAAA;;AACA,cAAA,kBAAA,CAAA,OAAA,IAAA,IAAA,CAAA,IAAA,EAAA;AACA,YAAA,iBAAA,CAAA,UAAA,GAAA,IAAA;AACA,YAAA,iBAAA,GAAA,IAAA;AACA,YAAA,kBAAA,GAAA,IAAA;AACA;AACA,SAhBA,MAgBA;AACA,eAAA,QAAA,CAAA,CAAA,IAAA,aAAA;AACA;AACA;AACA;AACA;;AAEA,EAAA,eAAA,CAAA,UAAA,EAAA,MAAA,EAAA,MAAA,EAAA;AACA;AACA,QAAA,MAAA,CAAA,UAAA,KAAA,UAAA,IAAA,MAAA,CAAA,MAAA,KAAA,MAAA,EAAA;AACA;AACA;;AAEA,IAAA,MAAA,CAAA,MAAA,GAAA,MAAA;AACA,IAAA,MAAA,CAAA,UAAA,GAAA,UAAA;AAEA,IAAA,MAAA,CAAA,OAAA,GAAA,MAAA,CAAA,OAAA;AACA,IAAA,MAAA,CAAA,QAAA,GAAA,UAAA,CAAA,QAAA,GAAA,SAAA,CAAA,MAAA;AACA,IAAA,MAAA,CAAA,QAAA,CAAA,CAAA,GAAA,UAAA,CAAA,CAAA;AACA,IAAA,MAAA,CAAA,QAAA,CAAA,CAAA,GAAA,UAAA,CAAA,CAAA;AACA,IAAA,MAAA,CAAA,KAAA,GAAA,UAAA,CAAA,KAAA,CAAA,CAAA;;AAEA,QAAA,CAAA,MAAA,CAAA,IAAA,EAAA;AACA,MAAA,MAAA,CAAA,KAAA,CAAA,CAAA,GAAA,UAAA,CAAA,MAAA,GAAA,UAAA,CAAA,KAAA,GAAA,MAAA,CAAA,aAAA;AACA,MAAA,MAAA,CAAA,KAAA,CAAA,CAAA,GAAA,CAAA,UAAA,CAAA,MAAA,GAAA,UAAA,CAAA,MAAA,GAAA,MAAA,CAAA,cAAA;AACA,KAHA,MAGA;AACA;AACA,MAAA,MAAA,CAAA,KAAA,CAAA,CAAA,GAAA,MAAA,CAAA,IAAA,CAAA,KAAA,GAAA,MAAA,CAAA,aAAA;AACA,MAAA,MAAA,CAAA,KAAA,CAAA,CAAA,GAAA,CAAA,MAAA,CAAA,IAAA,CAAA,MAAA,GAAA,MAAA,CAAA,cAAA;AACA;AACA;;AAEA,EAAA,aAAA,CAAA,UAAA,EAAA,IAAA,EAAA,MAAA,EAAA;AAEA,QAAA,IAAA,CAAA,UAAA,KAAA,UAAA,IAAA,IAAA,CAAA,MAAA,KAAA,MAAA,EAAA;AACA;AACA;;AAEA,IAAA,IAAA,CAAA,MAAA,GAAA,MAAA;AACA,IAAA,IAAA,CAAA,UAAA,GAAA,UAAA;AACA,IAAA,IAAA,CAAA,OAAA,GAAA,MAAA,CAAA,OAAA;AACA,IAAA,MAAA,CAAA,OAAA,CAAA,SAAA;AACA,IAAA,IAAA,CAAA,QAAA,CAAA,MAAA,CAAA,UAAA,CAAA,SAAA;AACA;AAIA;AACA;AACA;AACA;AACA;;;AACA,EAAA,mBAAA,GAAA;AACA,QAAA,QAAA,CAAA,kBAAA,EAAA;AACA,WAAA,QAAA,GAAA,KAAA,QAAA,IAAA,IAAA,CAAA,GAAA,EAAA;AACA,UAAA,SAAA,GAAA,CAAA,IAAA,CAAA,GAAA,KAAA,KAAA,QAAA,IAAA,KAAA;AACA,WAAA,QAAA,GAAA,IAAA,CAAA,GAAA,EAAA;AACA,WAAA,MAAA,CAAA,SAAA;AACA,KALA,MAKA;AACA,WAAA,QAAA,GAAA,CAAA;AACA;;AAEA,IAAA,SAAA,CAAA,SAAA,CAAA,eAAA,CAAA,IAAA,CAAA,IAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAA,YAAA,CAAA,IAAA,EAAA,UAAA,EAAA,OAAA,EAAA;AACA,QAAA,MAAA,GAAA,UAAA,CAAA,MAAA;;AACA,QAAA,IAAA,CAAA,cAAA,KAAA,UAAA,EAAA;AACA,MAAA,MAAA,GAAA,IAAA,CAAA,UAAA;AACA;;AACA,QAAA,OAAA,GAAA,MAAA,CAAA,OAAA;AACA,QAAA,MAAA,GAAA,KAAA,SAAA,CAAA,OAAA,CAAA;AAEA,IAAA,MAAA,CAAA,MAAA,CAAA,GAAA,CAAA,GAAA;AACA,SAAA,eAAA,CAAA,UAAA,EAAA,MAAA,EAAA,UAAA,CAAA,MAAA;AAEA,IAAA,IAAA,CAAA,OAAA,GAAA,IAAA,CAAA,OAAA,IAAA,EAAA;AACA,IAAA,IAAA,CAAA,OAAA,CAAA,OAAA,IAAA,MAAA;AACA,WAAA,MAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAA,UAAA,CAAA,IAAA,EAAA,UAAA,EAAA;AACA,QAAA,MAAA,GAAA,UAAA,CAAA,MAAA;;AACA,QAAA,IAAA,CAAA,cAAA,KAAA,UAAA,EAAA;AACA,MAAA,MAAA,GAAA,IAAA,CAAA,UAAA;AACA,MAAA,IAAA,CAAA,cAAA,GAAA,IAAA;AACA,MAAA,IAAA,CAAA,UAAA,GAAA,IAAA;AACA;;AACA,QAAA,KAAA,GAAA,KAAA,OAAA,CACA,MAAA,CAAA,OADA,EAEA,IAAA,YAAA,CAAA,UAAA,CAAA,SAAA,CAAA,MAAA,CAFA,EAGA,UAAA,CAAA,SAHA,EAIA,IAAA,WAAA,CAAA,UAAA,CAAA,SAAA,CAJA,EAKA,UAAA,CAAA,SALA,CAAA;;AAOA,QAAA,OAAA,KAAA,CAAA,cAAA,KAAA,WAAA,EAAA;AACA,MAAA,KAAA,CAAA,cAAA,GAAA,GAAA;AACA;;AAEA,IAAA,KAAA,CAAA,KAAA,GAAA,UAAA,CAAA,KAAA,CAAA,CAAA;AAEA,IAAA,KAAA,CAAA,MAAA,GAAA,UAAA,CAAA,MAAA;AACA,SAAA,aAAA,CAAA,UAAA,EAAA,KAAA,EAAA,MAAA;AAEA,IAAA,IAAA,CAAA,MAAA,GAAA,IAAA,CAAA,MAAA,IAAA,EAAA;AACA,IAAA,IAAA,CAAA,MAAA,CAAA,UAAA,CAAA,EAAA,IAAA,KAAA;AACA,WAAA,KAAA;AACA;;AAEA,SAAA,YAAA,GAAA;AAAA,SAAA,eAAA,GAAA,EAAA;AAAA,GA/eA,CAifA;;;AACA,EAAA,cAAA,CAAA,IAAA,EAAA,IAAA,EAAA;AACA,QAAA,QAAA,GAAA,KAAA,WAAA,EAAA;AACA,QAAA,IAAA,GAAA,IAAA,OAAA,CAAA,EAAA,CAAA;AACA,IAAA,QAAA,CAAA,KAAA;AACA,IAAA,QAAA,CAAA,SAAA,CAAA,QAAA,EAAA,CAAA;AACA,IAAA,QAAA,CAAA,WAAA,CAAA,IAAA;AACA,IAAA,QAAA,CAAA,UAAA,GAAA,KAAA;AACA,IAAA,IAAA,CAAA,eAAA,GAAA,QAAA;AACA,IAAA,IAAA,CAAA,iBAAA,GAAA,KAAA,YAAA,EAAA;AACA,IAAA,IAAA,CAAA,iBAAA,CAAA,IAAA,GAAA,IAAA,CAAA,eAAA;AAEA,WAAA,QAAA;AACA;;AAEA,EAAA,cAAA,CAAA,IAAA,EAAA,IAAA,EAAA;AACA,QAAA,IAAA,GAAA,IAAA,CAAA,eAAA,CAAA,QAAA;AACA,QAAA,QAAA,GAAA,IAAA,CAAA,YAAA,CAAA,CAAA,EAAA,KAAA,CAAA,MAAA;AACA,QAAA,CAAA,GAAA,IAAA,CAAA,mBAAA;AACA,IAAA,QAAA,CAAA,MAAA,GAAA,CAAA;AACA,IAAA,IAAA,CAAA,oBAAA,CAAA,IAAA,EAAA,CAAA,EAAA,CAAA,EAAA,QAAA,EAAA,CAAA,EAAA,CAAA;AACA,IAAA,IAAA,CAAA,UAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,EAAA,sBAAA,CAAA,SAAA,EAAA,OAAA,GAAA,IAAA,EAAA,IAAA,GAAA,IAAA,EAAA;AACA,QAAA,IAAA,GAAA,KAAA,QAAA,CAAA,KAAA,CAAA,SAAA,CAAA;;AACA,QAAA,CAAA,IAAA,EAAA;AACA,aAAA,KAAA;AACA;;AACA,QAAA,UAAA,GAAA,IAAA,CAAA,aAAA,EAAA;AACA,QAAA,MAAA,GAAA,UAAA,CAAA,MAAA;;AACA,QAAA,OAAA,EAAA;AACA,MAAA,MAAA,GAAA,IAAA,aAAA,EAAA;AACA,MAAA,MAAA,CAAA,OAAA,GAAA,OAAA;AACA,MAAA,MAAA,CAAA,IAAA,GAAA,IAAA;AACA,MAAA,IAAA,CAAA,UAAA,GAAA,MAAA;AACA,MAAA,IAAA,CAAA,cAAA,GAAA,UAAA;AACA,KANA,MAMA;AACA,MAAA,IAAA,CAAA,UAAA,GAAA,IAAA;AACA,MAAA,IAAA,CAAA,cAAA,GAAA,IAAA;AACA;;AACA,QAAA,IAAA,CAAA,aAAA,IAAA,IAAA,CAAA,aAAA,CAAA,MAAA,IAAA,MAAA,EAAA;AACA,WAAA,eAAA,CAAA,UAAA,EAAA,IAAA,CAAA,aAAA,EAAA,MAAA;AACA,MAAA,IAAA,CAAA,aAAA,CAAA,MAAA,GAAA,MAAA;AACA,KAHA,MAGA,IAAA,IAAA,CAAA,WAAA,IAAA,IAAA,CAAA,WAAA,CAAA,MAAA,IAAA,MAAA,EAAA;AACA,WAAA,aAAA,CAAA,UAAA,EAAA,IAAA,CAAA,WAAA,EAAA,MAAA;AACA;;AACA,WAAA,IAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,EAAA,qBAAA,CAAA,QAAA,EAAA,OAAA,GAAA,IAAA,EAAA,IAAA,GAAA,IAAA,EAAA;AACA,QAAA,KAAA,GAAA,KAAA,QAAA,CAAA,aAAA,CAAA,QAAA,CAAA;;AACA,QAAA,KAAA,IAAA,CAAA,CAAA,EAAA;AACA,aAAA,KAAA;AACA;;AACA,WAAA,KAAA,sBAAA,CAAA,KAAA,EAAA,OAAA,EAAA,IAAA,CAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,EAAA,qBAAA,CAAA,QAAA,EAAA,cAAA,EAAA,OAAA,EAAA,IAAA,GAAA,IAAA,EAAA;AACA;AACA,UAAA,SAAA,GAAA,KAAA,QAAA,CAAA,aAAA,CAAA,QAAA,CAAA;AACA,UAAA,UAAA,GAAA,KAAA,QAAA,CAAA,mBAAA,CAAA,QAAA,EAAA,cAAA,CAAA;AACA,IAAA,UAAA,CAAA,MAAA,CAAA,OAAA,GAAA,OAAA;AAEA,UAAA,IAAA,GAAA,KAAA,QAAA,CAAA,KAAA,CAAA,SAAA,CAAA;;AACA,QAAA,CAAA,IAAA,EAAA;AACA,aAAA,KAAA;AACA,KATA,CAWA;;;AACA,UAAA,iBAAA,GAAA,IAAA,CAAA,aAAA,EAAA;;AACA,QAAA,cAAA,KAAA,iBAAA,CAAA,IAAA,EAAA;AACA;AACA,UAAA,MAAA,GAAA,UAAA,CAAA,MAAA;;AACA,UAAA,OAAA,EAAA;AACA,QAAA,MAAA,GAAA,IAAA,aAAA,EAAA;AACA,QAAA,MAAA,CAAA,OAAA,GAAA,OAAA;AACA,QAAA,MAAA,CAAA,IAAA,GAAA,IAAA;AACA,QAAA,IAAA,CAAA,UAAA,GAAA,MAAA;AACA,QAAA,IAAA,CAAA,cAAA,GAAA,iBAAA;AACA,OANA,MAMA;AACA,QAAA,IAAA,CAAA,UAAA,GAAA,IAAA;AACA,QAAA,IAAA,CAAA,cAAA,GAAA,IAAA;AACA;;AACA,UAAA,IAAA,CAAA,aAAA,IAAA,IAAA,CAAA,aAAA,CAAA,MAAA,IAAA,MAAA,EAAA;AACA,aAAA,eAAA,CAAA,iBAAA,EAAA,IAAA,CAAA,aAAA,EAAA,MAAA;AACA,QAAA,IAAA,CAAA,aAAA,CAAA,MAAA,GAAA,MAAA;AACA,OAHA,MAGA,IAAA,IAAA,CAAA,WAAA,IAAA,IAAA,CAAA,WAAA,CAAA,MAAA,IAAA,MAAA,EAAA;AACA,aAAA,aAAA,CAAA,iBAAA,EAAA,IAAA,CAAA,WAAA,EAAA,MAAA;AACA;;AACA,aAAA,IAAA;AACA;;AACA,WAAA,KAAA;AACA,GA7mBA,CA+mBA;;;AACA,EAAA,YAAA,GAAA;AACA,WAAA,IAAA,SAAA,EAAA;AACA;;AAEA,EAAA,SAAA,CAAA,GAAA,EAAA;AACA,WAAA,IAAA,WAAA,CAAA,GAAA,CAAA;AACA;;AAEA,EAAA,WAAA,GAAA;AACA,WAAA,IAAA,QAAA,EAAA;AACA;;AAEA,EAAA,OAAA,CAAA,OAAA,EAAA,QAAA,EAAA,GAAA,EAAA,OAAA,EAAA,QAAA,EAAA;AACA,WAAA,IAAA,SAAA,CAAA,OAAA,EAAA,QAAA,EAAA,GAAA,EAAA,OAAA,EAAA,QAAA,CAAA;AACA;;AAEA,EAAA,aAAA,GAAA;AACA,WAAA,CAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,EAAA,oBAAA,CAAA,UAAA,EAAA,KAAA,EAAA,QAAA,EAAA;AACA,QAAA,CAAA,UAAA,EAAA;AACA,aAAA,SAAA;AACA;;AACA,UAAA,MAAA,GAAA,EAAA;AAAA,UAAA,MAAA,GAAA,EAAA;;AACA,SAAA,IAAA,CAAA,GAAA,CAAA,EAAA,GAAA,GAAA,KAAA,QAAA,CAAA,KAAA,CAAA,MAAA,EAAA,CAAA,GAAA,GAAA,EAAA,CAAA,EAAA,EAAA;AACA,YAAA,IAAA,GAAA,KAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA;AACA,YAAA,IAAA,GAAA,IAAA,CAAA,iBAAA,IAAA,IAAA,CAAA,eAAA,IAAA,EAAA;AACA,YAAA,MAAA,GAAA,IAAA,CAAA,aAAA,IAAA,IAAA,CAAA,WAAA;;AACA,UAAA,IAAA,CAAA,QAAA,CAAA,UAAA,CAAA,EAAA;AACA,QAAA,MAAA,CAAA,WAAA,GAAA,KAAA;AACA,QAAA,MAAA,CAAA,IAAA,CAAA,MAAA;AACA,OAHA,MAGA,IAAA,QAAA,IAAA,MAAA,EAAA;AACA,QAAA,MAAA,CAAA,WAAA,GAAA,QAAA;AACA,QAAA,MAAA,CAAA,IAAA,CAAA,MAAA;AACA;AACA;;AACA,WAAA,CAAA,MAAA,EAAA,MAAA,CAAA;AACA;;AAEA,EAAA,OAAA,CAAA,OAAA,EAAA;AACA,SAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,KAAA,QAAA,CAAA,KAAA,CAAA,MAAA,EAAA,CAAA,GAAA,CAAA,EAAA,CAAA,EAAA,EAAA;AACA,UAAA,IAAA,GAAA,KAAA,QAAA,CAAA,KAAA,CAAA,CAAA,CAAA;;AACA,WAAA,IAAA,IAAA,IAAA,IAAA,CAAA,MAAA,EAAA;AACA,QAAA,IAAA,CAAA,MAAA,CAAA,IAAA,EAAA,OAAA,CAAA,OAAA;AACA;;AACA,MAAA,IAAA,CAAA,MAAA,GAAA,IAAA;;AAEA,WAAA,IAAA,IAAA,IAAA,IAAA,CAAA,OAAA,EAAA;AACA,QAAA,IAAA,CAAA,OAAA,CAAA,IAAA,EAAA,OAAA,CAAA,OAAA;AACA;;AACA,MAAA,IAAA,CAAA,OAAA,GAAA,IAAA;AACA;;AAEA,SAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,GAAA,KAAA,cAAA,CAAA,MAAA,EAAA,CAAA,GAAA,CAAA,EAAA,CAAA,EAAA,EAAA;AACA,WAAA,cAAA,CAAA,CAAA,EAAA,OAAA,CAAA,OAAA;AACA;;AACA,SAAA,SAAA,GAAA,IAAA;AACA,SAAA,QAAA,GAAA,IAAA;AACA,SAAA,cAAA,GAAA,IAAA;AACA,SAAA,SAAA,GAAA,IAAA;AACA,SAAA,KAAA,GAAA,IAAA;AACA,SAAA,kBAAA,GAAA,IAAA;AAEA,UAAA,OAAA,CAAA,OAAA;AACA;;AAvrBA;;AAwrBA,SAAA,CAAA,YAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAA,CAAA,cAAA,CAAA,SAAA,CAAA,SAAA,EAAA,SAAA,EAAA;AACA,EAAA,GAAA,EAAA,YAAA;AACA,WAAA,KAAA,QAAA;AACA,GAHA;AAIA,EAAA,GAAA,EAAA,UAAA,KAAA,EAAA;AACA,QAAA,KAAA,KAAA,KAAA,QAAA,EAAA;AACA,WAAA,QAAA,GAAA,KAAA;;AACA,UAAA,KAAA,EAAA;AACA,aAAA,QAAA,GAAA,CAAA;AACA;AACA;AACA;AAXA,CAAA","sourcesContent":["\r\n/**\r\n * @public\r\n */\r\nexport enum AttachmentType {\r\n    Region, BoundingBox, Mesh, LinkedMesh, Path, Point, Clipping\r\n}\r\n","/**\r\n * @public\r\n */\r\nexport class BinaryInput {\r\n    constructor(data: Uint8Array, public strings = new Array<string>(), private index: number = 0, private buffer = new DataView(data.buffer)) {\r\n\r\n    }\r\n\r\n    readByte(): number {\r\n        return this.buffer.getInt8(this.index++);\r\n    }\r\n\r\n    readUnsignedByte(): number {\r\n        return this.buffer.getUint8(this.index++);\r\n    }\r\n\r\n    readShort(): number {\r\n        let value = this.buffer.getInt16(this.index);\r\n        this.index += 2;\r\n        return value;\r\n    }\r\n\r\n    readInt32(): number {\r\n        let value = this.buffer.getInt32(this.index)\r\n        this.index += 4;\r\n        return value;\r\n    }\r\n\r\n    readInt(optimizePositive: boolean) {\r\n        let b = this.readByte();\r\n        let result = b & 0x7F;\r\n        if ((b & 0x80) != 0) {\r\n            b = this.readByte();\r\n            result |= (b & 0x7F) << 7;\r\n            if ((b & 0x80) != 0) {\r\n                b = this.readByte();\r\n                result |= (b & 0x7F) << 14;\r\n                if ((b & 0x80) != 0) {\r\n                    b = this.readByte();\r\n                    result |= (b & 0x7F) << 21;\r\n                    if ((b & 0x80) != 0) {\r\n                        b = this.readByte();\r\n                        result |= (b & 0x7F) << 28;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return optimizePositive ? result : ((result >>> 1) ^ -(result & 1));\r\n    }\r\n\r\n    readStringRef (): string {\r\n        let index = this.readInt(true);\r\n        return index == 0 ? null : this.strings[index - 1];\r\n    }\r\n\r\n    readString (): string {\r\n        let byteCount = this.readInt(true);\r\n        switch (byteCount) {\r\n            case 0:\r\n                return null;\r\n            case 1:\r\n                return \"\";\r\n        }\r\n        byteCount--;\r\n        let chars = \"\";\r\n        for (let i = 0; i < byteCount;) {\r\n            let b = this.readByte();\r\n            switch (b >> 4) {\r\n                case 12:\r\n                case 13:\r\n                    chars += String.fromCharCode(((b & 0x1F) << 6 | this.readByte() & 0x3F));\r\n                    i += 2;\r\n                    break;\r\n                case 14:\r\n                    chars += String.fromCharCode(((b & 0x0F) << 12 | (this.readByte() & 0x3F) << 6 | this.readByte() & 0x3F));\r\n                    i += 3;\r\n                    break;\r\n                default:\r\n                    chars += String.fromCharCode(b);\r\n                    i++;\r\n            }\r\n        }\r\n        return chars;\r\n    }\r\n\r\n    readFloat (): number {\r\n        let value = this.buffer.getFloat32(this.index);\r\n        this.index += 4;\r\n        return value;\r\n    }\r\n\r\n    readBoolean (): boolean {\r\n        return this.readByte() != 0;\r\n    }\r\n}\r\n","\r\nimport { Texture } from '@pixi/core';\r\nimport { Rectangle } from '@pixi/math';\r\n\r\n/**\r\n * @public\r\n */\r\nexport function filterFromString (text: string): TextureFilter {\r\n    switch (text.toLowerCase()) {\r\n        case \"nearest\": return TextureFilter.Nearest;\r\n        case \"linear\": return TextureFilter.Linear;\r\n        case \"mipmap\": return TextureFilter.MipMap;\r\n        case \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\r\n        case \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\r\n        case \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\r\n        case \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\r\n        default: throw new Error(`Unknown texture filter ${text}`);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport function wrapFromString (text: string): TextureWrap {\r\n    switch (text.toLowerCase()) {\r\n        case \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\r\n        case \"clamptoedge\": return TextureWrap.ClampToEdge;\r\n        case \"repeat\": return TextureWrap.Repeat;\r\n        default: throw new Error(`Unknown texture wrap ${text}`);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum TextureFilter {\r\n    Nearest = 9728, // WebGLRenderingContext.NEAREST\r\n    Linear = 9729, // WebGLRenderingContext.LINEAR\r\n    MipMap = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\r\n    MipMapNearestNearest = 9984, // WebGLRenderingContext.NEAREST_MIPMAP_NEAREST\r\n    MipMapLinearNearest = 9985, // WebGLRenderingContext.LINEAR_MIPMAP_NEAREST\r\n    MipMapNearestLinear = 9986, // WebGLRenderingContext.NEAREST_MIPMAP_LINEAR\r\n    MipMapLinearLinear = 9987 // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum TextureWrap {\r\n    MirroredRepeat = 33648, // WebGLRenderingContext.MIRRORED_REPEAT\r\n    ClampToEdge = 33071, // WebGLRenderingContext.CLAMP_TO_EDGE\r\n    Repeat = 10497 // WebGLRenderingContext.REPEAT\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TextureRegion {\r\n    texture: Texture;\r\n\r\n    //thats for overrides\r\n    size: Rectangle = null;\r\n\r\n    names: string[] = null;\r\n    values: number[][] = null;\r\n\r\n    get width(): number {\r\n        const tex = this.texture;\r\n        if (tex.trim) {\r\n            return tex.trim.width;\r\n        }\r\n        return tex.orig.width;\r\n    }\r\n\r\n    get height(): number {\r\n        const tex = this.texture;\r\n        if (tex.trim) {\r\n            return tex.trim.height;\r\n        }\r\n        return tex.orig.height;\r\n    }\r\n\r\n    get u(): number {\r\n        return (this.texture as any)._uvs.x0;\r\n    }\r\n\r\n    get v(): number {\r\n        return (this.texture as any)._uvs.y0;\r\n    }\r\n\r\n    get u2(): number {\r\n        return (this.texture as any)._uvs.x2;\r\n    }\r\n\r\n    get v2(): number {\r\n        return (this.texture as any)._uvs.y2;\r\n    }\r\n\r\n    get offsetX(): number {\r\n        const tex = this.texture;\r\n        return tex.trim ? tex.trim.x : 0;\r\n    }\r\n\r\n    get offsetY(): number {\r\n        // console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\r\n        return this.spineOffsetY;\r\n    }\r\n\r\n    get pixiOffsetY(): number {\r\n        const tex = this.texture;\r\n        return tex.trim ? tex.trim.y : 0;\r\n    }\r\n\r\n    get spineOffsetY(): number {\r\n        let tex = this.texture;\r\n        return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\r\n    }\r\n\r\n    get originalWidth(): number {\r\n        return this.texture.orig.width;\r\n    }\r\n\r\n    get originalHeight(): number {\r\n        return this.texture.orig.height;\r\n    }\r\n\r\n    get x(): number {\r\n        return this.texture.frame.x;\r\n    }\r\n\r\n    get y(): number {\r\n        return this.texture.frame.y;\r\n    }\r\n\r\n    get rotate(): boolean {\r\n        return this.texture.rotate !== 0;\r\n    }\r\n\r\n    get degrees() {\r\n        return (360 - this.texture.rotate * 45) % 360;\r\n    }\r\n}\r\n","import {SCALE_MODES, MIPMAP_MODES, ALPHA_MODES} from '@pixi/constants';\r\nimport {Texture} from '@pixi/core';\r\nimport {Rectangle} from '@pixi/math';\r\nimport {TextureRegion, TextureWrap, TextureFilter, filterFromString} from './TextureRegion';\r\nimport {Map, Disposable} from './Utils';\r\n\r\nimport type {BaseTexture} from '@pixi/core';\r\n\r\nclass RegionFields {\r\n    x = 0;\r\n    y = 0;\r\n    width = 0;\r\n    height = 0;\r\n    offsetX = 0;\r\n    offsetY = 0;\r\n    originalWidth = 0;\r\n    originalHeight = 0;\r\n    rotate = 0;\r\n    index = 0;\r\n}\r\n/**\r\n * @public\r\n */\r\nexport class TextureAtlas implements Disposable {\r\n    pages = new Array<TextureAtlasPage>();\r\n    regions = new Array<TextureAtlasRegion>();\r\n\r\n    constructor(atlasText?: string, textureLoader?: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback?: (obj: TextureAtlas) => any) {\r\n        if (atlasText) {\r\n            this.addSpineAtlas(atlasText, textureLoader, callback);\r\n        }\r\n    }\r\n\r\n    addTexture(name: string, texture: Texture) {\r\n        let pages = this.pages;\r\n        let page: TextureAtlasPage = null;\r\n        for (let i = 0; i < pages.length; i++) {\r\n            if (pages[i].baseTexture === texture.baseTexture) {\r\n                page = pages[i];\r\n                break;\r\n            }\r\n        }\r\n        if (page === null) {\r\n            page = new TextureAtlasPage();\r\n            page.name = 'texturePage';\r\n            let baseTexture = texture.baseTexture;\r\n            page.width = baseTexture.realWidth;\r\n            page.height = baseTexture.realHeight;\r\n            page.baseTexture = baseTexture;\r\n            //those fields are not relevant in Pixi\r\n            page.minFilter = page.magFilter = TextureFilter.Nearest;\r\n            page.uWrap = TextureWrap.ClampToEdge;\r\n            page.vWrap = TextureWrap.ClampToEdge;\r\n            pages.push(page);\r\n        }\r\n        let region = new TextureAtlasRegion();\r\n        region.name = name;\r\n        region.page = page;\r\n        region.texture = texture;\r\n        region.index = -1;\r\n        this.regions.push(region);\r\n        return region;\r\n    }\r\n\r\n    addTextureHash(textures: Map<Texture>, stripExtension: boolean) {\r\n        for (let key in textures) {\r\n            if (textures.hasOwnProperty(key)) {\r\n                this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\r\n            }\r\n        }\r\n    }\r\n\r\n    public addSpineAtlas(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\r\n        return this.load(atlasText, textureLoader, callback);\r\n    }\r\n\r\n    private load(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\r\n        if (textureLoader == null)\r\n            throw new Error(\"textureLoader cannot be null.\");\r\n\r\n        let reader = new TextureAtlasReader(atlasText);\r\n        let entry = new Array<string>(4);\r\n        let page: TextureAtlasPage = null;\r\n        let pageFields: Map<Function> = {};\r\n        let region: RegionFields = null;\r\n        pageFields[\"size\"] = () => {\r\n            page.width = parseInt(entry[1]);\r\n            page.height = parseInt(entry[2]);\r\n        };\r\n        pageFields[\"format\"] = () => {\r\n            // page.format = Format[tuple[0]]; we don't need format in WebGL\r\n        };\r\n        pageFields[\"filter\"] = () => {\r\n            page.minFilter = filterFromString(entry[1]);\r\n            page.magFilter = filterFromString(entry[2]);\r\n        };\r\n        pageFields[\"repeat\"] = () => {\r\n            if (entry[1].indexOf('x') != -1) page.uWrap = TextureWrap.Repeat;\r\n            if (entry[1].indexOf('y') != -1) page.vWrap = TextureWrap.Repeat;\r\n        };\r\n        pageFields[\"pma\"] = () => {\r\n            page.pma = entry[1] == \"true\";\r\n        };\r\n\r\n        let regionFields: Map<Function> = {};\r\n        regionFields[\"xy\"] = () => { // Deprecated, use bounds.\r\n            region.x = parseInt(entry[1]);\r\n            region.y = parseInt(entry[2]);\r\n        };\r\n        regionFields[\"size\"] = () => { // Deprecated, use bounds.\r\n            region.width = parseInt(entry[1]);\r\n            region.height = parseInt(entry[2]);\r\n        };\r\n        regionFields[\"bounds\"] = () => {\r\n            region.x = parseInt(entry[1]);\r\n            region.y = parseInt(entry[2]);\r\n            region.width = parseInt(entry[3]);\r\n            region.height = parseInt(entry[4]);\r\n        };\r\n        regionFields[\"offset\"] = () => { // Deprecated, use offsets.\r\n            region.offsetX = parseInt(entry[1]);\r\n            region.offsetY = parseInt(entry[2]);\r\n        };\r\n        regionFields[\"orig\"] = () => { // Deprecated, use offsets.\r\n            region.originalWidth = parseInt(entry[1]);\r\n            region.originalHeight = parseInt(entry[2]);\r\n        };\r\n        regionFields[\"offsets\"] = () => {\r\n            region.offsetX = parseInt(entry[1]);\r\n            region.offsetY = parseInt(entry[2]);\r\n            region.originalWidth = parseInt(entry[3]);\r\n            region.originalHeight = parseInt(entry[4]);\r\n        };\r\n        regionFields[\"rotate\"] = () => {\r\n            let rotateValue = entry[1];\r\n            let rotate = 0;\r\n            if (rotateValue.toLocaleLowerCase() == \"true\") {\r\n                rotate = 6;\r\n            } else if (rotateValue.toLocaleLowerCase() == \"false\") {\r\n                rotate = 0;\r\n            } else {\r\n                rotate = ((720 - parseFloat(rotateValue)) % 360) / 45;\r\n            }\r\n            region.rotate = rotate;\r\n        };\r\n        regionFields[\"index\"] = () => {\r\n            region.index = parseInt(entry[1]);\r\n        };\r\n\r\n        let line = reader.readLine();\r\n        // Ignore empty lines before first entry.\r\n        while (line != null && line.trim().length == 0)\r\n            line = reader.readLine();\r\n        // Header entries.\r\n        while (true) {\r\n            if (line == null || line.trim().length == 0) break;\r\n            if (reader.readEntry(entry, line) == 0) break; // Silently ignore all header fields.\r\n            line = reader.readLine();\r\n        }\r\n\r\n        let iterateParser = () => {\r\n            while (true) {\r\n                if (line == null) {\r\n                    return callback && callback(this);\r\n                }\r\n                if (line.trim().length == 0) {\r\n                    page = null;\r\n                    line = reader.readLine();\r\n                } else if (page === null) {\r\n                    page = new TextureAtlasPage();\r\n                    page.name = line.trim();\r\n\r\n                    while (true) {\r\n                        if (reader.readEntry(entry, line = reader.readLine()) == 0) break;\r\n                        let field: Function = pageFields[entry[0]];\r\n                        if (field) field();\r\n                    }\r\n                    this.pages.push(page);\r\n\r\n                    textureLoader(page.name, (texture: BaseTexture) => {\r\n                        if (texture === null) {\r\n                            this.pages.splice(this.pages.indexOf(page), 1);\r\n                            return callback && callback(null);\r\n                        }\r\n                        page.baseTexture = texture;\r\n                        //TODO: set scaleMode and mipmapMode from spine\r\n                        if (page.pma) {\r\n                            texture.alphaMode = ALPHA_MODES.PMA;\r\n                        }\r\n                        if (!texture.valid) {\r\n                            texture.setSize(page.width, page.height);\r\n                        }\r\n                        this.pages.push(page);\r\n                        page.setFilters();\r\n\r\n                        if (!page.width || !page.height) {\r\n                            page.width = texture.realWidth;\r\n                            page.height = texture.realHeight;\r\n                            if (!page.width || !page.height) {\r\n                                console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\r\n                            }\r\n                        }\r\n                        iterateParser();\r\n                    });\r\n                    this.pages.push(page);\r\n                    break;\r\n                } else {\r\n                    region = new RegionFields();\r\n                    let atlasRegion = new TextureAtlasRegion();\r\n                    atlasRegion.name = line;\r\n                    atlasRegion.page = page;\r\n                    let names: string[] = null;\r\n                    let values: number[][] = null;\r\n                    while (true) {\r\n                        let count = reader.readEntry(entry, line = reader.readLine());\r\n                        if (count == 0) break;\r\n                        let field: Function = regionFields[entry[0]];\r\n                        if (field)\r\n                            field();\r\n                        else {\r\n                            if (names == null) {\r\n                                names = [];\r\n                                values = []\r\n                            }\r\n                            names.push(entry[0]);\r\n                            let entryValues: number[] = [];\r\n                            for (let i = 0; i < count; i++)\r\n                                entryValues.push(parseInt(entry[i + 1]));\r\n                            values.push(entryValues);\r\n                        }\r\n                    }\r\n                    if (region.originalWidth == 0 && region.originalHeight == 0) {\r\n                        region.originalWidth = region.width;\r\n                        region.originalHeight = region.height;\r\n                    }\r\n\r\n                    let resolution = page.baseTexture.resolution;\r\n                    region.x /= resolution;\r\n                    region.y /= resolution;\r\n                    region.width /= resolution;\r\n                    region.height /= resolution;\r\n                    region.originalWidth /= resolution;\r\n                    region.originalHeight /= resolution;\r\n                    region.offsetX /= resolution;\r\n                    region.offsetY /= resolution;\r\n\r\n                    const swapWH = region.rotate % 4 !== 0;\r\n                    let frame = new Rectangle(region.x, region.y, swapWH ? region.height : region.width, swapWH ? region.width : region.height);\r\n\r\n                    let orig = new Rectangle(0, 0, region.originalWidth, region.originalHeight);\r\n                    let trim = new Rectangle(region.offsetX, region.originalHeight - region.height - region.offsetY, region.width, region.height);\r\n\r\n                    atlasRegion.texture = new Texture(atlasRegion.page.baseTexture, frame, orig, trim, region.rotate);\r\n                    atlasRegion.index = region.index;\r\n                    atlasRegion.texture.updateUvs();\r\n\r\n                    this.regions.push(atlasRegion);\r\n                }\r\n            }\r\n        };\r\n\r\n        iterateParser();\r\n    }\r\n\r\n    findRegion(name: string): TextureAtlasRegion {\r\n        for (let i = 0; i < this.regions.length; i++) {\r\n            if (this.regions[i].name == name) {\r\n                return this.regions[i];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    dispose() {\r\n        for (let i = 0; i < this.pages.length; i++) {\r\n            this.pages[i].baseTexture.dispose();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nclass TextureAtlasReader {\r\n    lines: Array<string>;\r\n    index: number = 0;\r\n\r\n    constructor(text: string) {\r\n        this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n    }\r\n\r\n    readLine(): string {\r\n        if (this.index >= this.lines.length)\r\n            return null;\r\n        return this.lines[this.index++];\r\n    }\r\n\r\n    readEntry (entry: string[], line: string): number {\r\n        if (line == null) return 0;\r\n        line = line.trim();\r\n        if (line.length == 0) return 0;\r\n\r\n        let colon = line.indexOf(':');\r\n        if (colon == -1) return 0;\r\n        entry[0] = line.substr(0, colon).trim();\r\n        for (let i = 1, lastMatch = colon + 1;; i++) {\r\n            let comma = line.indexOf(',', lastMatch);\r\n            if (comma == -1) {\r\n                entry[i] = line.substr(lastMatch).trim();\r\n                return i;\r\n            }\r\n            entry[i] = line.substr(lastMatch, comma - lastMatch).trim();\r\n            lastMatch = comma + 1;\r\n            if (i == 4) return 4;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TextureAtlasPage {\r\n    name: string;\r\n    minFilter: TextureFilter = TextureFilter.Nearest;\r\n    magFilter: TextureFilter = TextureFilter.Nearest;\r\n    uWrap: TextureWrap = TextureWrap.ClampToEdge;\r\n    vWrap: TextureWrap = TextureWrap.ClampToEdge;\r\n    baseTexture: BaseTexture;\r\n    width: number;\r\n    height: number;\r\n    pma: boolean;\r\n\r\n    public setFilters() {\r\n        let tex = this.baseTexture;\r\n        let filter = this.minFilter;\r\n        if (filter == TextureFilter.Linear) {\r\n            tex.scaleMode = SCALE_MODES.LINEAR;\r\n        } else if (this.minFilter == TextureFilter.Nearest) {\r\n            tex.scaleMode = SCALE_MODES.NEAREST;\r\n        } else {\r\n            tex.mipmap = MIPMAP_MODES.POW2;\r\n            if (filter == TextureFilter.MipMapNearestNearest) {\r\n                tex.scaleMode = SCALE_MODES.NEAREST;\r\n            } else {\r\n                tex.scaleMode = SCALE_MODES.LINEAR;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TextureAtlasRegion extends TextureRegion {\r\n    page: TextureAtlasPage;\r\n    name: string;\r\n    index: number;\r\n}\r\n","import {ISkeleton} from \"./ISkeleton\";\r\n\r\n\r\nlet fround_polyfill = (function(array) {\r\n    return function(x: number) {\r\n        return array[0] = x, array[0];\r\n    };\r\n})(new Float32Array(1));\r\n\r\nlet fround: (value: number) => number =\r\n    (Math as any).fround || fround_polyfill;\r\n/**\r\n * @public\r\n */\r\nexport interface Map<T> {\r\n    [key: string]: T;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class IntSet {\r\n    array = new Array<number>();\r\n\r\n    add (value: number): boolean {\r\n        let contains = this.contains(value);\r\n        this.array[value | 0] = value | 0;\r\n        return !contains;\r\n    }\r\n\r\n    contains (value: number) {\r\n        return this.array[value | 0] != undefined;\r\n    }\r\n\r\n    remove (value: number) {\r\n        this.array[value | 0] = undefined;\r\n    }\r\n\r\n    clear () {\r\n        this.array.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class StringSet {\r\n    entries: Map<boolean> = {};\r\n    size = 0;\r\n\r\n    add (value: string): boolean {\r\n        let contains = this.entries[value];\r\n        this.entries[value] = true;\r\n        if (!contains) {\r\n            this.size++;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    addAll (values: string[]): boolean {\r\n        let oldSize = this.size;\r\n        for (var i = 0, n = values.length; i < n; i++)\r\n            this.add(values[i]);\r\n        return oldSize != this.size;\r\n    }\r\n\r\n    contains (value: string) {\r\n        return this.entries[value];\r\n    }\r\n\r\n    clear () {\r\n        this.entries = {};\r\n        this.size = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface Disposable {\r\n    dispose (): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface Restorable {\r\n    restore (): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Color {\r\n    public static WHITE = new Color(1, 1, 1, 1);\r\n    public static RED = new Color(1, 0, 0, 1);\r\n    public static GREEN = new Color(0, 1, 0, 1);\r\n    public static BLUE = new Color(0, 0, 1, 1);\r\n    public static MAGENTA = new Color(1, 0, 1, 1);\r\n\r\n    constructor (public r: number = 0, public g: number = 0, public b: number = 0, public a: number = 0) {\r\n    }\r\n\r\n    set (r: number, g: number, b: number, a: number) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = a;\r\n        return this.clamp();\r\n    }\r\n\r\n    setFromColor (c: Color) {\r\n        this.r = c.r;\r\n        this.g = c.g;\r\n        this.b = c.b;\r\n        this.a = c.a;\r\n        return this;\r\n    }\r\n\r\n    setFromString (hex: string) {\r\n        hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\r\n        this.r = parseInt(hex.substr(0, 2), 16) / 255;\r\n        this.g = parseInt(hex.substr(2, 2), 16) / 255;\r\n        this.b = parseInt(hex.substr(4, 2), 16) / 255;\r\n        this.a = hex.length != 8 ? 1 : parseInt(hex.substr(6, 2), 16) / 255;\r\n        return this;\r\n    }\r\n\r\n    add (r: number, g: number, b: number, a: number) {\r\n        this.r += r;\r\n        this.g += g;\r\n        this.b += b;\r\n        this.a += a;\r\n        return this.clamp();\r\n    }\r\n\r\n    clamp () {\r\n        if (this.r < 0) this.r = 0;\r\n        else if (this.r > 1) this.r = 1;\r\n\r\n        if (this.g < 0) this.g = 0;\r\n        else if (this.g > 1) this.g = 1;\r\n\r\n        if (this.b < 0) this.b = 0;\r\n        else if (this.b > 1) this.b = 1;\r\n\r\n        if (this.a < 0) this.a = 0;\r\n        else if (this.a > 1) this.a = 1;\r\n        return this;\r\n    }\r\n\r\n    static rgba8888ToColor(color: Color, value: number) {\r\n        color.r = ((value & 0xff000000) >>> 24) / 255;\r\n        color.g = ((value & 0x00ff0000) >>> 16) / 255;\r\n        color.b = ((value & 0x0000ff00) >>> 8) / 255;\r\n        color.a = ((value & 0x000000ff)) / 255;\r\n    }\r\n\r\n    static rgb888ToColor (color: Color, value: number) {\r\n        color.r = ((value & 0x00ff0000) >>> 16) / 255;\r\n        color.g = ((value & 0x0000ff00) >>> 8) / 255;\r\n        color.b = ((value & 0x000000ff)) / 255;\r\n    }\r\n\r\n    static fromString (hex : string) : Color {\r\n        return new Color().setFromString(hex);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class MathUtils {\r\n    static PI = 3.1415927;\r\n    static PI2 = MathUtils.PI * 2;\r\n    static radiansToDegrees = 180 / MathUtils.PI;\r\n    static radDeg = MathUtils.radiansToDegrees;\r\n    static degreesToRadians = MathUtils.PI / 180;\r\n    static degRad = MathUtils.degreesToRadians;\r\n\r\n    static clamp (value: number, min: number, max: number) {\r\n        if (value < min) return min;\r\n        if (value > max) return max;\r\n        return value;\r\n    }\r\n\r\n    static cosDeg (degrees: number) {\r\n        return Math.cos(degrees * MathUtils.degRad);\r\n    }\r\n\r\n    static sinDeg (degrees: number) {\r\n        return Math.sin(degrees * MathUtils.degRad);\r\n    }\r\n\r\n    static signum (value: number): number {\r\n        return value > 0 ? 1 : value < 0 ? -1 : 0;\r\n    }\r\n\r\n    static toInt (x: number) {\r\n        return x > 0 ? Math.floor(x) : Math.ceil(x);\r\n    }\r\n\r\n    static cbrt (x: number) {\r\n        let y = Math.pow(Math.abs(x), 1/3);\r\n        return x < 0 ? -y : y;\r\n    }\r\n\r\n    static randomTriangular (min: number, max: number): number {\r\n        return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\r\n    }\r\n\r\n    static randomTriangularWith (min: number, max: number, mode: number): number {\r\n        let u = Math.random();\r\n        let d = max - min;\r\n        if (u <= (mode - min) / d) return min + Math.sqrt(u * d * (mode - min));\r\n        return max - Math.sqrt((1 - u) * d * (max - mode));\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class Interpolation {\r\n    protected abstract applyInternal (a: number): number;\r\n    apply(start: number, end: number, a: number): number {\r\n        return start + (end - start) * this.applyInternal(a);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Pow extends Interpolation {\r\n    protected power = 2;\r\n\r\n    constructor (power: number) {\r\n        super();\r\n        this.power = power;\r\n    }\r\n\r\n    applyInternal (a: number): number {\r\n        if (a <= 0.5) return Math.pow(a * 2, this.power) / 2;\r\n        return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PowOut extends Pow {\r\n    constructor (power: number) {\r\n        super(power);\r\n    }\r\n\r\n    applyInternal (a: number) : number {\r\n        return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Utils {\r\n    static SUPPORTS_TYPED_ARRAYS = typeof(Float32Array) !== \"undefined\";\r\n\r\n    static arrayCopy<T> (source: ArrayLike<T>, sourceStart: number, dest: ArrayLike<T>, destStart: number, numElements: number) {\r\n        for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\r\n            dest[j] = source[i];\r\n        }\r\n    }\r\n\r\n    static arrayFill<T> (array: ArrayLike<T>, fromIndex: number, toIndex: number, value: T) {\r\n        for (let i = fromIndex; i < toIndex; i++)\r\n            array[i] = value;\r\n    }\r\n\r\n    static setArraySize<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\r\n        let oldSize = array.length;\r\n        if (oldSize == size) return array;\r\n        array.length = size;\r\n        if (oldSize < size) {\r\n            for (let i = oldSize; i < size; i++) array[i] = value;\r\n        }\r\n        return array;\r\n    }\r\n\r\n    static ensureArrayCapacity<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\r\n        if (array.length >= size) return array;\r\n        return Utils.setArraySize(array, size, value);\r\n    }\r\n\r\n    static newArray<T> (size: number, defaultValue: T): Array<T> {\r\n        let array = new Array<T>(size);\r\n        for (let i = 0; i < size; i++) array[i] = defaultValue;\r\n        return array;\r\n    }\r\n\r\n    static newFloatArray (size: number): ArrayLike<number> {\r\n        if (Utils.SUPPORTS_TYPED_ARRAYS)\r\n            return new Float32Array(size)\r\n        else {\r\n            let array = new Array<number>(size);\r\n            for (let i = 0; i < array.length; i++) array[i] = 0;\r\n            return array;\r\n        }\r\n    }\r\n\r\n    static newShortArray (size: number): ArrayLike<number> {\r\n        if (Utils.SUPPORTS_TYPED_ARRAYS)\r\n            return new Int16Array(size)\r\n        else {\r\n            let array = new Array<number>(size);\r\n            for (let i = 0; i < array.length; i++) array[i] = 0;\r\n            return array;\r\n        }\r\n    }\r\n\r\n    static toFloatArray (array: Array<number>) {\r\n        return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\r\n    }\r\n\r\n    static toSinglePrecision (value: number) {\r\n        return Utils.SUPPORTS_TYPED_ARRAYS ? fround(value) : value;\r\n    }\r\n\r\n    // This function is used to fix WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n    static webkit602BugfixHelper (alpha: number, blend: any) {\r\n\r\n    }\r\n\r\n    static contains<T> (array: Array<T>, element: T, identity = true) {\r\n        for (let i = 0; i < array.length; i++)\r\n            if (array[i] == element) return true;\r\n        return false;\r\n    }\r\n\r\n    static enumValue (type: any, name: string) {\r\n        return type[name[0].toUpperCase() + name.slice(1)];\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class DebugUtils {\r\n    static logBones(skeleton: ISkeleton) {\r\n        for (let i = 0; i < skeleton.bones.length; i++) {\r\n            let bone = skeleton.bones[i];\r\n            let mat = bone.matrix;\r\n            console.log(bone.data.name + \", \" + mat.a + \", \" + mat.b + \", \" + mat.c + \", \" + mat.d + \", \" + mat.tx + \", \" + mat.ty);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Pool<T> {\r\n    private items = new Array<T>();\r\n    private instantiator: () => T;\r\n\r\n    constructor (instantiator: () => T) {\r\n        this.instantiator = instantiator;\r\n    }\r\n\r\n    obtain () {\r\n        return this.items.length > 0 ? this.items.pop() : this.instantiator();\r\n    }\r\n\r\n    free (item: T) {\r\n        if ((item as any).reset) (item as any).reset();\r\n        this.items.push(item);\r\n    }\r\n\r\n    freeAll (items: ArrayLike<T>) {\r\n        for (let i = 0; i < items.length; i++)\r\n            this.free(items[i]);\r\n    }\r\n\r\n    clear () {\r\n        this.items.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Vector2 {\r\n    constructor (public x = 0, public y = 0) {\r\n    }\r\n\r\n    set (x: number, y: number): Vector2 {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    length () {\r\n        let x = this.x;\r\n        let y = this.y;\r\n        return Math.sqrt(x * x + y * y);\r\n    }\r\n\r\n    normalize () {\r\n        let len = this.length();\r\n        if (len != 0) {\r\n            this.x /= len;\r\n            this.y /= len;\r\n        }\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TimeKeeper {\r\n    maxDelta = 0.064;\r\n    framesPerSecond = 0;\r\n    delta = 0;\r\n    totalTime = 0;\r\n\r\n    private lastTime = Date.now() / 1000;\r\n    private frameCount = 0;\r\n    private frameTime = 0;\r\n\r\n    update () {\r\n        let now = Date.now() / 1000;\r\n        this.delta = now - this.lastTime;\r\n        this.frameTime += this.delta;\r\n        this.totalTime += this.delta;\r\n        if (this.delta > this.maxDelta) this.delta = this.maxDelta;\r\n        this.lastTime = now;\r\n\r\n        this.frameCount++;\r\n        if (this.frameTime > 1) {\r\n            this.framesPerSecond = this.frameCount / this.frameTime;\r\n            this.frameTime = 0;\r\n            this.frameCount = 0;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ArrayLike<T> {\r\n    length: number;\r\n    [n: number]: T;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class WindowedMean {\r\n    values: Array<number>;\r\n    addedValues = 0;\r\n    lastValue = 0;\r\n    mean = 0;\r\n    dirty = true;\r\n\r\n    constructor (windowSize: number = 32) {\r\n        this.values = new Array<number>(windowSize);\r\n    }\r\n\r\n    hasEnoughData () {\r\n        return this.addedValues >= this.values.length;\r\n    }\r\n\r\n    addValue (value: number) {\r\n        if (this.addedValues < this.values.length) this.addedValues++;\r\n        this.values[this.lastValue++] = value;\r\n        if (this.lastValue > this.values.length - 1) this.lastValue = 0;\r\n        this.dirty = true;\r\n    }\r\n\r\n    getMean () {\r\n        if (this.hasEnoughData()) {\r\n            if (this.dirty) {\r\n                let mean = 0;\r\n                for (let i = 0; i < this.values.length; i++)\r\n                    mean += this.values[i];\r\n                this.mean = mean / this.values.length;\r\n                this.dirty = false;\r\n            }\r\n            return this.mean;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n","/**\r\n * @public\r\n */\r\nexport let settings = {\r\n    yDown: true,\r\n    /**\r\n     * pixi-spine gives option to not fail at certain parsing errors\r\n     * spine-ts fails here\r\n     */\r\n    FAIL_ON_NON_EXISTING_SKIN: false,\r\n\r\n    /**\r\n     * past Spine.globalAutoUpdate\r\n     */\r\n    GLOBAL_AUTO_UPDATE: true,\r\n\r\n    /**\r\n     * past Spine.globalDelayLimit\r\n     */\r\n    GLOBAL_DELAY_LIMIT: 0,\r\n}\r\n","import {AttachmentType} from './core/AttachmentType';\r\nimport {TextureRegion} from './core/TextureRegion';\r\nimport {TextureAtlasRegion} from './core/TextureAtlas';\r\nimport {MathUtils} from './core/Utils';\r\nimport type {\r\n    IAnimationState,\r\n    IAnimationStateData,\r\n    IAttachment, IClippingAttachment, IMeshAttachment,\r\n    IRegionAttachment,\r\n    ISkeleton,\r\n    ISkeletonData,\r\n    ISlot,\r\n    IVertexAttachment\r\n} from './core/ISkeleton';\r\n\r\nimport {DRAW_MODES} from '@pixi/constants';\r\nimport {Container, DisplayObject} from '@pixi/display';\r\nimport {Sprite} from '@pixi/sprite';\r\nimport {SimpleMesh} from '@pixi/mesh-extras';\r\nimport {Graphics} from '@pixi/graphics'\r\nimport {Rectangle, Polygon, Transform} from '@pixi/math';\r\nimport {hex2rgb, rgb2hex} from '@pixi/utils';\r\nimport type {Texture} from '@pixi/core';\r\nimport {settings} from \"./settings\";\r\n\r\nlet tempRgb = [0, 0, 0];\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISpineDisplayObject extends DisplayObject {\r\n    region?: TextureRegion;\r\n    attachment?: IAttachment;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SpineSprite extends Sprite implements ISpineDisplayObject {\r\n    region?: TextureRegion = null;\r\n    attachment?: IAttachment = null;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SpineMesh extends SimpleMesh implements ISpineDisplayObject {\r\n    region?: TextureRegion = null;\r\n    attachment?: IAttachment = null;\r\n\r\n    constructor(texture: Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\r\n        super(texture, vertices, uvs, indices, drawMode);\r\n    }\r\n}\r\n\r\n/**\r\n * A class that enables the you to import and run your spine animations in pixi.\r\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\r\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\r\n *\r\n * ```js\r\n * let spineAnimation = new spine(spineData);\r\n * ```\r\n *\r\n * @public\r\n * @class\r\n * @extends Container\r\n * @memberof spine\r\n * @param spineData {object} The spine data loaded from a spine atlas.\r\n */\r\nexport abstract class SpineBase<Skeleton extends ISkeleton,\r\n    SkeletonData extends ISkeletonData,\r\n    AnimationState extends IAnimationState,\r\n    AnimationStateData extends IAnimationStateData>\r\n    extends Container implements GlobalMixins.Spine {\r\n\r\n    tintRgb: ArrayLike<number>;\r\n    spineData: SkeletonData;\r\n    skeleton: Skeleton;\r\n    stateData: AnimationStateData;\r\n    state: AnimationState;\r\n    slotContainers: Array<Container>;\r\n    tempClipContainers: Array<Container>;\r\n    localDelayLimit: number;\r\n    private _autoUpdate: boolean;\r\n    protected _visible: boolean;\r\n\r\n    abstract createSkeleton(spineData: ISkeletonData);\r\n\r\n    constructor(spineData: SkeletonData) {\r\n        super();\r\n\r\n        if (!spineData) {\r\n            throw new Error('The spineData param is required.');\r\n        }\r\n\r\n        if ((typeof spineData) === \"string\") {\r\n            throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\r\n        }\r\n\r\n        /**\r\n         * The spineData object\r\n         *\r\n         * @member {object}\r\n         */\r\n        this.spineData = spineData;\r\n\r\n        /**\r\n         * A spine Skeleton object\r\n         *\r\n         * @member {object}\r\n         */\r\n        this.createSkeleton(spineData);\r\n\r\n        /**\r\n         * An array of containers\r\n         *\r\n         * @member {Container[]}\r\n         */\r\n        this.slotContainers = [];\r\n\r\n        this.tempClipContainers = [];\r\n\r\n        for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\r\n            let slot = this.skeleton.slots[i];\r\n            let attachment: any = slot.getAttachment();\r\n            let slotContainer = this.newContainer();\r\n            this.slotContainers.push(slotContainer);\r\n            this.addChild(slotContainer);\r\n            this.tempClipContainers.push(null);\r\n\r\n            if (!attachment) {\r\n                continue;\r\n            }\r\n            if (attachment.type === AttachmentType.Region) {\r\n                let spriteName = (attachment.region as TextureAtlasRegion).name;\r\n                let sprite = this.createSprite(slot, attachment as IRegionAttachment, spriteName);\r\n                slot.currentSprite = sprite;\r\n                slot.currentSpriteName = spriteName;\r\n                slotContainer.addChild(sprite);\r\n            } else if (attachment.type === AttachmentType.Mesh) {\r\n                let mesh = this.createMesh(slot, attachment);\r\n                slot.currentMesh = mesh;\r\n                slot.currentMeshId = attachment.id;\r\n                slot.currentMeshName = attachment.name;\r\n                slotContainer.addChild(mesh);\r\n            } else if (attachment.type === AttachmentType.Clipping) {\r\n                this.createGraphics(slot, attachment);\r\n                slotContainer.addChild(slot.clippingContainer);\r\n                slotContainer.addChild(slot.currentGraphics);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\r\n         *\r\n         * @member {number}\r\n         * @memberof spine.Spine#\r\n         */\r\n        this.tintRgb = new Float32Array([1, 1, 1]);\r\n\r\n        this.autoUpdate = true;\r\n        this.visible = true;\r\n    }\r\n\r\n    /**\r\n     * If this flag is set to true, the spine animation will be automatically updated every\r\n     * time the object id drawn. The down side of this approach is that the delta time is\r\n     * automatically calculated and you could miss out on cool effects like slow motion,\r\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\r\n     * autoUpdate enabled but are harder to achieve.\r\n     *\r\n     * @member {boolean}\r\n     * @memberof spine.Spine#\r\n     * @default true\r\n     */\r\n    get autoUpdate(): boolean {\r\n        return this._autoUpdate;\r\n    }\r\n\r\n    set autoUpdate(value: boolean) {\r\n        if (value !== this._autoUpdate) {\r\n            this._autoUpdate = value;\r\n            this.updateTransform = value ? SpineBase.prototype.autoUpdateTransform : Container.prototype.updateTransform;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\r\n     *\r\n     * @member {number}\r\n     * @memberof spine.Spine#\r\n     * @default 0xFFFFFF\r\n     */\r\n    get tint(): number {\r\n        return rgb2hex(this.tintRgb as any);\r\n    }\r\n\r\n    set tint(value: number) {\r\n        this.tintRgb = hex2rgb(value, this.tintRgb as any);\r\n    }\r\n\r\n    /**\r\n     * Limit value for the update dt with Spine.globalDelayLimit\r\n     * that can be overridden with localDelayLimit\r\n     * @return {number} - Maximum processed dt value for the update\r\n     */\r\n    get delayLimit(): number {\r\n        let limit = typeof this.localDelayLimit !== \"undefined\" ?\r\n            this.localDelayLimit : settings.GLOBAL_DELAY_LIMIT;\r\n\r\n        // If limit is 0, this means there is no limit for the delay\r\n        return limit || Number.MAX_VALUE\r\n    }\r\n\r\n    /**\r\n     * Update the spine skeleton and its animations by delta time (dt)\r\n     *\r\n     * @param dt {number} Delta time. Time by which the animation should be updated\r\n     */\r\n    update(dt: number) {\r\n        // Limit delta value to avoid animation jumps\r\n        let delayLimit = this.delayLimit;\r\n        if (dt > delayLimit) dt = delayLimit;\r\n\r\n        this.state.update(dt);\r\n        this.state.apply(this.skeleton);\r\n\r\n        //check we haven't been destroyed via a spine event callback in state update\r\n        if (!this.skeleton)\r\n            return;\r\n\r\n        this.skeleton.updateWorldTransform();\r\n\r\n        let slots = this.skeleton.slots;\r\n\r\n        // in case pixi has double tint\r\n        let globalClr = (this as any).color;\r\n        let light: ArrayLike<number> = null, dark: ArrayLike<number> = null;\r\n\r\n        if (globalClr) {\r\n            light = globalClr.light;\r\n            dark = globalClr.dark;\r\n        } else {\r\n            light = this.tintRgb;\r\n        }\r\n\r\n        // let thack = false;\r\n\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            let slot = slots[i];\r\n            let attachment = slot.getAttachment();\r\n            let slotContainer = this.slotContainers[i];\r\n\r\n            if (!attachment) {\r\n                slotContainer.visible = false;\r\n                continue;\r\n            }\r\n\r\n            let spriteColor: any = null;\r\n\r\n            let attColor = (attachment as any).color;\r\n            switch (attachment.type) {\r\n                case AttachmentType.Region:\r\n                    let region = (attachment as IRegionAttachment).region;\r\n                    if (region) {\r\n                        if (slot.currentMesh) {\r\n                            slot.currentMesh.visible = false;\r\n                            slot.currentMesh = null;\r\n                            slot.currentMeshId = undefined;\r\n                            slot.currentMeshName = undefined;\r\n                        }\r\n                        let ar = region as TextureAtlasRegion;\r\n                        if (!slot.currentSpriteName || slot.currentSpriteName !== ar.name) {\r\n                            let spriteName = ar.name;\r\n                            if (slot.currentSprite) {\r\n                                slot.currentSprite.visible = false;\r\n                            }\r\n                            slot.sprites = slot.sprites || {};\r\n                            if (slot.sprites[spriteName] !== undefined) {\r\n                                slot.sprites[spriteName].visible = true;\r\n                            } else {\r\n                                let sprite = this.createSprite(slot, attachment as IRegionAttachment, spriteName);\r\n                                slotContainer.addChild(sprite);\r\n                            }\r\n                            slot.currentSprite = slot.sprites[spriteName];\r\n                            slot.currentSpriteName = spriteName;\r\n\r\n                            // force sprite update when attachment name is same.\r\n                            // issues https://github.com/pixijs/pixi-spine/issues/318\r\n                        } else if (slot.currentSpriteName === ar.name && !slot.hackRegion) {\r\n                            this.setSpriteRegion(attachment as IRegionAttachment, slot.currentSprite, region);\r\n                        }\r\n                    }\r\n\r\n                    let transform = slotContainer.transform;\r\n                    transform.setFromMatrix(slot.bone.matrix);\r\n\r\n                    if (slot.currentSprite.color) {\r\n                        //YAY! double - tint!\r\n                        spriteColor = slot.currentSprite.color;\r\n                    } else {\r\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\r\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\r\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\r\n                        slot.currentSprite.tint = rgb2hex(tempRgb);\r\n                    }\r\n                    slot.currentSprite.blendMode = slot.blendMode;\r\n                    break;\r\n\r\n                case AttachmentType.Mesh:\r\n                    if (slot.currentSprite) {\r\n                        //TODO: refactor this thing, switch it on and off for container\r\n                        slot.currentSprite.visible = false;\r\n                        slot.currentSprite = null;\r\n                        slot.currentSpriteName = undefined;\r\n\r\n                        //TODO: refactor this shit\r\n                        const transform = new Transform();\r\n                        (transform as any)._parentID = -1;\r\n                        (transform as any)._worldID = (slotContainer.transform as any)._worldID;\r\n                        slotContainer.transform = transform;\r\n                    }\r\n                    const id = (attachment as IVertexAttachment).id;\r\n                    if (!slot.currentMeshId || slot.currentMeshId !== id) {\r\n                        let meshId = id;\r\n                        if (slot.currentMesh) {\r\n                            slot.currentMesh.visible = false;\r\n                        }\r\n\r\n                        slot.meshes = slot.meshes || {};\r\n\r\n                        if (slot.meshes[meshId] !== undefined) {\r\n                            slot.meshes[meshId].visible = true;\r\n                        } else {\r\n                            let mesh = this.createMesh(slot, attachment as IMeshAttachment);\r\n                            slotContainer.addChild(mesh);\r\n                        }\r\n\r\n                        slot.currentMesh = slot.meshes[meshId];\r\n                        slot.currentMeshName = attachment.name;\r\n                        slot.currentMeshId = meshId;\r\n                    }\r\n                    (attachment as IVertexAttachment).computeWorldVerticesOld(slot, slot.currentMesh.vertices);\r\n                    if (slot.currentMesh.color) {\r\n                        // pixi-heaven\r\n                        spriteColor = slot.currentMesh.color;\r\n                    } else {\r\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\r\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\r\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\r\n                        slot.currentMesh.tint = rgb2hex(tempRgb);\r\n                    }\r\n                    slot.currentMesh.blendMode = slot.blendMode;\r\n                    break;\r\n                case AttachmentType.Clipping:\r\n                    if (!slot.currentGraphics) {\r\n                        this.createGraphics(slot, attachment as IClippingAttachment);\r\n                        slotContainer.addChild(slot.clippingContainer);\r\n                        slotContainer.addChild(slot.currentGraphics);\r\n                    }\r\n                    this.updateGraphics(slot, attachment as IClippingAttachment);\r\n                    slotContainer.alpha = 1.0;\r\n                    slotContainer.visible = true;\r\n                    continue;\r\n                default:\r\n                    slotContainer.visible = false;\r\n                    continue;\r\n            }\r\n            slotContainer.visible = true;\r\n\r\n            // pixi has double tint\r\n            if (spriteColor) {\r\n                let r0 = slot.color.r * attColor.r;\r\n                let g0 = slot.color.g * attColor.g;\r\n                let b0 = slot.color.b * attColor.b;\r\n\r\n                //YAY! double-tint!\r\n                spriteColor.setLight(\r\n                    light[0] * r0 + dark[0] * (1.0 - r0),\r\n                    light[1] * g0 + dark[1] * (1.0 - g0),\r\n                    light[2] * b0 + dark[2] * (1.0 - b0),\r\n                );\r\n                if (slot.darkColor) {\r\n                    r0 = slot.darkColor.r;\r\n                    g0 = slot.darkColor.g;\r\n                    b0 = slot.darkColor.b;\r\n                } else {\r\n                    r0 = 0.0;\r\n                    g0 = 0.0;\r\n                    b0 = 0.0;\r\n                }\r\n                spriteColor.setDark(\r\n                    light[0] * r0 + dark[0] * (1 - r0),\r\n                    light[1] * g0 + dark[1] * (1 - g0),\r\n                    light[2] * b0 + dark[2] * (1 - b0),\r\n                );\r\n            }\r\n\r\n            slotContainer.alpha = slot.color.a;\r\n        }\r\n\r\n        //== this is clipping implementation ===\r\n        //TODO: remove parent hacks when pixi masks allow it\r\n        let drawOrder = this.skeleton.drawOrder;\r\n        let clippingAttachment: IClippingAttachment = null;\r\n        let clippingContainer: Container = null;\r\n\r\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\r\n            let slot = slots[drawOrder[i].data.index];\r\n            let slotContainer = this.slotContainers[drawOrder[i].data.index];\r\n\r\n            if (!clippingContainer) {\r\n                //Adding null check as it is possible for slotContainer.parent to be null in the event of a spine being disposed off in its loop callback\r\n                if (slotContainer.parent !== null && slotContainer.parent !== this) {\r\n                    slotContainer.parent.removeChild(slotContainer);\r\n                    //silend add hack\r\n                    (slotContainer as any).parent = this;\r\n                }\r\n            }\r\n            if (slot.currentGraphics && slot.getAttachment()) {\r\n                clippingContainer = slot.clippingContainer;\r\n                clippingAttachment = slot.getAttachment() as IClippingAttachment;\r\n                clippingContainer.children.length = 0;\r\n                this.children[i] = slotContainer;\r\n\r\n                if (clippingAttachment.endSlot === slot.data) {\r\n                    clippingAttachment.endSlot = null;\r\n                }\r\n\r\n            } else {\r\n                if (clippingContainer) {\r\n                    let c = this.tempClipContainers[i];\r\n                    if (!c) {\r\n                        c = this.tempClipContainers[i] = this.newContainer();\r\n                        c.visible = false;\r\n                    }\r\n                    this.children[i] = c;\r\n\r\n                    //silent remove hack\r\n                    (slotContainer as any).parent = null;\r\n                    clippingContainer.addChild(slotContainer);\r\n                    if (clippingAttachment.endSlot == slot.data) {\r\n                        clippingContainer.renderable = true;\r\n                        clippingContainer = null;\r\n                        clippingAttachment = null;\r\n                    }\r\n                } else {\r\n                    this.children[i] = slotContainer;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    private setSpriteRegion(attachment: IRegionAttachment, sprite: SpineSprite, region: TextureRegion) {\r\n        // prevent setters calling when attachment and region is same\r\n        if (sprite.attachment === attachment && sprite.region === region) {\r\n            return;\r\n        }\r\n\r\n        sprite.region = region;\r\n        sprite.attachment = attachment;\r\n\r\n        sprite.texture = region.texture;\r\n        sprite.rotation = attachment.rotation * MathUtils.degRad;\r\n        sprite.position.x = attachment.x;\r\n        sprite.position.y = attachment.y;\r\n        sprite.alpha = attachment.color.a;\r\n\r\n        if (!region.size) {\r\n            sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;\r\n            sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;\r\n        } else {\r\n            //hacked!\r\n            sprite.scale.x = region.size.width / region.originalWidth;\r\n            sprite.scale.y = -region.size.height / region.originalHeight;\r\n        }\r\n    }\r\n\r\n    private setMeshRegion(attachment: IMeshAttachment, mesh: SpineMesh, region: TextureRegion) {\r\n\r\n        if (mesh.attachment === attachment && mesh.region === region) {\r\n            return;\r\n        }\r\n\r\n        mesh.region = region;\r\n        mesh.attachment = attachment;\r\n        mesh.texture = region.texture;\r\n        region.texture.updateUvs();\r\n        mesh.uvBuffer.update(attachment.regionUVs);\r\n    }\r\n\r\n    protected lastTime: number;\r\n\r\n    /**\r\n     * When autoupdate is set to yes this function is used as pixi's updateTransform function\r\n     *\r\n     * @private\r\n     */\r\n    autoUpdateTransform() {\r\n        if (settings.GLOBAL_AUTO_UPDATE) {\r\n            this.lastTime = this.lastTime || Date.now();\r\n            let timeDelta = (Date.now() - this.lastTime) * 0.001;\r\n            this.lastTime = Date.now();\r\n            this.update(timeDelta);\r\n        } else {\r\n            this.lastTime = 0;\r\n        }\r\n\r\n        Container.prototype.updateTransform.call(this);\r\n    };\r\n\r\n    /**\r\n     * Create a new sprite to be used with core.RegionAttachment\r\n     *\r\n     * @param slot {spine.Slot} The slot to which the attachment is parented\r\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n     * @private\r\n     */\r\n    createSprite(slot: ISlot, attachment: IRegionAttachment, defName: string) {\r\n        let region = attachment.region;\r\n        if (slot.hackAttachment === attachment) {\r\n            region = slot.hackRegion;\r\n        }\r\n        let texture = region.texture;\r\n        let sprite = this.newSprite(texture);\r\n\r\n        sprite.anchor.set(0.5);\r\n        this.setSpriteRegion(attachment, sprite, attachment.region);\r\n\r\n        slot.sprites = slot.sprites || {};\r\n        slot.sprites[defName] = sprite;\r\n        return sprite;\r\n    };\r\n\r\n    /**\r\n     * Creates a Strip from the spine data\r\n     * @param slot {spine.Slot} The slot to which the attachment is parented\r\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n     * @private\r\n     */\r\n    createMesh(slot: ISlot, attachment: IMeshAttachment) {\r\n        let region = attachment.region;\r\n        if (slot.hackAttachment === attachment) {\r\n            region = slot.hackRegion;\r\n            slot.hackAttachment = null;\r\n            slot.hackRegion = null;\r\n        }\r\n        let strip = this.newMesh(\r\n            region.texture,\r\n            new Float32Array(attachment.regionUVs.length),\r\n            attachment.regionUVs,\r\n            new Uint16Array(attachment.triangles),\r\n            DRAW_MODES.TRIANGLES);\r\n\r\n        if (typeof (strip as any)._canvasPadding !== \"undefined\") {\r\n            (strip as any)._canvasPadding = 1.5;\r\n        }\r\n\r\n        strip.alpha = attachment.color.a;\r\n\r\n        strip.region = attachment.region;\r\n        this.setMeshRegion(attachment, strip, region);\r\n\r\n        slot.meshes = slot.meshes || {};\r\n        slot.meshes[attachment.id] = strip;\r\n        return strip;\r\n    };\r\n\r\n    static clippingPolygon: Array<number> = [];\r\n\r\n    //@ts-ignore\r\n    createGraphics(slot: ISlot, clip: IClippingAttachment) {\r\n        let graphics = this.newGraphics();\r\n        let poly = new Polygon([]);\r\n        graphics.clear();\r\n        graphics.beginFill(0xffffff, 1);\r\n        graphics.drawPolygon(poly as any);\r\n        graphics.renderable = false;\r\n        slot.currentGraphics = graphics;\r\n        slot.clippingContainer = this.newContainer();\r\n        slot.clippingContainer.mask = slot.currentGraphics;\r\n\r\n        return graphics;\r\n    }\r\n\r\n    updateGraphics(slot: ISlot, clip: IClippingAttachment) {\r\n        let geom = slot.currentGraphics.geometry;\r\n        let vertices = (geom.graphicsData[0].shape as Polygon).points;\r\n        let n = clip.worldVerticesLength;\r\n        vertices.length = n;\r\n        clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\r\n        geom.invalidate();\r\n    }\r\n\r\n    /**\r\n     * Changes texture in attachment in specific slot.\r\n     *\r\n     * PIXI runtime feature, it was made to satisfy our users.\r\n     *\r\n     * @param slotIndex {number}\r\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n     * @returns {boolean} Success flag\r\n     */\r\n    hackTextureBySlotIndex(slotIndex: number, texture: Texture = null, size: Rectangle = null) {\r\n        let slot = this.skeleton.slots[slotIndex];\r\n        if (!slot) {\r\n            return false;\r\n        }\r\n        let attachment: any = slot.getAttachment();\r\n        let region: TextureRegion = attachment.region;\r\n        if (texture) {\r\n            region = new TextureRegion();\r\n            region.texture = texture;\r\n            region.size = size;\r\n            slot.hackRegion = region;\r\n            slot.hackAttachment = attachment;\r\n        } else {\r\n            slot.hackRegion = null;\r\n            slot.hackAttachment = null;\r\n        }\r\n        if (slot.currentSprite && slot.currentSprite.region != region) {\r\n            this.setSpriteRegion(attachment, slot.currentSprite, region);\r\n            slot.currentSprite.region = region;\r\n        } else if (slot.currentMesh && slot.currentMesh.region != region) {\r\n            this.setMeshRegion(attachment, slot.currentMesh, region);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Changes texture in attachment in specific slot.\r\n     *\r\n     * PIXI runtime feature, it was made to satisfy our users.\r\n     *\r\n     * @param slotName {string}\r\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n     * @returns {boolean} Success flag\r\n     */\r\n    hackTextureBySlotName(slotName: string, texture: Texture = null, size: Rectangle = null) {\r\n        let index = this.skeleton.findSlotIndex(slotName);\r\n        if (index == -1) {\r\n            return false;\r\n        }\r\n        return this.hackTextureBySlotIndex(index, texture, size);\r\n    }\r\n\r\n    /**\r\n     * Changes texture of an attachment\r\n     *\r\n     * PIXI runtime feature, it was made to satisfy our users.\r\n     *\r\n     * @param slotName {string}\r\n     * @param attachmentName {string}\r\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n     * @returns {boolean} Success flag\r\n     */\r\n    hackTextureAttachment(slotName: string, attachmentName: string, texture, size: Rectangle = null) {\r\n        // changes the texture of an attachment at the skeleton level\r\n        const slotIndex = this.skeleton.findSlotIndex(slotName)\r\n        const attachment: any = this.skeleton.getAttachmentByName(slotName, attachmentName)\r\n        attachment.region.texture = texture\r\n\r\n        const slot = this.skeleton.slots[slotIndex]\r\n        if (!slot) {\r\n            return false\r\n        }\r\n\r\n        // gets the currently active attachment in this slot\r\n        const currentAttachment: any = slot.getAttachment()\r\n        if (attachmentName === currentAttachment.name) {\r\n            // if the attachment we are changing is currently active, change the the live texture\r\n            let region: TextureRegion = attachment.region\r\n            if (texture) {\r\n                region = new TextureRegion()\r\n                region.texture = texture\r\n                region.size = size\r\n                slot.hackRegion = region\r\n                slot.hackAttachment = currentAttachment\r\n            } else {\r\n                slot.hackRegion = null\r\n                slot.hackAttachment = null\r\n            }\r\n            if (slot.currentSprite && slot.currentSprite.region != region) {\r\n                this.setSpriteRegion(currentAttachment, slot.currentSprite, region)\r\n                slot.currentSprite.region = region\r\n            } else if (slot.currentMesh && slot.currentMesh.region != region) {\r\n                this.setMeshRegion(currentAttachment, slot.currentMesh, region)\r\n            }\r\n            return true\r\n        }\r\n        return false\r\n    }\r\n\r\n    //those methods can be overriden to spawn different classes\r\n    newContainer() {\r\n        return new Container();\r\n    }\r\n\r\n    newSprite(tex: Texture) {\r\n        return new SpineSprite(tex);\r\n    }\r\n\r\n    newGraphics() {\r\n        return new Graphics();\r\n    }\r\n\r\n    newMesh(texture: Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\r\n        return new SpineMesh(texture, vertices, uvs, indices, drawMode);\r\n    }\r\n\r\n    transformHack() {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Hack for pixi-display and pixi-lights. Every attachment name ending with a suffix will be added to different layer\r\n     * @param nameSuffix\r\n     * @param group\r\n     * @param outGroup\r\n     */\r\n    hackAttachmentGroups(nameSuffix: string, group: any, outGroup: any) {\r\n        if (!nameSuffix) {\r\n            return undefined;\r\n        }\r\n        const list_d = [], list_n = [];\r\n        for (let i = 0, len = this.skeleton.slots.length; i < len; i++) {\r\n            const slot = this.skeleton.slots[i];\r\n            const name = slot.currentSpriteName || slot.currentMeshName || \"\";\r\n            const target = slot.currentSprite || slot.currentMesh;\r\n            if (name.endsWith(nameSuffix)) {\r\n                target.parentGroup = group;\r\n                list_n.push(target);\r\n            } else if (outGroup && target) {\r\n                target.parentGroup = outGroup;\r\n                list_d.push(target);\r\n            }\r\n        }\r\n        return [list_d, list_n];\r\n    };\r\n\r\n    destroy(options?: any): void {\r\n        for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\r\n            let slot = this.skeleton.slots[i];\r\n            for (let name in slot.meshes) {\r\n                slot.meshes[name].destroy(options);\r\n            }\r\n            slot.meshes = null;\r\n\r\n            for (let name in slot.sprites) {\r\n                slot.sprites[name].destroy(options);\r\n            }\r\n            slot.sprites = null;\r\n        }\r\n\r\n        for (let i = 0, n = this.slotContainers.length; i < n; i++) {\r\n            this.slotContainers[i].destroy(options);\r\n        }\r\n        this.spineData = null;\r\n        this.skeleton = null;\r\n        this.slotContainers = null;\r\n        this.stateData = null;\r\n        this.state = null;\r\n        this.tempClipContainers = null;\r\n\r\n        super.destroy(options);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * The visibility of the spine object. If false the object will not be drawn,\r\n * the updateTransform function will not be called, and the spine will not be automatically updated.\r\n *\r\n * @member {boolean}\r\n * @memberof spine.Spine#\r\n * @default true\r\n */\r\nObject.defineProperty(SpineBase.prototype, 'visible', {\r\n    get: function () {\r\n        return this._visible;\r\n    },\r\n    set: function (value: boolean) {\r\n        if (value !== this._visible) {\r\n            this._visible = value;\r\n            if (value) {\r\n                this.lastTime = 0;\r\n            }\r\n        }\r\n    }\r\n})\r\n"]},"metadata":{},"sourceType":"module"}