{"ast":null,"code":"/* eslint-disable */\n\n/*!\n * @pixi-spine/loader-base - v3.0.5\n * Compiled Wed, 14 Jul 2021 08:35:22 UTC\n *\n * @pixi-spine/loader-base is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n * \n * Copyright 2019-2020, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved\n */\nimport { LoaderResource } from '@pixi/loaders';\nimport { BaseTexture } from '@pixi/core';\nimport { TextureAtlas } from '@pixi-spine/base';\nimport { ALPHA_MODES } from '@pixi/constants';\n\nfunction isJson(resource) {\n  return resource.type === LoaderResource.TYPE.JSON;\n}\n\nfunction isBuffer(resource) {\n  return resource.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BUFFER;\n}\n\nLoaderResource.setExtensionXhrType('skel', LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\n/**\r\n * @public\r\n */\n\nclass AbstractSpineParser {\n  genMiddleware() {\n    const self = this;\n    return {\n      use(resource, next) {\n        // skip if no data, its not json, or it isn't atlas data\n        if (!resource.data) {\n          return next();\n        }\n\n        const isJsonSpineModel = isJson(resource) && resource.data.bones;\n        const isBinarySpineModel = isBuffer(resource) && (resource.extension === 'skel' || resource.metadata && resource.metadata.spineMetadata);\n\n        if (!isJsonSpineModel && !isBinarySpineModel) {\n          return next();\n        }\n\n        let parser = null;\n        let dataToParse = resource.data;\n\n        if (isJsonSpineModel) {\n          parser = self.createJsonParser();\n        } else {\n          parser = self.createBinaryParser();\n\n          if (resource.data instanceof ArrayBuffer) {\n            dataToParse = new Uint8Array(resource.data);\n          }\n        }\n\n        const metadata = resource.metadata || {};\n        const metadataSkeletonScale = metadata ? metadata.spineSkeletonScale : null;\n\n        if (metadataSkeletonScale) {\n          parser.scale = metadataSkeletonScale;\n        }\n\n        const metadataAtlas = metadata.spineAtlas;\n\n        if (metadataAtlas === false) {\n          return next();\n        }\n\n        if (metadataAtlas && metadataAtlas.pages) {\n          self.parseData(resource, parser, metadataAtlas, dataToParse);\n          return next();\n        }\n\n        const metadataAtlasSuffix = metadata.spineAtlasSuffix || '.atlas';\n        /**\r\n         * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\r\n         * that correspond to the spine file are in the same base URL and that the .json and .atlas files\r\n         * have the same name\r\n         */\n\n        let atlasPath = resource.url;\n        let queryStringPos = atlasPath.indexOf('?');\n\n        if (queryStringPos > 0) {\n          //remove querystring\n          atlasPath = atlasPath.substr(0, queryStringPos);\n        }\n\n        atlasPath = atlasPath.substr(0, atlasPath.lastIndexOf('.')) + metadataAtlasSuffix; // use atlas path as a params. (no need to use same atlas file name with json file name)\n\n        if (metadata.spineAtlasFile) {\n          atlasPath = metadata.spineAtlasFile;\n        } //remove the baseUrl\n\n\n        atlasPath = atlasPath.replace(this.baseUrl, '');\n        const atlasOptions = {\n          crossOrigin: resource.crossOrigin,\n          xhrType: LoaderResource.XHR_RESPONSE_TYPE.TEXT,\n          metadata: metadata.spineMetadata || null,\n          parentResource: resource\n        };\n        const imageOptions = {\n          crossOrigin: resource.crossOrigin,\n          metadata: metadata.imageMetadata || null,\n          parentResource: resource\n        };\n        let baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1); //remove the baseUrl\n\n        baseUrl = baseUrl.replace(this.baseUrl, '');\n        const namePrefix = metadata.imageNamePrefix || resource.name + '_atlas_page_';\n        const adapter = metadata.images ? staticImageLoader(metadata.images) : metadata.image ? staticImageLoader({\n          'default': metadata.image\n        }) : metadata.imageLoader ? metadata.imageLoader(this, namePrefix, baseUrl, imageOptions) : imageLoaderAdapter(this, namePrefix, baseUrl, imageOptions);\n\n        function createSkeletonWithRawAtlas(rawData) {\n          new TextureAtlas(rawData, adapter, function (spineAtlas) {\n            if (spineAtlas) {\n              self.parseData(resource, parser, spineAtlas, dataToParse);\n            }\n\n            next();\n          });\n        }\n\n        if (metadata.atlasRawData) {\n          createSkeletonWithRawAtlas(metadata.atlasRawData);\n        } else {\n          this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (atlasResource) {\n            if (!atlasResource.error) {\n              createSkeletonWithRawAtlas(atlasResource.data);\n            } else {\n              next();\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n}\n/**\r\n * @public\r\n */\n\n\nfunction imageLoaderAdapter(loader, namePrefix, baseUrl, imageOptions) {\n  if (baseUrl && baseUrl.lastIndexOf('/') !== baseUrl.length - 1) {\n    baseUrl += '/';\n  }\n\n  return function (line, callback) {\n    const name = namePrefix + line;\n    const url = baseUrl + line;\n    const cachedResource = loader.resources[name];\n\n    if (cachedResource) {\n      const done = () => {\n        callback(cachedResource.texture.baseTexture);\n      };\n\n      if (cachedResource.texture) {\n        done();\n      } else {\n        cachedResource.onAfterMiddleware.add(done);\n      }\n    } else {\n      loader.add(name, url, imageOptions, resource => {\n        if (!resource.error) {\n          if (line.indexOf('-pma.') >= 0) {\n            resource.texture.baseTexture.alphaMode = ALPHA_MODES.PMA;\n          }\n\n          callback(resource.texture.baseTexture);\n        } else {\n          callback(null);\n        }\n      });\n    }\n  };\n}\n/**\r\n * @public\r\n */\n\n\nfunction syncImageLoaderAdapter(baseUrl, crossOrigin) {\n  if (baseUrl && baseUrl.lastIndexOf('/') !== baseUrl.length - 1) {\n    baseUrl += '/';\n  }\n\n  return function (line, callback) {\n    callback(BaseTexture.from(line, crossOrigin));\n  };\n}\n/**\r\n * @public\r\n */\n\n\nfunction staticImageLoader(pages) {\n  return function (line, callback) {\n    let page = pages[line] || pages['default'];\n    if (page && page.baseTexture) callback(page.baseTexture);else callback(page);\n  };\n}\n\nexport { AbstractSpineParser, imageLoaderAdapter, staticImageLoader, syncImageLoaderAdapter };","map":{"version":3,"sources":["../src/loaders.ts"],"names":[],"mappings":"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","sourcesContent":["import {ILoaderResource, IResourceMetadata, Loader, LoaderResource} from \"@pixi/loaders\";\r\nimport {BaseTexture, Texture} from \"@pixi/core\";\r\nimport {ISkeletonParser, TextureAtlas} from \"@pixi-spine/base\";\r\nimport {ALPHA_MODES} from \"@pixi/constants\";\r\n\r\nfunction isJson(resource: ILoaderResource) {\r\n    return resource.type === LoaderResource.TYPE.JSON;\r\n}\r\n\r\nfunction isBuffer(resource: ILoaderResource) {\r\n    return resource.xhrType === (LoaderResource as any).XHR_RESPONSE_TYPE.BUFFER;\r\n}\r\n\r\nLoaderResource.setExtensionXhrType('skel', LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class AbstractSpineParser {\r\n    abstract createJsonParser(): ISkeletonParser;\r\n\r\n    abstract createBinaryParser(): ISkeletonParser;\r\n\r\n    abstract parseData(resource: ILoaderResource, parser: ISkeletonParser, atlas: TextureAtlas, dataToParse: any): void;\r\n\r\n    genMiddleware() {\r\n        const self = this;\r\n\r\n        return {\r\n            use(this: Loader, resource: ILoaderResource, next: () => any) {\r\n                // skip if no data, its not json, or it isn't atlas data\r\n                if (!resource.data) {\r\n                    return next();\r\n                }\r\n\r\n                const isJsonSpineModel = isJson(resource) && resource.data.bones;\r\n                const isBinarySpineModel = isBuffer(resource) && (resource.extension === 'skel' || resource.metadata\r\n                    && (resource.metadata as any).spineMetadata);\r\n\r\n                if (!isJsonSpineModel && !isBinarySpineModel) {\r\n                    return next();\r\n                }\r\n\r\n                let parser: ISkeletonParser = null;\r\n                let dataToParse = resource.data;\r\n\r\n                if (isJsonSpineModel) {\r\n                    parser = self.createJsonParser();\r\n                } else {\r\n                    parser = self.createBinaryParser();\r\n                    if (resource.data instanceof ArrayBuffer) {\r\n                        dataToParse = new Uint8Array(resource.data);\r\n                    }\r\n                }\r\n\r\n                const metadata = (resource.metadata || {}) as IResourceMetadata;\r\n                const metadataSkeletonScale = metadata ? (metadata as any).spineSkeletonScale : null;\r\n\r\n                if (metadataSkeletonScale) {\r\n                    parser.scale = metadataSkeletonScale;\r\n                }\r\n\r\n                const metadataAtlas = metadata.spineAtlas;\r\n                if (metadataAtlas === false) {\r\n                    return next();\r\n                }\r\n                if (metadataAtlas && metadataAtlas.pages) {\r\n                    self.parseData(resource, parser, metadataAtlas, dataToParse);\r\n                    return next();\r\n                }\r\n\r\n                const metadataAtlasSuffix = metadata.spineAtlasSuffix || '.atlas';\r\n\r\n                /**\r\n                 * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\r\n                 * that correspond to the spine file are in the same base URL and that the .json and .atlas files\r\n                 * have the same name\r\n                 */\r\n                let atlasPath = resource.url;\r\n                let queryStringPos = atlasPath.indexOf('?');\r\n                if (queryStringPos > 0) {\r\n                    //remove querystring\r\n                    atlasPath = atlasPath.substr(0, queryStringPos)\r\n                }\r\n                atlasPath = atlasPath.substr(0, atlasPath.lastIndexOf('.')) + metadataAtlasSuffix;\r\n// use atlas path as a params. (no need to use same atlas file name with json file name)\r\n                if (metadata.spineAtlasFile) {\r\n                    atlasPath = metadata.spineAtlasFile;\r\n                }\r\n\r\n//remove the baseUrl\r\n                atlasPath = atlasPath.replace(this.baseUrl, '');\r\n\r\n                const atlasOptions = {\r\n                    crossOrigin: resource.crossOrigin,\r\n                    xhrType: LoaderResource.XHR_RESPONSE_TYPE.TEXT,\r\n                    metadata: metadata.spineMetadata || null,\r\n                    parentResource: resource\r\n                };\r\n                const imageOptions = {\r\n                    crossOrigin: resource.crossOrigin,\r\n                    metadata: metadata.imageMetadata || null,\r\n                    parentResource: resource\r\n                };\r\n                let baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\r\n//remove the baseUrl\r\n                baseUrl = baseUrl.replace(this.baseUrl, '');\r\n\r\n                const namePrefix = metadata.imageNamePrefix || (resource.name + '_atlas_page_');\r\n\r\n                const adapter = metadata.images ? staticImageLoader(metadata.images)\r\n                    : metadata.image ? staticImageLoader({'default': metadata.image})\r\n                        : metadata.imageLoader ? metadata.imageLoader(this, namePrefix, baseUrl, imageOptions)\r\n                            : imageLoaderAdapter(this, namePrefix, baseUrl, imageOptions);\r\n\r\n                function createSkeletonWithRawAtlas(rawData: string) {\r\n                    new TextureAtlas(rawData, adapter, function(spineAtlas) {\r\n                        if (spineAtlas) {\r\n                            self.parseData(resource, parser, spineAtlas, dataToParse);\r\n                        }\r\n                        next();\r\n                    });\r\n                }\r\n\r\n                if (metadata.atlasRawData) {\r\n                    createSkeletonWithRawAtlas(metadata.atlasRawData)\r\n                } else {\r\n                    this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (atlasResource: any) {\r\n                        if (!atlasResource.error) {\r\n                            createSkeletonWithRawAtlas(atlasResource.data);\r\n                        } else {\r\n                            next();\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport function imageLoaderAdapter(loader: any, namePrefix: any, baseUrl: any, imageOptions: any) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {\r\n        baseUrl += '/';\r\n    }\r\n    return function (line: string, callback: (baseTexture: BaseTexture) => any) {\r\n        const name = namePrefix + line;\r\n        const url = baseUrl + line;\r\n\r\n        const cachedResource = loader.resources[name];\r\n        if (cachedResource) {\r\n            const done = () => {\r\n                callback(cachedResource.texture.baseTexture)\r\n            }\r\n            if (cachedResource.texture) {\r\n                done();\r\n            } else {\r\n                cachedResource.onAfterMiddleware.add(done);\r\n            }\r\n        } else {\r\n            loader.add(name, url, imageOptions, (resource: ILoaderResource) => {\r\n                if (!resource.error) {\r\n                    if (line.indexOf('-pma.') >= 0) {\r\n                        resource.texture.baseTexture.alphaMode = ALPHA_MODES.PMA;\r\n                    }\r\n\r\n                    callback(resource.texture.baseTexture);\r\n                } else {\r\n                    callback(null);\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport function syncImageLoaderAdapter(baseUrl: any, crossOrigin: any) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {\r\n        baseUrl += '/';\r\n    }\r\n    return function (line: any, callback: any) {\r\n        callback(BaseTexture.from(line, crossOrigin));\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport function staticImageLoader(pages: { [key: string]: (BaseTexture | Texture) }) {\r\n    return function (line: any, callback: any) {\r\n        let page = pages[line] || pages['default'] as any;\r\n        if (page && page.baseTexture)\r\n            callback(page.baseTexture);\r\n        else\r\n            callback(page);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}