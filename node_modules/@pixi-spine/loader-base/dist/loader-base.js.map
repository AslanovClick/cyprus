{"version":3,"file":"loader-base.js","sources":["../src/loaders.ts","../src/index.ts"],"sourcesContent":["import {ILoaderResource, IResourceMetadata, Loader, LoaderResource} from \"@pixi/loaders\";\r\nimport {BaseTexture, Texture} from \"@pixi/core\";\r\nimport {ISkeletonParser, TextureAtlas} from \"@pixi-spine/base\";\r\nimport {ALPHA_MODES} from \"@pixi/constants\";\r\n\r\nfunction isJson(resource: ILoaderResource) {\r\n    return resource.type === LoaderResource.TYPE.JSON;\r\n}\r\n\r\nfunction isBuffer(resource: ILoaderResource) {\r\n    return resource.xhrType === (LoaderResource as any).XHR_RESPONSE_TYPE.BUFFER;\r\n}\r\n\r\nLoaderResource.setExtensionXhrType('skel', LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class AbstractSpineParser {\r\n    abstract createJsonParser(): ISkeletonParser;\r\n\r\n    abstract createBinaryParser(): ISkeletonParser;\r\n\r\n    abstract parseData(resource: ILoaderResource, parser: ISkeletonParser, atlas: TextureAtlas, dataToParse: any): void;\r\n\r\n    genMiddleware() {\r\n        const self = this;\r\n\r\n        return {\r\n            use(this: Loader, resource: ILoaderResource, next: () => any) {\r\n                // skip if no data, its not json, or it isn't atlas data\r\n                if (!resource.data) {\r\n                    return next();\r\n                }\r\n\r\n                const isJsonSpineModel = isJson(resource) && resource.data.bones;\r\n                const isBinarySpineModel = isBuffer(resource) && (resource.extension === 'skel' || resource.metadata\r\n                    && (resource.metadata as any).spineMetadata);\r\n\r\n                if (!isJsonSpineModel && !isBinarySpineModel) {\r\n                    return next();\r\n                }\r\n\r\n                let parser: ISkeletonParser = null;\r\n                let dataToParse = resource.data;\r\n\r\n                if (isJsonSpineModel) {\r\n                    parser = self.createJsonParser();\r\n                } else {\r\n                    parser = self.createBinaryParser();\r\n                    if (resource.data instanceof ArrayBuffer) {\r\n                        dataToParse = new Uint8Array(resource.data);\r\n                    }\r\n                }\r\n\r\n                const metadata = (resource.metadata || {}) as IResourceMetadata;\r\n                const metadataSkeletonScale = metadata ? (metadata as any).spineSkeletonScale : null;\r\n\r\n                if (metadataSkeletonScale) {\r\n                    parser.scale = metadataSkeletonScale;\r\n                }\r\n\r\n                const metadataAtlas = metadata.spineAtlas;\r\n                if (metadataAtlas === false) {\r\n                    return next();\r\n                }\r\n                if (metadataAtlas && metadataAtlas.pages) {\r\n                    self.parseData(resource, parser, metadataAtlas, dataToParse);\r\n                    return next();\r\n                }\r\n\r\n                const metadataAtlasSuffix = metadata.spineAtlasSuffix || '.atlas';\r\n\r\n                /**\r\n                 * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\r\n                 * that correspond to the spine file are in the same base URL and that the .json and .atlas files\r\n                 * have the same name\r\n                 */\r\n                let atlasPath = resource.url;\r\n                let queryStringPos = atlasPath.indexOf('?');\r\n                if (queryStringPos > 0) {\r\n                    //remove querystring\r\n                    atlasPath = atlasPath.substr(0, queryStringPos)\r\n                }\r\n                atlasPath = atlasPath.substr(0, atlasPath.lastIndexOf('.')) + metadataAtlasSuffix;\r\n// use atlas path as a params. (no need to use same atlas file name with json file name)\r\n                if (metadata.spineAtlasFile) {\r\n                    atlasPath = metadata.spineAtlasFile;\r\n                }\r\n\r\n//remove the baseUrl\r\n                atlasPath = atlasPath.replace(this.baseUrl, '');\r\n\r\n                const atlasOptions = {\r\n                    crossOrigin: resource.crossOrigin,\r\n                    xhrType: LoaderResource.XHR_RESPONSE_TYPE.TEXT,\r\n                    metadata: metadata.spineMetadata || null,\r\n                    parentResource: resource\r\n                };\r\n                const imageOptions = {\r\n                    crossOrigin: resource.crossOrigin,\r\n                    metadata: metadata.imageMetadata || null,\r\n                    parentResource: resource\r\n                };\r\n                let baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\r\n//remove the baseUrl\r\n                baseUrl = baseUrl.replace(this.baseUrl, '');\r\n\r\n                const namePrefix = metadata.imageNamePrefix || (resource.name + '_atlas_page_');\r\n\r\n                const adapter = metadata.images ? staticImageLoader(metadata.images)\r\n                    : metadata.image ? staticImageLoader({'default': metadata.image})\r\n                        : metadata.imageLoader ? metadata.imageLoader(this, namePrefix, baseUrl, imageOptions)\r\n                            : imageLoaderAdapter(this, namePrefix, baseUrl, imageOptions);\r\n\r\n                function createSkeletonWithRawAtlas(rawData: string) {\r\n                    new TextureAtlas(rawData, adapter, function(spineAtlas) {\r\n                        if (spineAtlas) {\r\n                            self.parseData(resource, parser, spineAtlas, dataToParse);\r\n                        }\r\n                        next();\r\n                    });\r\n                }\r\n\r\n                if (metadata.atlasRawData) {\r\n                    createSkeletonWithRawAtlas(metadata.atlasRawData)\r\n                } else {\r\n                    this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (atlasResource: any) {\r\n                        if (!atlasResource.error) {\r\n                            createSkeletonWithRawAtlas(atlasResource.data);\r\n                        } else {\r\n                            next();\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport function imageLoaderAdapter(loader: any, namePrefix: any, baseUrl: any, imageOptions: any) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {\r\n        baseUrl += '/';\r\n    }\r\n    return function (line: string, callback: (baseTexture: BaseTexture) => any) {\r\n        const name = namePrefix + line;\r\n        const url = baseUrl + line;\r\n\r\n        const cachedResource = loader.resources[name];\r\n        if (cachedResource) {\r\n            const done = () => {\r\n                callback(cachedResource.texture.baseTexture)\r\n            }\r\n            if (cachedResource.texture) {\r\n                done();\r\n            } else {\r\n                cachedResource.onAfterMiddleware.add(done);\r\n            }\r\n        } else {\r\n            loader.add(name, url, imageOptions, (resource: ILoaderResource) => {\r\n                if (!resource.error) {\r\n                    if (line.indexOf('-pma.') >= 0) {\r\n                        resource.texture.baseTexture.alphaMode = ALPHA_MODES.PMA;\r\n                    }\r\n\r\n                    callback(resource.texture.baseTexture);\r\n                } else {\r\n                    callback(null);\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport function syncImageLoaderAdapter(baseUrl: any, crossOrigin: any) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {\r\n        baseUrl += '/';\r\n    }\r\n    return function (line: any, callback: any) {\r\n        callback(BaseTexture.from(line, crossOrigin));\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport function staticImageLoader(pages: { [key: string]: (BaseTexture | Texture) }) {\r\n    return function (line: any, callback: any) {\r\n        let page = pages[line] || pages['default'] as any;\r\n        if (page && page.baseTexture)\r\n            callback(page.baseTexture);\r\n        else\r\n            callback(page);\r\n    }\r\n}\r\n","/// <reference path=\"../global.d.ts\" />\r\nexport * from './loaders';\r\n"],"names":["LoaderResource"],"mappings":";;;;;;;;;;;;;;;;;;;IAKA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;AACAA;AACA;IACA;IACA;IACA;;IAEA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;ICxMA;;;;;;;;;;;;;;;;"}