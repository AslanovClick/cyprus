/* eslint-disable */
 
/*!
 * @pixi-spine/loader-base - v3.0.5
 * Compiled Wed, 14 Jul 2021 08:35:22 UTC
 *
 * @pixi-spine/loader-base is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2019-2020, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */
import { LoaderResource } from '@pixi/loaders';
import { BaseTexture } from '@pixi/core';
import { TextureAtlas } from '@pixi-spine/base';
import { ALPHA_MODES } from '@pixi/constants';

function isJson(resource) {
    return resource.type === LoaderResource.TYPE.JSON;
}

function isBuffer(resource) {
    return resource.xhrType === (LoaderResource ).XHR_RESPONSE_TYPE.BUFFER;
}

LoaderResource.setExtensionXhrType('skel', LoaderResource.XHR_RESPONSE_TYPE.BUFFER);

/**
 * @public
 */
class AbstractSpineParser {
    





    genMiddleware() {
        const self = this;

        return {
            use( resource, next) {
                // skip if no data, its not json, or it isn't atlas data
                if (!resource.data) {
                    return next();
                }

                const isJsonSpineModel = isJson(resource) && resource.data.bones;
                const isBinarySpineModel = isBuffer(resource) && (resource.extension === 'skel' || resource.metadata
                    && (resource.metadata ).spineMetadata);

                if (!isJsonSpineModel && !isBinarySpineModel) {
                    return next();
                }

                let parser = null;
                let dataToParse = resource.data;

                if (isJsonSpineModel) {
                    parser = self.createJsonParser();
                } else {
                    parser = self.createBinaryParser();
                    if (resource.data instanceof ArrayBuffer) {
                        dataToParse = new Uint8Array(resource.data);
                    }
                }

                const metadata = (resource.metadata || {}) ;
                const metadataSkeletonScale = metadata ? (metadata ).spineSkeletonScale : null;

                if (metadataSkeletonScale) {
                    parser.scale = metadataSkeletonScale;
                }

                const metadataAtlas = metadata.spineAtlas;
                if (metadataAtlas === false) {
                    return next();
                }
                if (metadataAtlas && metadataAtlas.pages) {
                    self.parseData(resource, parser, metadataAtlas, dataToParse);
                    return next();
                }

                const metadataAtlasSuffix = metadata.spineAtlasSuffix || '.atlas';

                /**
                 * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files
                 * that correspond to the spine file are in the same base URL and that the .json and .atlas files
                 * have the same name
                 */
                let atlasPath = resource.url;
                let queryStringPos = atlasPath.indexOf('?');
                if (queryStringPos > 0) {
                    //remove querystring
                    atlasPath = atlasPath.substr(0, queryStringPos);
                }
                atlasPath = atlasPath.substr(0, atlasPath.lastIndexOf('.')) + metadataAtlasSuffix;
// use atlas path as a params. (no need to use same atlas file name with json file name)
                if (metadata.spineAtlasFile) {
                    atlasPath = metadata.spineAtlasFile;
                }

//remove the baseUrl
                atlasPath = atlasPath.replace(this.baseUrl, '');

                const atlasOptions = {
                    crossOrigin: resource.crossOrigin,
                    xhrType: LoaderResource.XHR_RESPONSE_TYPE.TEXT,
                    metadata: metadata.spineMetadata || null,
                    parentResource: resource
                };
                const imageOptions = {
                    crossOrigin: resource.crossOrigin,
                    metadata: metadata.imageMetadata || null,
                    parentResource: resource
                };
                let baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);
//remove the baseUrl
                baseUrl = baseUrl.replace(this.baseUrl, '');

                const namePrefix = metadata.imageNamePrefix || (resource.name + '_atlas_page_');

                const adapter = metadata.images ? staticImageLoader(metadata.images)
                    : metadata.image ? staticImageLoader({'default': metadata.image})
                        : metadata.imageLoader ? metadata.imageLoader(this, namePrefix, baseUrl, imageOptions)
                            : imageLoaderAdapter(this, namePrefix, baseUrl, imageOptions);

                function createSkeletonWithRawAtlas(rawData) {
                    new TextureAtlas(rawData, adapter, function(spineAtlas) {
                        if (spineAtlas) {
                            self.parseData(resource, parser, spineAtlas, dataToParse);
                        }
                        next();
                    });
                }

                if (metadata.atlasRawData) {
                    createSkeletonWithRawAtlas(metadata.atlasRawData);
                } else {
                    this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (atlasResource) {
                        if (!atlasResource.error) {
                            createSkeletonWithRawAtlas(atlasResource.data);
                        } else {
                            next();
                        }
                    });
                }
            }
        }
    }
}

/**
 * @public
 */
function imageLoaderAdapter(loader, namePrefix, baseUrl, imageOptions) {
    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {
        baseUrl += '/';
    }
    return function (line, callback) {
        const name = namePrefix + line;
        const url = baseUrl + line;

        const cachedResource = loader.resources[name];
        if (cachedResource) {
            const done = () => {
                callback(cachedResource.texture.baseTexture);
            };
            if (cachedResource.texture) {
                done();
            } else {
                cachedResource.onAfterMiddleware.add(done);
            }
        } else {
            loader.add(name, url, imageOptions, (resource) => {
                if (!resource.error) {
                    if (line.indexOf('-pma.') >= 0) {
                        resource.texture.baseTexture.alphaMode = ALPHA_MODES.PMA;
                    }

                    callback(resource.texture.baseTexture);
                } else {
                    callback(null);
                }
            });
        }
    }
}

/**
 * @public
 */
function syncImageLoaderAdapter(baseUrl, crossOrigin) {
    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {
        baseUrl += '/';
    }
    return function (line, callback) {
        callback(BaseTexture.from(line, crossOrigin));
    }
}

/**
 * @public
 */
function staticImageLoader(pages) {
    return function (line, callback) {
        let page = pages[line] || pages['default'] ;
        if (page && page.baseTexture)
            callback(page.baseTexture);
        else
            callback(page);
    }
}

export { AbstractSpineParser, imageLoaderAdapter, staticImageLoader, syncImageLoaderAdapter };
//# sourceMappingURL=loader-base.es.js.map
