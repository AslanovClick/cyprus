{"version":3,"file":"base.js","sources":["../src/core/AttachmentType.ts","../src/core/BinaryInput.ts","../src/core/TextureRegion.ts","../src/core/TextureAtlas.ts","../src/core/Utils.ts","../src/settings.ts","../src/SpineBase.ts"],"sourcesContent":["\r\n/**\r\n * @public\r\n */\r\nexport enum AttachmentType {\r\n    Region, BoundingBox, Mesh, LinkedMesh, Path, Point, Clipping\r\n}\r\n","/**\r\n * @public\r\n */\r\nexport class BinaryInput {\r\n    constructor(data: Uint8Array, public strings = new Array<string>(), private index: number = 0, private buffer = new DataView(data.buffer)) {\r\n\r\n    }\r\n\r\n    readByte(): number {\r\n        return this.buffer.getInt8(this.index++);\r\n    }\r\n\r\n    readUnsignedByte(): number {\r\n        return this.buffer.getUint8(this.index++);\r\n    }\r\n\r\n    readShort(): number {\r\n        let value = this.buffer.getInt16(this.index);\r\n        this.index += 2;\r\n        return value;\r\n    }\r\n\r\n    readInt32(): number {\r\n        let value = this.buffer.getInt32(this.index)\r\n        this.index += 4;\r\n        return value;\r\n    }\r\n\r\n    readInt(optimizePositive: boolean) {\r\n        let b = this.readByte();\r\n        let result = b & 0x7F;\r\n        if ((b & 0x80) != 0) {\r\n            b = this.readByte();\r\n            result |= (b & 0x7F) << 7;\r\n            if ((b & 0x80) != 0) {\r\n                b = this.readByte();\r\n                result |= (b & 0x7F) << 14;\r\n                if ((b & 0x80) != 0) {\r\n                    b = this.readByte();\r\n                    result |= (b & 0x7F) << 21;\r\n                    if ((b & 0x80) != 0) {\r\n                        b = this.readByte();\r\n                        result |= (b & 0x7F) << 28;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return optimizePositive ? result : ((result >>> 1) ^ -(result & 1));\r\n    }\r\n\r\n    readStringRef (): string {\r\n        let index = this.readInt(true);\r\n        return index == 0 ? null : this.strings[index - 1];\r\n    }\r\n\r\n    readString (): string {\r\n        let byteCount = this.readInt(true);\r\n        switch (byteCount) {\r\n            case 0:\r\n                return null;\r\n            case 1:\r\n                return \"\";\r\n        }\r\n        byteCount--;\r\n        let chars = \"\";\r\n        for (let i = 0; i < byteCount;) {\r\n            let b = this.readByte();\r\n            switch (b >> 4) {\r\n                case 12:\r\n                case 13:\r\n                    chars += String.fromCharCode(((b & 0x1F) << 6 | this.readByte() & 0x3F));\r\n                    i += 2;\r\n                    break;\r\n                case 14:\r\n                    chars += String.fromCharCode(((b & 0x0F) << 12 | (this.readByte() & 0x3F) << 6 | this.readByte() & 0x3F));\r\n                    i += 3;\r\n                    break;\r\n                default:\r\n                    chars += String.fromCharCode(b);\r\n                    i++;\r\n            }\r\n        }\r\n        return chars;\r\n    }\r\n\r\n    readFloat (): number {\r\n        let value = this.buffer.getFloat32(this.index);\r\n        this.index += 4;\r\n        return value;\r\n    }\r\n\r\n    readBoolean (): boolean {\r\n        return this.readByte() != 0;\r\n    }\r\n}\r\n","\r\nimport { Texture } from '@pixi/core';\r\nimport { Rectangle } from '@pixi/math';\r\n\r\n/**\r\n * @public\r\n */\r\nexport function filterFromString (text: string): TextureFilter {\r\n    switch (text.toLowerCase()) {\r\n        case \"nearest\": return TextureFilter.Nearest;\r\n        case \"linear\": return TextureFilter.Linear;\r\n        case \"mipmap\": return TextureFilter.MipMap;\r\n        case \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\r\n        case \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\r\n        case \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\r\n        case \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\r\n        default: throw new Error(`Unknown texture filter ${text}`);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport function wrapFromString (text: string): TextureWrap {\r\n    switch (text.toLowerCase()) {\r\n        case \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\r\n        case \"clamptoedge\": return TextureWrap.ClampToEdge;\r\n        case \"repeat\": return TextureWrap.Repeat;\r\n        default: throw new Error(`Unknown texture wrap ${text}`);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum TextureFilter {\r\n    Nearest = 9728, // WebGLRenderingContext.NEAREST\r\n    Linear = 9729, // WebGLRenderingContext.LINEAR\r\n    MipMap = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\r\n    MipMapNearestNearest = 9984, // WebGLRenderingContext.NEAREST_MIPMAP_NEAREST\r\n    MipMapLinearNearest = 9985, // WebGLRenderingContext.LINEAR_MIPMAP_NEAREST\r\n    MipMapNearestLinear = 9986, // WebGLRenderingContext.NEAREST_MIPMAP_LINEAR\r\n    MipMapLinearLinear = 9987 // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum TextureWrap {\r\n    MirroredRepeat = 33648, // WebGLRenderingContext.MIRRORED_REPEAT\r\n    ClampToEdge = 33071, // WebGLRenderingContext.CLAMP_TO_EDGE\r\n    Repeat = 10497 // WebGLRenderingContext.REPEAT\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TextureRegion {\r\n    texture: Texture;\r\n\r\n    //thats for overrides\r\n    size: Rectangle = null;\r\n\r\n    names: string[] = null;\r\n    values: number[][] = null;\r\n\r\n    get width(): number {\r\n        const tex = this.texture;\r\n        if (tex.trim) {\r\n            return tex.trim.width;\r\n        }\r\n        return tex.orig.width;\r\n    }\r\n\r\n    get height(): number {\r\n        const tex = this.texture;\r\n        if (tex.trim) {\r\n            return tex.trim.height;\r\n        }\r\n        return tex.orig.height;\r\n    }\r\n\r\n    get u(): number {\r\n        return (this.texture as any)._uvs.x0;\r\n    }\r\n\r\n    get v(): number {\r\n        return (this.texture as any)._uvs.y0;\r\n    }\r\n\r\n    get u2(): number {\r\n        return (this.texture as any)._uvs.x2;\r\n    }\r\n\r\n    get v2(): number {\r\n        return (this.texture as any)._uvs.y2;\r\n    }\r\n\r\n    get offsetX(): number {\r\n        const tex = this.texture;\r\n        return tex.trim ? tex.trim.x : 0;\r\n    }\r\n\r\n    get offsetY(): number {\r\n        // console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\r\n        return this.spineOffsetY;\r\n    }\r\n\r\n    get pixiOffsetY(): number {\r\n        const tex = this.texture;\r\n        return tex.trim ? tex.trim.y : 0;\r\n    }\r\n\r\n    get spineOffsetY(): number {\r\n        let tex = this.texture;\r\n        return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\r\n    }\r\n\r\n    get originalWidth(): number {\r\n        return this.texture.orig.width;\r\n    }\r\n\r\n    get originalHeight(): number {\r\n        return this.texture.orig.height;\r\n    }\r\n\r\n    get x(): number {\r\n        return this.texture.frame.x;\r\n    }\r\n\r\n    get y(): number {\r\n        return this.texture.frame.y;\r\n    }\r\n\r\n    get rotate(): boolean {\r\n        return this.texture.rotate !== 0;\r\n    }\r\n\r\n    get degrees() {\r\n        return (360 - this.texture.rotate * 45) % 360;\r\n    }\r\n}\r\n","import {SCALE_MODES, MIPMAP_MODES, ALPHA_MODES} from '@pixi/constants';\r\nimport {Texture} from '@pixi/core';\r\nimport {Rectangle} from '@pixi/math';\r\nimport {TextureRegion, TextureWrap, TextureFilter, filterFromString} from './TextureRegion';\r\nimport {Map, Disposable} from './Utils';\r\n\r\nimport type {BaseTexture} from '@pixi/core';\r\n\r\nclass RegionFields {\r\n    x = 0;\r\n    y = 0;\r\n    width = 0;\r\n    height = 0;\r\n    offsetX = 0;\r\n    offsetY = 0;\r\n    originalWidth = 0;\r\n    originalHeight = 0;\r\n    rotate = 0;\r\n    index = 0;\r\n}\r\n/**\r\n * @public\r\n */\r\nexport class TextureAtlas implements Disposable {\r\n    pages = new Array<TextureAtlasPage>();\r\n    regions = new Array<TextureAtlasRegion>();\r\n\r\n    constructor(atlasText?: string, textureLoader?: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback?: (obj: TextureAtlas) => any) {\r\n        if (atlasText) {\r\n            this.addSpineAtlas(atlasText, textureLoader, callback);\r\n        }\r\n    }\r\n\r\n    addTexture(name: string, texture: Texture) {\r\n        let pages = this.pages;\r\n        let page: TextureAtlasPage = null;\r\n        for (let i = 0; i < pages.length; i++) {\r\n            if (pages[i].baseTexture === texture.baseTexture) {\r\n                page = pages[i];\r\n                break;\r\n            }\r\n        }\r\n        if (page === null) {\r\n            page = new TextureAtlasPage();\r\n            page.name = 'texturePage';\r\n            let baseTexture = texture.baseTexture;\r\n            page.width = baseTexture.realWidth;\r\n            page.height = baseTexture.realHeight;\r\n            page.baseTexture = baseTexture;\r\n            //those fields are not relevant in Pixi\r\n            page.minFilter = page.magFilter = TextureFilter.Nearest;\r\n            page.uWrap = TextureWrap.ClampToEdge;\r\n            page.vWrap = TextureWrap.ClampToEdge;\r\n            pages.push(page);\r\n        }\r\n        let region = new TextureAtlasRegion();\r\n        region.name = name;\r\n        region.page = page;\r\n        region.texture = texture;\r\n        region.index = -1;\r\n        this.regions.push(region);\r\n        return region;\r\n    }\r\n\r\n    addTextureHash(textures: Map<Texture>, stripExtension: boolean) {\r\n        for (let key in textures) {\r\n            if (textures.hasOwnProperty(key)) {\r\n                this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\r\n            }\r\n        }\r\n    }\r\n\r\n    public addSpineAtlas(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\r\n        return this.load(atlasText, textureLoader, callback);\r\n    }\r\n\r\n    private load(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\r\n        if (textureLoader == null)\r\n            throw new Error(\"textureLoader cannot be null.\");\r\n\r\n        let reader = new TextureAtlasReader(atlasText);\r\n        let entry = new Array<string>(4);\r\n        let page: TextureAtlasPage = null;\r\n        let pageFields: Map<Function> = {};\r\n        let region: RegionFields = null;\r\n        pageFields[\"size\"] = () => {\r\n            page.width = parseInt(entry[1]);\r\n            page.height = parseInt(entry[2]);\r\n        };\r\n        pageFields[\"format\"] = () => {\r\n            // page.format = Format[tuple[0]]; we don't need format in WebGL\r\n        };\r\n        pageFields[\"filter\"] = () => {\r\n            page.minFilter = filterFromString(entry[1]);\r\n            page.magFilter = filterFromString(entry[2]);\r\n        };\r\n        pageFields[\"repeat\"] = () => {\r\n            if (entry[1].indexOf('x') != -1) page.uWrap = TextureWrap.Repeat;\r\n            if (entry[1].indexOf('y') != -1) page.vWrap = TextureWrap.Repeat;\r\n        };\r\n        pageFields[\"pma\"] = () => {\r\n            page.pma = entry[1] == \"true\";\r\n        };\r\n\r\n        let regionFields: Map<Function> = {};\r\n        regionFields[\"xy\"] = () => { // Deprecated, use bounds.\r\n            region.x = parseInt(entry[1]);\r\n            region.y = parseInt(entry[2]);\r\n        };\r\n        regionFields[\"size\"] = () => { // Deprecated, use bounds.\r\n            region.width = parseInt(entry[1]);\r\n            region.height = parseInt(entry[2]);\r\n        };\r\n        regionFields[\"bounds\"] = () => {\r\n            region.x = parseInt(entry[1]);\r\n            region.y = parseInt(entry[2]);\r\n            region.width = parseInt(entry[3]);\r\n            region.height = parseInt(entry[4]);\r\n        };\r\n        regionFields[\"offset\"] = () => { // Deprecated, use offsets.\r\n            region.offsetX = parseInt(entry[1]);\r\n            region.offsetY = parseInt(entry[2]);\r\n        };\r\n        regionFields[\"orig\"] = () => { // Deprecated, use offsets.\r\n            region.originalWidth = parseInt(entry[1]);\r\n            region.originalHeight = parseInt(entry[2]);\r\n        };\r\n        regionFields[\"offsets\"] = () => {\r\n            region.offsetX = parseInt(entry[1]);\r\n            region.offsetY = parseInt(entry[2]);\r\n            region.originalWidth = parseInt(entry[3]);\r\n            region.originalHeight = parseInt(entry[4]);\r\n        };\r\n        regionFields[\"rotate\"] = () => {\r\n            let rotateValue = entry[1];\r\n            let rotate = 0;\r\n            if (rotateValue.toLocaleLowerCase() == \"true\") {\r\n                rotate = 6;\r\n            } else if (rotateValue.toLocaleLowerCase() == \"false\") {\r\n                rotate = 0;\r\n            } else {\r\n                rotate = ((720 - parseFloat(rotateValue)) % 360) / 45;\r\n            }\r\n            region.rotate = rotate;\r\n        };\r\n        regionFields[\"index\"] = () => {\r\n            region.index = parseInt(entry[1]);\r\n        };\r\n\r\n        let line = reader.readLine();\r\n        // Ignore empty lines before first entry.\r\n        while (line != null && line.trim().length == 0)\r\n            line = reader.readLine();\r\n        // Header entries.\r\n        while (true) {\r\n            if (line == null || line.trim().length == 0) break;\r\n            if (reader.readEntry(entry, line) == 0) break; // Silently ignore all header fields.\r\n            line = reader.readLine();\r\n        }\r\n\r\n        let iterateParser = () => {\r\n            while (true) {\r\n                if (line == null) {\r\n                    return callback && callback(this);\r\n                }\r\n                if (line.trim().length == 0) {\r\n                    page = null;\r\n                    line = reader.readLine();\r\n                } else if (page === null) {\r\n                    page = new TextureAtlasPage();\r\n                    page.name = line.trim();\r\n\r\n                    while (true) {\r\n                        if (reader.readEntry(entry, line = reader.readLine()) == 0) break;\r\n                        let field: Function = pageFields[entry[0]];\r\n                        if (field) field();\r\n                    }\r\n                    this.pages.push(page);\r\n\r\n                    textureLoader(page.name, (texture: BaseTexture) => {\r\n                        if (texture === null) {\r\n                            this.pages.splice(this.pages.indexOf(page), 1);\r\n                            return callback && callback(null);\r\n                        }\r\n                        page.baseTexture = texture;\r\n                        //TODO: set scaleMode and mipmapMode from spine\r\n                        if (page.pma) {\r\n                            texture.alphaMode = ALPHA_MODES.PMA;\r\n                        }\r\n                        if (!texture.valid) {\r\n                            texture.setSize(page.width, page.height);\r\n                        }\r\n                        this.pages.push(page);\r\n                        page.setFilters();\r\n\r\n                        if (!page.width || !page.height) {\r\n                            page.width = texture.realWidth;\r\n                            page.height = texture.realHeight;\r\n                            if (!page.width || !page.height) {\r\n                                console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\r\n                            }\r\n                        }\r\n                        iterateParser();\r\n                    });\r\n                    this.pages.push(page);\r\n                    break;\r\n                } else {\r\n                    region = new RegionFields();\r\n                    let atlasRegion = new TextureAtlasRegion();\r\n                    atlasRegion.name = line;\r\n                    atlasRegion.page = page;\r\n                    let names: string[] = null;\r\n                    let values: number[][] = null;\r\n                    while (true) {\r\n                        let count = reader.readEntry(entry, line = reader.readLine());\r\n                        if (count == 0) break;\r\n                        let field: Function = regionFields[entry[0]];\r\n                        if (field)\r\n                            field();\r\n                        else {\r\n                            if (names == null) {\r\n                                names = [];\r\n                                values = []\r\n                            }\r\n                            names.push(entry[0]);\r\n                            let entryValues: number[] = [];\r\n                            for (let i = 0; i < count; i++)\r\n                                entryValues.push(parseInt(entry[i + 1]));\r\n                            values.push(entryValues);\r\n                        }\r\n                    }\r\n                    if (region.originalWidth == 0 && region.originalHeight == 0) {\r\n                        region.originalWidth = region.width;\r\n                        region.originalHeight = region.height;\r\n                    }\r\n\r\n                    let resolution = page.baseTexture.resolution;\r\n                    region.x /= resolution;\r\n                    region.y /= resolution;\r\n                    region.width /= resolution;\r\n                    region.height /= resolution;\r\n                    region.originalWidth /= resolution;\r\n                    region.originalHeight /= resolution;\r\n                    region.offsetX /= resolution;\r\n                    region.offsetY /= resolution;\r\n\r\n                    const swapWH = region.rotate % 4 !== 0;\r\n                    let frame = new Rectangle(region.x, region.y, swapWH ? region.height : region.width, swapWH ? region.width : region.height);\r\n\r\n                    let orig = new Rectangle(0, 0, region.originalWidth, region.originalHeight);\r\n                    let trim = new Rectangle(region.offsetX, region.originalHeight - region.height - region.offsetY, region.width, region.height);\r\n\r\n                    atlasRegion.texture = new Texture(atlasRegion.page.baseTexture, frame, orig, trim, region.rotate);\r\n                    atlasRegion.index = region.index;\r\n                    atlasRegion.texture.updateUvs();\r\n\r\n                    this.regions.push(atlasRegion);\r\n                }\r\n            }\r\n        };\r\n\r\n        iterateParser();\r\n    }\r\n\r\n    findRegion(name: string): TextureAtlasRegion {\r\n        for (let i = 0; i < this.regions.length; i++) {\r\n            if (this.regions[i].name == name) {\r\n                return this.regions[i];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    dispose() {\r\n        for (let i = 0; i < this.pages.length; i++) {\r\n            this.pages[i].baseTexture.dispose();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nclass TextureAtlasReader {\r\n    lines: Array<string>;\r\n    index: number = 0;\r\n\r\n    constructor(text: string) {\r\n        this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n    }\r\n\r\n    readLine(): string {\r\n        if (this.index >= this.lines.length)\r\n            return null;\r\n        return this.lines[this.index++];\r\n    }\r\n\r\n    readEntry (entry: string[], line: string): number {\r\n        if (line == null) return 0;\r\n        line = line.trim();\r\n        if (line.length == 0) return 0;\r\n\r\n        let colon = line.indexOf(':');\r\n        if (colon == -1) return 0;\r\n        entry[0] = line.substr(0, colon).trim();\r\n        for (let i = 1, lastMatch = colon + 1;; i++) {\r\n            let comma = line.indexOf(',', lastMatch);\r\n            if (comma == -1) {\r\n                entry[i] = line.substr(lastMatch).trim();\r\n                return i;\r\n            }\r\n            entry[i] = line.substr(lastMatch, comma - lastMatch).trim();\r\n            lastMatch = comma + 1;\r\n            if (i == 4) return 4;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TextureAtlasPage {\r\n    name: string;\r\n    minFilter: TextureFilter = TextureFilter.Nearest;\r\n    magFilter: TextureFilter = TextureFilter.Nearest;\r\n    uWrap: TextureWrap = TextureWrap.ClampToEdge;\r\n    vWrap: TextureWrap = TextureWrap.ClampToEdge;\r\n    baseTexture: BaseTexture;\r\n    width: number;\r\n    height: number;\r\n    pma: boolean;\r\n\r\n    public setFilters() {\r\n        let tex = this.baseTexture;\r\n        let filter = this.minFilter;\r\n        if (filter == TextureFilter.Linear) {\r\n            tex.scaleMode = SCALE_MODES.LINEAR;\r\n        } else if (this.minFilter == TextureFilter.Nearest) {\r\n            tex.scaleMode = SCALE_MODES.NEAREST;\r\n        } else {\r\n            tex.mipmap = MIPMAP_MODES.POW2;\r\n            if (filter == TextureFilter.MipMapNearestNearest) {\r\n                tex.scaleMode = SCALE_MODES.NEAREST;\r\n            } else {\r\n                tex.scaleMode = SCALE_MODES.LINEAR;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TextureAtlasRegion extends TextureRegion {\r\n    page: TextureAtlasPage;\r\n    name: string;\r\n    index: number;\r\n}\r\n","import {ISkeleton} from \"./ISkeleton\";\r\n\r\n\r\nlet fround_polyfill = (function(array) {\r\n    return function(x: number) {\r\n        return array[0] = x, array[0];\r\n    };\r\n})(new Float32Array(1));\r\n\r\nlet fround: (value: number) => number =\r\n    (Math as any).fround || fround_polyfill;\r\n/**\r\n * @public\r\n */\r\nexport interface Map<T> {\r\n    [key: string]: T;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class IntSet {\r\n    array = new Array<number>();\r\n\r\n    add (value: number): boolean {\r\n        let contains = this.contains(value);\r\n        this.array[value | 0] = value | 0;\r\n        return !contains;\r\n    }\r\n\r\n    contains (value: number) {\r\n        return this.array[value | 0] != undefined;\r\n    }\r\n\r\n    remove (value: number) {\r\n        this.array[value | 0] = undefined;\r\n    }\r\n\r\n    clear () {\r\n        this.array.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class StringSet {\r\n    entries: Map<boolean> = {};\r\n    size = 0;\r\n\r\n    add (value: string): boolean {\r\n        let contains = this.entries[value];\r\n        this.entries[value] = true;\r\n        if (!contains) {\r\n            this.size++;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    addAll (values: string[]): boolean {\r\n        let oldSize = this.size;\r\n        for (var i = 0, n = values.length; i < n; i++)\r\n            this.add(values[i]);\r\n        return oldSize != this.size;\r\n    }\r\n\r\n    contains (value: string) {\r\n        return this.entries[value];\r\n    }\r\n\r\n    clear () {\r\n        this.entries = {};\r\n        this.size = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface Disposable {\r\n    dispose (): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface Restorable {\r\n    restore (): void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Color {\r\n    public static WHITE = new Color(1, 1, 1, 1);\r\n    public static RED = new Color(1, 0, 0, 1);\r\n    public static GREEN = new Color(0, 1, 0, 1);\r\n    public static BLUE = new Color(0, 0, 1, 1);\r\n    public static MAGENTA = new Color(1, 0, 1, 1);\r\n\r\n    constructor (public r: number = 0, public g: number = 0, public b: number = 0, public a: number = 0) {\r\n    }\r\n\r\n    set (r: number, g: number, b: number, a: number) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = a;\r\n        return this.clamp();\r\n    }\r\n\r\n    setFromColor (c: Color) {\r\n        this.r = c.r;\r\n        this.g = c.g;\r\n        this.b = c.b;\r\n        this.a = c.a;\r\n        return this;\r\n    }\r\n\r\n    setFromString (hex: string) {\r\n        hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\r\n        this.r = parseInt(hex.substr(0, 2), 16) / 255;\r\n        this.g = parseInt(hex.substr(2, 2), 16) / 255;\r\n        this.b = parseInt(hex.substr(4, 2), 16) / 255;\r\n        this.a = hex.length != 8 ? 1 : parseInt(hex.substr(6, 2), 16) / 255;\r\n        return this;\r\n    }\r\n\r\n    add (r: number, g: number, b: number, a: number) {\r\n        this.r += r;\r\n        this.g += g;\r\n        this.b += b;\r\n        this.a += a;\r\n        return this.clamp();\r\n    }\r\n\r\n    clamp () {\r\n        if (this.r < 0) this.r = 0;\r\n        else if (this.r > 1) this.r = 1;\r\n\r\n        if (this.g < 0) this.g = 0;\r\n        else if (this.g > 1) this.g = 1;\r\n\r\n        if (this.b < 0) this.b = 0;\r\n        else if (this.b > 1) this.b = 1;\r\n\r\n        if (this.a < 0) this.a = 0;\r\n        else if (this.a > 1) this.a = 1;\r\n        return this;\r\n    }\r\n\r\n    static rgba8888ToColor(color: Color, value: number) {\r\n        color.r = ((value & 0xff000000) >>> 24) / 255;\r\n        color.g = ((value & 0x00ff0000) >>> 16) / 255;\r\n        color.b = ((value & 0x0000ff00) >>> 8) / 255;\r\n        color.a = ((value & 0x000000ff)) / 255;\r\n    }\r\n\r\n    static rgb888ToColor (color: Color, value: number) {\r\n        color.r = ((value & 0x00ff0000) >>> 16) / 255;\r\n        color.g = ((value & 0x0000ff00) >>> 8) / 255;\r\n        color.b = ((value & 0x000000ff)) / 255;\r\n    }\r\n\r\n    static fromString (hex : string) : Color {\r\n        return new Color().setFromString(hex);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class MathUtils {\r\n    static PI = 3.1415927;\r\n    static PI2 = MathUtils.PI * 2;\r\n    static radiansToDegrees = 180 / MathUtils.PI;\r\n    static radDeg = MathUtils.radiansToDegrees;\r\n    static degreesToRadians = MathUtils.PI / 180;\r\n    static degRad = MathUtils.degreesToRadians;\r\n\r\n    static clamp (value: number, min: number, max: number) {\r\n        if (value < min) return min;\r\n        if (value > max) return max;\r\n        return value;\r\n    }\r\n\r\n    static cosDeg (degrees: number) {\r\n        return Math.cos(degrees * MathUtils.degRad);\r\n    }\r\n\r\n    static sinDeg (degrees: number) {\r\n        return Math.sin(degrees * MathUtils.degRad);\r\n    }\r\n\r\n    static signum (value: number): number {\r\n        return value > 0 ? 1 : value < 0 ? -1 : 0;\r\n    }\r\n\r\n    static toInt (x: number) {\r\n        return x > 0 ? Math.floor(x) : Math.ceil(x);\r\n    }\r\n\r\n    static cbrt (x: number) {\r\n        let y = Math.pow(Math.abs(x), 1/3);\r\n        return x < 0 ? -y : y;\r\n    }\r\n\r\n    static randomTriangular (min: number, max: number): number {\r\n        return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\r\n    }\r\n\r\n    static randomTriangularWith (min: number, max: number, mode: number): number {\r\n        let u = Math.random();\r\n        let d = max - min;\r\n        if (u <= (mode - min) / d) return min + Math.sqrt(u * d * (mode - min));\r\n        return max - Math.sqrt((1 - u) * d * (max - mode));\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class Interpolation {\r\n    protected abstract applyInternal (a: number): number;\r\n    apply(start: number, end: number, a: number): number {\r\n        return start + (end - start) * this.applyInternal(a);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Pow extends Interpolation {\r\n    protected power = 2;\r\n\r\n    constructor (power: number) {\r\n        super();\r\n        this.power = power;\r\n    }\r\n\r\n    applyInternal (a: number): number {\r\n        if (a <= 0.5) return Math.pow(a * 2, this.power) / 2;\r\n        return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PowOut extends Pow {\r\n    constructor (power: number) {\r\n        super(power);\r\n    }\r\n\r\n    applyInternal (a: number) : number {\r\n        return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Utils {\r\n    static SUPPORTS_TYPED_ARRAYS = typeof(Float32Array) !== \"undefined\";\r\n\r\n    static arrayCopy<T> (source: ArrayLike<T>, sourceStart: number, dest: ArrayLike<T>, destStart: number, numElements: number) {\r\n        for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\r\n            dest[j] = source[i];\r\n        }\r\n    }\r\n\r\n    static arrayFill<T> (array: ArrayLike<T>, fromIndex: number, toIndex: number, value: T) {\r\n        for (let i = fromIndex; i < toIndex; i++)\r\n            array[i] = value;\r\n    }\r\n\r\n    static setArraySize<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\r\n        let oldSize = array.length;\r\n        if (oldSize == size) return array;\r\n        array.length = size;\r\n        if (oldSize < size) {\r\n            for (let i = oldSize; i < size; i++) array[i] = value;\r\n        }\r\n        return array;\r\n    }\r\n\r\n    static ensureArrayCapacity<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\r\n        if (array.length >= size) return array;\r\n        return Utils.setArraySize(array, size, value);\r\n    }\r\n\r\n    static newArray<T> (size: number, defaultValue: T): Array<T> {\r\n        let array = new Array<T>(size);\r\n        for (let i = 0; i < size; i++) array[i] = defaultValue;\r\n        return array;\r\n    }\r\n\r\n    static newFloatArray (size: number): ArrayLike<number> {\r\n        if (Utils.SUPPORTS_TYPED_ARRAYS)\r\n            return new Float32Array(size)\r\n        else {\r\n            let array = new Array<number>(size);\r\n            for (let i = 0; i < array.length; i++) array[i] = 0;\r\n            return array;\r\n        }\r\n    }\r\n\r\n    static newShortArray (size: number): ArrayLike<number> {\r\n        if (Utils.SUPPORTS_TYPED_ARRAYS)\r\n            return new Int16Array(size)\r\n        else {\r\n            let array = new Array<number>(size);\r\n            for (let i = 0; i < array.length; i++) array[i] = 0;\r\n            return array;\r\n        }\r\n    }\r\n\r\n    static toFloatArray (array: Array<number>) {\r\n        return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\r\n    }\r\n\r\n    static toSinglePrecision (value: number) {\r\n        return Utils.SUPPORTS_TYPED_ARRAYS ? fround(value) : value;\r\n    }\r\n\r\n    // This function is used to fix WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n    static webkit602BugfixHelper (alpha: number, blend: any) {\r\n\r\n    }\r\n\r\n    static contains<T> (array: Array<T>, element: T, identity = true) {\r\n        for (let i = 0; i < array.length; i++)\r\n            if (array[i] == element) return true;\r\n        return false;\r\n    }\r\n\r\n    static enumValue (type: any, name: string) {\r\n        return type[name[0].toUpperCase() + name.slice(1)];\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class DebugUtils {\r\n    static logBones(skeleton: ISkeleton) {\r\n        for (let i = 0; i < skeleton.bones.length; i++) {\r\n            let bone = skeleton.bones[i];\r\n            let mat = bone.matrix;\r\n            console.log(bone.data.name + \", \" + mat.a + \", \" + mat.b + \", \" + mat.c + \", \" + mat.d + \", \" + mat.tx + \", \" + mat.ty);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Pool<T> {\r\n    private items = new Array<T>();\r\n    private instantiator: () => T;\r\n\r\n    constructor (instantiator: () => T) {\r\n        this.instantiator = instantiator;\r\n    }\r\n\r\n    obtain () {\r\n        return this.items.length > 0 ? this.items.pop() : this.instantiator();\r\n    }\r\n\r\n    free (item: T) {\r\n        if ((item as any).reset) (item as any).reset();\r\n        this.items.push(item);\r\n    }\r\n\r\n    freeAll (items: ArrayLike<T>) {\r\n        for (let i = 0; i < items.length; i++)\r\n            this.free(items[i]);\r\n    }\r\n\r\n    clear () {\r\n        this.items.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Vector2 {\r\n    constructor (public x = 0, public y = 0) {\r\n    }\r\n\r\n    set (x: number, y: number): Vector2 {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    length () {\r\n        let x = this.x;\r\n        let y = this.y;\r\n        return Math.sqrt(x * x + y * y);\r\n    }\r\n\r\n    normalize () {\r\n        let len = this.length();\r\n        if (len != 0) {\r\n            this.x /= len;\r\n            this.y /= len;\r\n        }\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class TimeKeeper {\r\n    maxDelta = 0.064;\r\n    framesPerSecond = 0;\r\n    delta = 0;\r\n    totalTime = 0;\r\n\r\n    private lastTime = Date.now() / 1000;\r\n    private frameCount = 0;\r\n    private frameTime = 0;\r\n\r\n    update () {\r\n        let now = Date.now() / 1000;\r\n        this.delta = now - this.lastTime;\r\n        this.frameTime += this.delta;\r\n        this.totalTime += this.delta;\r\n        if (this.delta > this.maxDelta) this.delta = this.maxDelta;\r\n        this.lastTime = now;\r\n\r\n        this.frameCount++;\r\n        if (this.frameTime > 1) {\r\n            this.framesPerSecond = this.frameCount / this.frameTime;\r\n            this.frameTime = 0;\r\n            this.frameCount = 0;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ArrayLike<T> {\r\n    length: number;\r\n    [n: number]: T;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class WindowedMean {\r\n    values: Array<number>;\r\n    addedValues = 0;\r\n    lastValue = 0;\r\n    mean = 0;\r\n    dirty = true;\r\n\r\n    constructor (windowSize: number = 32) {\r\n        this.values = new Array<number>(windowSize);\r\n    }\r\n\r\n    hasEnoughData () {\r\n        return this.addedValues >= this.values.length;\r\n    }\r\n\r\n    addValue (value: number) {\r\n        if (this.addedValues < this.values.length) this.addedValues++;\r\n        this.values[this.lastValue++] = value;\r\n        if (this.lastValue > this.values.length - 1) this.lastValue = 0;\r\n        this.dirty = true;\r\n    }\r\n\r\n    getMean () {\r\n        if (this.hasEnoughData()) {\r\n            if (this.dirty) {\r\n                let mean = 0;\r\n                for (let i = 0; i < this.values.length; i++)\r\n                    mean += this.values[i];\r\n                this.mean = mean / this.values.length;\r\n                this.dirty = false;\r\n            }\r\n            return this.mean;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n","/**\r\n * @public\r\n */\r\nexport let settings = {\r\n    yDown: true,\r\n    /**\r\n     * pixi-spine gives option to not fail at certain parsing errors\r\n     * spine-ts fails here\r\n     */\r\n    FAIL_ON_NON_EXISTING_SKIN: false,\r\n\r\n    /**\r\n     * past Spine.globalAutoUpdate\r\n     */\r\n    GLOBAL_AUTO_UPDATE: true,\r\n\r\n    /**\r\n     * past Spine.globalDelayLimit\r\n     */\r\n    GLOBAL_DELAY_LIMIT: 0,\r\n}\r\n","import {AttachmentType} from './core/AttachmentType';\r\nimport {TextureRegion} from './core/TextureRegion';\r\nimport {TextureAtlasRegion} from './core/TextureAtlas';\r\nimport {MathUtils} from './core/Utils';\r\nimport type {\r\n    IAnimationState,\r\n    IAnimationStateData,\r\n    IAttachment, IClippingAttachment, IMeshAttachment,\r\n    IRegionAttachment,\r\n    ISkeleton,\r\n    ISkeletonData,\r\n    ISlot,\r\n    IVertexAttachment\r\n} from './core/ISkeleton';\r\n\r\nimport {DRAW_MODES} from '@pixi/constants';\r\nimport {Container, DisplayObject} from '@pixi/display';\r\nimport {Sprite} from '@pixi/sprite';\r\nimport {SimpleMesh} from '@pixi/mesh-extras';\r\nimport {Graphics} from '@pixi/graphics'\r\nimport {Rectangle, Polygon, Transform} from '@pixi/math';\r\nimport {hex2rgb, rgb2hex} from '@pixi/utils';\r\nimport type {Texture} from '@pixi/core';\r\nimport {settings} from \"./settings\";\r\n\r\nlet tempRgb = [0, 0, 0];\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface ISpineDisplayObject extends DisplayObject {\r\n    region?: TextureRegion;\r\n    attachment?: IAttachment;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SpineSprite extends Sprite implements ISpineDisplayObject {\r\n    region?: TextureRegion = null;\r\n    attachment?: IAttachment = null;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SpineMesh extends SimpleMesh implements ISpineDisplayObject {\r\n    region?: TextureRegion = null;\r\n    attachment?: IAttachment = null;\r\n\r\n    constructor(texture: Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\r\n        super(texture, vertices, uvs, indices, drawMode);\r\n    }\r\n}\r\n\r\n/**\r\n * A class that enables the you to import and run your spine animations in pixi.\r\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\r\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\r\n *\r\n * ```js\r\n * let spineAnimation = new spine(spineData);\r\n * ```\r\n *\r\n * @public\r\n * @class\r\n * @extends Container\r\n * @memberof spine\r\n * @param spineData {object} The spine data loaded from a spine atlas.\r\n */\r\nexport abstract class SpineBase<Skeleton extends ISkeleton,\r\n    SkeletonData extends ISkeletonData,\r\n    AnimationState extends IAnimationState,\r\n    AnimationStateData extends IAnimationStateData>\r\n    extends Container implements GlobalMixins.Spine {\r\n\r\n    tintRgb: ArrayLike<number>;\r\n    spineData: SkeletonData;\r\n    skeleton: Skeleton;\r\n    stateData: AnimationStateData;\r\n    state: AnimationState;\r\n    slotContainers: Array<Container>;\r\n    tempClipContainers: Array<Container>;\r\n    localDelayLimit: number;\r\n    private _autoUpdate: boolean;\r\n    protected _visible: boolean;\r\n\r\n    abstract createSkeleton(spineData: ISkeletonData);\r\n\r\n    constructor(spineData: SkeletonData) {\r\n        super();\r\n\r\n        if (!spineData) {\r\n            throw new Error('The spineData param is required.');\r\n        }\r\n\r\n        if ((typeof spineData) === \"string\") {\r\n            throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\r\n        }\r\n\r\n        /**\r\n         * The spineData object\r\n         *\r\n         * @member {object}\r\n         */\r\n        this.spineData = spineData;\r\n\r\n        /**\r\n         * A spine Skeleton object\r\n         *\r\n         * @member {object}\r\n         */\r\n        this.createSkeleton(spineData);\r\n\r\n        /**\r\n         * An array of containers\r\n         *\r\n         * @member {Container[]}\r\n         */\r\n        this.slotContainers = [];\r\n\r\n        this.tempClipContainers = [];\r\n\r\n        for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\r\n            let slot = this.skeleton.slots[i];\r\n            let attachment: any = slot.getAttachment();\r\n            let slotContainer = this.newContainer();\r\n            this.slotContainers.push(slotContainer);\r\n            this.addChild(slotContainer);\r\n            this.tempClipContainers.push(null);\r\n\r\n            if (!attachment) {\r\n                continue;\r\n            }\r\n            if (attachment.type === AttachmentType.Region) {\r\n                let spriteName = (attachment.region as TextureAtlasRegion).name;\r\n                let sprite = this.createSprite(slot, attachment as IRegionAttachment, spriteName);\r\n                slot.currentSprite = sprite;\r\n                slot.currentSpriteName = spriteName;\r\n                slotContainer.addChild(sprite);\r\n            } else if (attachment.type === AttachmentType.Mesh) {\r\n                let mesh = this.createMesh(slot, attachment);\r\n                slot.currentMesh = mesh;\r\n                slot.currentMeshId = attachment.id;\r\n                slot.currentMeshName = attachment.name;\r\n                slotContainer.addChild(mesh);\r\n            } else if (attachment.type === AttachmentType.Clipping) {\r\n                this.createGraphics(slot, attachment);\r\n                slotContainer.addChild(slot.clippingContainer);\r\n                slotContainer.addChild(slot.currentGraphics);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\r\n         *\r\n         * @member {number}\r\n         * @memberof spine.Spine#\r\n         */\r\n        this.tintRgb = new Float32Array([1, 1, 1]);\r\n\r\n        this.autoUpdate = true;\r\n        this.visible = true;\r\n    }\r\n\r\n    /**\r\n     * If this flag is set to true, the spine animation will be automatically updated every\r\n     * time the object id drawn. The down side of this approach is that the delta time is\r\n     * automatically calculated and you could miss out on cool effects like slow motion,\r\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\r\n     * autoUpdate enabled but are harder to achieve.\r\n     *\r\n     * @member {boolean}\r\n     * @memberof spine.Spine#\r\n     * @default true\r\n     */\r\n    get autoUpdate(): boolean {\r\n        return this._autoUpdate;\r\n    }\r\n\r\n    set autoUpdate(value: boolean) {\r\n        if (value !== this._autoUpdate) {\r\n            this._autoUpdate = value;\r\n            this.updateTransform = value ? SpineBase.prototype.autoUpdateTransform : Container.prototype.updateTransform;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\r\n     *\r\n     * @member {number}\r\n     * @memberof spine.Spine#\r\n     * @default 0xFFFFFF\r\n     */\r\n    get tint(): number {\r\n        return rgb2hex(this.tintRgb as any);\r\n    }\r\n\r\n    set tint(value: number) {\r\n        this.tintRgb = hex2rgb(value, this.tintRgb as any);\r\n    }\r\n\r\n    /**\r\n     * Limit value for the update dt with Spine.globalDelayLimit\r\n     * that can be overridden with localDelayLimit\r\n     * @return {number} - Maximum processed dt value for the update\r\n     */\r\n    get delayLimit(): number {\r\n        let limit = typeof this.localDelayLimit !== \"undefined\" ?\r\n            this.localDelayLimit : settings.GLOBAL_DELAY_LIMIT;\r\n\r\n        // If limit is 0, this means there is no limit for the delay\r\n        return limit || Number.MAX_VALUE\r\n    }\r\n\r\n    /**\r\n     * Update the spine skeleton and its animations by delta time (dt)\r\n     *\r\n     * @param dt {number} Delta time. Time by which the animation should be updated\r\n     */\r\n    update(dt: number) {\r\n        // Limit delta value to avoid animation jumps\r\n        let delayLimit = this.delayLimit;\r\n        if (dt > delayLimit) dt = delayLimit;\r\n\r\n        this.state.update(dt);\r\n        this.state.apply(this.skeleton);\r\n\r\n        //check we haven't been destroyed via a spine event callback in state update\r\n        if (!this.skeleton)\r\n            return;\r\n\r\n        this.skeleton.updateWorldTransform();\r\n\r\n        let slots = this.skeleton.slots;\r\n\r\n        // in case pixi has double tint\r\n        let globalClr = (this as any).color;\r\n        let light: ArrayLike<number> = null, dark: ArrayLike<number> = null;\r\n\r\n        if (globalClr) {\r\n            light = globalClr.light;\r\n            dark = globalClr.dark;\r\n        } else {\r\n            light = this.tintRgb;\r\n        }\r\n\r\n        // let thack = false;\r\n\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            let slot = slots[i];\r\n            let attachment = slot.getAttachment();\r\n            let slotContainer = this.slotContainers[i];\r\n\r\n            if (!attachment) {\r\n                slotContainer.visible = false;\r\n                continue;\r\n            }\r\n\r\n            let spriteColor: any = null;\r\n\r\n            let attColor = (attachment as any).color;\r\n            switch (attachment.type) {\r\n                case AttachmentType.Region:\r\n                    let region = (attachment as IRegionAttachment).region;\r\n                    if (region) {\r\n                        if (slot.currentMesh) {\r\n                            slot.currentMesh.visible = false;\r\n                            slot.currentMesh = null;\r\n                            slot.currentMeshId = undefined;\r\n                            slot.currentMeshName = undefined;\r\n                        }\r\n                        let ar = region as TextureAtlasRegion;\r\n                        if (!slot.currentSpriteName || slot.currentSpriteName !== ar.name) {\r\n                            let spriteName = ar.name;\r\n                            if (slot.currentSprite) {\r\n                                slot.currentSprite.visible = false;\r\n                            }\r\n                            slot.sprites = slot.sprites || {};\r\n                            if (slot.sprites[spriteName] !== undefined) {\r\n                                slot.sprites[spriteName].visible = true;\r\n                            } else {\r\n                                let sprite = this.createSprite(slot, attachment as IRegionAttachment, spriteName);\r\n                                slotContainer.addChild(sprite);\r\n                            }\r\n                            slot.currentSprite = slot.sprites[spriteName];\r\n                            slot.currentSpriteName = spriteName;\r\n\r\n                            // force sprite update when attachment name is same.\r\n                            // issues https://github.com/pixijs/pixi-spine/issues/318\r\n                        } else if (slot.currentSpriteName === ar.name && !slot.hackRegion) {\r\n                            this.setSpriteRegion(attachment as IRegionAttachment, slot.currentSprite, region);\r\n                        }\r\n                    }\r\n\r\n                    let transform = slotContainer.transform;\r\n                    transform.setFromMatrix(slot.bone.matrix);\r\n\r\n                    if (slot.currentSprite.color) {\r\n                        //YAY! double - tint!\r\n                        spriteColor = slot.currentSprite.color;\r\n                    } else {\r\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\r\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\r\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\r\n                        slot.currentSprite.tint = rgb2hex(tempRgb);\r\n                    }\r\n                    slot.currentSprite.blendMode = slot.blendMode;\r\n                    break;\r\n\r\n                case AttachmentType.Mesh:\r\n                    if (slot.currentSprite) {\r\n                        //TODO: refactor this thing, switch it on and off for container\r\n                        slot.currentSprite.visible = false;\r\n                        slot.currentSprite = null;\r\n                        slot.currentSpriteName = undefined;\r\n\r\n                        //TODO: refactor this shit\r\n                        const transform = new Transform();\r\n                        (transform as any)._parentID = -1;\r\n                        (transform as any)._worldID = (slotContainer.transform as any)._worldID;\r\n                        slotContainer.transform = transform;\r\n                    }\r\n                    const id = (attachment as IVertexAttachment).id;\r\n                    if (!slot.currentMeshId || slot.currentMeshId !== id) {\r\n                        let meshId = id;\r\n                        if (slot.currentMesh) {\r\n                            slot.currentMesh.visible = false;\r\n                        }\r\n\r\n                        slot.meshes = slot.meshes || {};\r\n\r\n                        if (slot.meshes[meshId] !== undefined) {\r\n                            slot.meshes[meshId].visible = true;\r\n                        } else {\r\n                            let mesh = this.createMesh(slot, attachment as IMeshAttachment);\r\n                            slotContainer.addChild(mesh);\r\n                        }\r\n\r\n                        slot.currentMesh = slot.meshes[meshId];\r\n                        slot.currentMeshName = attachment.name;\r\n                        slot.currentMeshId = meshId;\r\n                    }\r\n                    (attachment as IVertexAttachment).computeWorldVerticesOld(slot, slot.currentMesh.vertices);\r\n                    if (slot.currentMesh.color) {\r\n                        // pixi-heaven\r\n                        spriteColor = slot.currentMesh.color;\r\n                    } else {\r\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\r\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\r\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\r\n                        slot.currentMesh.tint = rgb2hex(tempRgb);\r\n                    }\r\n                    slot.currentMesh.blendMode = slot.blendMode;\r\n                    break;\r\n                case AttachmentType.Clipping:\r\n                    if (!slot.currentGraphics) {\r\n                        this.createGraphics(slot, attachment as IClippingAttachment);\r\n                        slotContainer.addChild(slot.clippingContainer);\r\n                        slotContainer.addChild(slot.currentGraphics);\r\n                    }\r\n                    this.updateGraphics(slot, attachment as IClippingAttachment);\r\n                    slotContainer.alpha = 1.0;\r\n                    slotContainer.visible = true;\r\n                    continue;\r\n                default:\r\n                    slotContainer.visible = false;\r\n                    continue;\r\n            }\r\n            slotContainer.visible = true;\r\n\r\n            // pixi has double tint\r\n            if (spriteColor) {\r\n                let r0 = slot.color.r * attColor.r;\r\n                let g0 = slot.color.g * attColor.g;\r\n                let b0 = slot.color.b * attColor.b;\r\n\r\n                //YAY! double-tint!\r\n                spriteColor.setLight(\r\n                    light[0] * r0 + dark[0] * (1.0 - r0),\r\n                    light[1] * g0 + dark[1] * (1.0 - g0),\r\n                    light[2] * b0 + dark[2] * (1.0 - b0),\r\n                );\r\n                if (slot.darkColor) {\r\n                    r0 = slot.darkColor.r;\r\n                    g0 = slot.darkColor.g;\r\n                    b0 = slot.darkColor.b;\r\n                } else {\r\n                    r0 = 0.0;\r\n                    g0 = 0.0;\r\n                    b0 = 0.0;\r\n                }\r\n                spriteColor.setDark(\r\n                    light[0] * r0 + dark[0] * (1 - r0),\r\n                    light[1] * g0 + dark[1] * (1 - g0),\r\n                    light[2] * b0 + dark[2] * (1 - b0),\r\n                );\r\n            }\r\n\r\n            slotContainer.alpha = slot.color.a;\r\n        }\r\n\r\n        //== this is clipping implementation ===\r\n        //TODO: remove parent hacks when pixi masks allow it\r\n        let drawOrder = this.skeleton.drawOrder;\r\n        let clippingAttachment: IClippingAttachment = null;\r\n        let clippingContainer: Container = null;\r\n\r\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\r\n            let slot = slots[drawOrder[i].data.index];\r\n            let slotContainer = this.slotContainers[drawOrder[i].data.index];\r\n\r\n            if (!clippingContainer) {\r\n                //Adding null check as it is possible for slotContainer.parent to be null in the event of a spine being disposed off in its loop callback\r\n                if (slotContainer.parent !== null && slotContainer.parent !== this) {\r\n                    slotContainer.parent.removeChild(slotContainer);\r\n                    //silend add hack\r\n                    (slotContainer as any).parent = this;\r\n                }\r\n            }\r\n            if (slot.currentGraphics && slot.getAttachment()) {\r\n                clippingContainer = slot.clippingContainer;\r\n                clippingAttachment = slot.getAttachment() as IClippingAttachment;\r\n                clippingContainer.children.length = 0;\r\n                this.children[i] = slotContainer;\r\n\r\n                if (clippingAttachment.endSlot === slot.data) {\r\n                    clippingAttachment.endSlot = null;\r\n                }\r\n\r\n            } else {\r\n                if (clippingContainer) {\r\n                    let c = this.tempClipContainers[i];\r\n                    if (!c) {\r\n                        c = this.tempClipContainers[i] = this.newContainer();\r\n                        c.visible = false;\r\n                    }\r\n                    this.children[i] = c;\r\n\r\n                    //silent remove hack\r\n                    (slotContainer as any).parent = null;\r\n                    clippingContainer.addChild(slotContainer);\r\n                    if (clippingAttachment.endSlot == slot.data) {\r\n                        clippingContainer.renderable = true;\r\n                        clippingContainer = null;\r\n                        clippingAttachment = null;\r\n                    }\r\n                } else {\r\n                    this.children[i] = slotContainer;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    private setSpriteRegion(attachment: IRegionAttachment, sprite: SpineSprite, region: TextureRegion) {\r\n        // prevent setters calling when attachment and region is same\r\n        if (sprite.attachment === attachment && sprite.region === region) {\r\n            return;\r\n        }\r\n\r\n        sprite.region = region;\r\n        sprite.attachment = attachment;\r\n\r\n        sprite.texture = region.texture;\r\n        sprite.rotation = attachment.rotation * MathUtils.degRad;\r\n        sprite.position.x = attachment.x;\r\n        sprite.position.y = attachment.y;\r\n        sprite.alpha = attachment.color.a;\r\n\r\n        if (!region.size) {\r\n            sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;\r\n            sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;\r\n        } else {\r\n            //hacked!\r\n            sprite.scale.x = region.size.width / region.originalWidth;\r\n            sprite.scale.y = -region.size.height / region.originalHeight;\r\n        }\r\n    }\r\n\r\n    private setMeshRegion(attachment: IMeshAttachment, mesh: SpineMesh, region: TextureRegion) {\r\n\r\n        if (mesh.attachment === attachment && mesh.region === region) {\r\n            return;\r\n        }\r\n\r\n        mesh.region = region;\r\n        mesh.attachment = attachment;\r\n        mesh.texture = region.texture;\r\n        region.texture.updateUvs();\r\n        mesh.uvBuffer.update(attachment.regionUVs);\r\n    }\r\n\r\n    protected lastTime: number;\r\n\r\n    /**\r\n     * When autoupdate is set to yes this function is used as pixi's updateTransform function\r\n     *\r\n     * @private\r\n     */\r\n    autoUpdateTransform() {\r\n        if (settings.GLOBAL_AUTO_UPDATE) {\r\n            this.lastTime = this.lastTime || Date.now();\r\n            let timeDelta = (Date.now() - this.lastTime) * 0.001;\r\n            this.lastTime = Date.now();\r\n            this.update(timeDelta);\r\n        } else {\r\n            this.lastTime = 0;\r\n        }\r\n\r\n        Container.prototype.updateTransform.call(this);\r\n    };\r\n\r\n    /**\r\n     * Create a new sprite to be used with core.RegionAttachment\r\n     *\r\n     * @param slot {spine.Slot} The slot to which the attachment is parented\r\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n     * @private\r\n     */\r\n    createSprite(slot: ISlot, attachment: IRegionAttachment, defName: string) {\r\n        let region = attachment.region;\r\n        if (slot.hackAttachment === attachment) {\r\n            region = slot.hackRegion;\r\n        }\r\n        let texture = region.texture;\r\n        let sprite = this.newSprite(texture);\r\n\r\n        sprite.anchor.set(0.5);\r\n        this.setSpriteRegion(attachment, sprite, attachment.region);\r\n\r\n        slot.sprites = slot.sprites || {};\r\n        slot.sprites[defName] = sprite;\r\n        return sprite;\r\n    };\r\n\r\n    /**\r\n     * Creates a Strip from the spine data\r\n     * @param slot {spine.Slot} The slot to which the attachment is parented\r\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n     * @private\r\n     */\r\n    createMesh(slot: ISlot, attachment: IMeshAttachment) {\r\n        let region = attachment.region;\r\n        if (slot.hackAttachment === attachment) {\r\n            region = slot.hackRegion;\r\n            slot.hackAttachment = null;\r\n            slot.hackRegion = null;\r\n        }\r\n        let strip = this.newMesh(\r\n            region.texture,\r\n            new Float32Array(attachment.regionUVs.length),\r\n            attachment.regionUVs,\r\n            new Uint16Array(attachment.triangles),\r\n            DRAW_MODES.TRIANGLES);\r\n\r\n        if (typeof (strip as any)._canvasPadding !== \"undefined\") {\r\n            (strip as any)._canvasPadding = 1.5;\r\n        }\r\n\r\n        strip.alpha = attachment.color.a;\r\n\r\n        strip.region = attachment.region;\r\n        this.setMeshRegion(attachment, strip, region);\r\n\r\n        slot.meshes = slot.meshes || {};\r\n        slot.meshes[attachment.id] = strip;\r\n        return strip;\r\n    };\r\n\r\n    static clippingPolygon: Array<number> = [];\r\n\r\n    //@ts-ignore\r\n    createGraphics(slot: ISlot, clip: IClippingAttachment) {\r\n        let graphics = this.newGraphics();\r\n        let poly = new Polygon([]);\r\n        graphics.clear();\r\n        graphics.beginFill(0xffffff, 1);\r\n        graphics.drawPolygon(poly as any);\r\n        graphics.renderable = false;\r\n        slot.currentGraphics = graphics;\r\n        slot.clippingContainer = this.newContainer();\r\n        slot.clippingContainer.mask = slot.currentGraphics;\r\n\r\n        return graphics;\r\n    }\r\n\r\n    updateGraphics(slot: ISlot, clip: IClippingAttachment) {\r\n        let geom = slot.currentGraphics.geometry;\r\n        let vertices = (geom.graphicsData[0].shape as Polygon).points;\r\n        let n = clip.worldVerticesLength;\r\n        vertices.length = n;\r\n        clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\r\n        geom.invalidate();\r\n    }\r\n\r\n    /**\r\n     * Changes texture in attachment in specific slot.\r\n     *\r\n     * PIXI runtime feature, it was made to satisfy our users.\r\n     *\r\n     * @param slotIndex {number}\r\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n     * @returns {boolean} Success flag\r\n     */\r\n    hackTextureBySlotIndex(slotIndex: number, texture: Texture = null, size: Rectangle = null) {\r\n        let slot = this.skeleton.slots[slotIndex];\r\n        if (!slot) {\r\n            return false;\r\n        }\r\n        let attachment: any = slot.getAttachment();\r\n        let region: TextureRegion = attachment.region;\r\n        if (texture) {\r\n            region = new TextureRegion();\r\n            region.texture = texture;\r\n            region.size = size;\r\n            slot.hackRegion = region;\r\n            slot.hackAttachment = attachment;\r\n        } else {\r\n            slot.hackRegion = null;\r\n            slot.hackAttachment = null;\r\n        }\r\n        if (slot.currentSprite && slot.currentSprite.region != region) {\r\n            this.setSpriteRegion(attachment, slot.currentSprite, region);\r\n            slot.currentSprite.region = region;\r\n        } else if (slot.currentMesh && slot.currentMesh.region != region) {\r\n            this.setMeshRegion(attachment, slot.currentMesh, region);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Changes texture in attachment in specific slot.\r\n     *\r\n     * PIXI runtime feature, it was made to satisfy our users.\r\n     *\r\n     * @param slotName {string}\r\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n     * @returns {boolean} Success flag\r\n     */\r\n    hackTextureBySlotName(slotName: string, texture: Texture = null, size: Rectangle = null) {\r\n        let index = this.skeleton.findSlotIndex(slotName);\r\n        if (index == -1) {\r\n            return false;\r\n        }\r\n        return this.hackTextureBySlotIndex(index, texture, size);\r\n    }\r\n\r\n    /**\r\n     * Changes texture of an attachment\r\n     *\r\n     * PIXI runtime feature, it was made to satisfy our users.\r\n     *\r\n     * @param slotName {string}\r\n     * @param attachmentName {string}\r\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n     * @returns {boolean} Success flag\r\n     */\r\n    hackTextureAttachment(slotName: string, attachmentName: string, texture, size: Rectangle = null) {\r\n        // changes the texture of an attachment at the skeleton level\r\n        const slotIndex = this.skeleton.findSlotIndex(slotName)\r\n        const attachment: any = this.skeleton.getAttachmentByName(slotName, attachmentName)\r\n        attachment.region.texture = texture\r\n\r\n        const slot = this.skeleton.slots[slotIndex]\r\n        if (!slot) {\r\n            return false\r\n        }\r\n\r\n        // gets the currently active attachment in this slot\r\n        const currentAttachment: any = slot.getAttachment()\r\n        if (attachmentName === currentAttachment.name) {\r\n            // if the attachment we are changing is currently active, change the the live texture\r\n            let region: TextureRegion = attachment.region\r\n            if (texture) {\r\n                region = new TextureRegion()\r\n                region.texture = texture\r\n                region.size = size\r\n                slot.hackRegion = region\r\n                slot.hackAttachment = currentAttachment\r\n            } else {\r\n                slot.hackRegion = null\r\n                slot.hackAttachment = null\r\n            }\r\n            if (slot.currentSprite && slot.currentSprite.region != region) {\r\n                this.setSpriteRegion(currentAttachment, slot.currentSprite, region)\r\n                slot.currentSprite.region = region\r\n            } else if (slot.currentMesh && slot.currentMesh.region != region) {\r\n                this.setMeshRegion(currentAttachment, slot.currentMesh, region)\r\n            }\r\n            return true\r\n        }\r\n        return false\r\n    }\r\n\r\n    //those methods can be overriden to spawn different classes\r\n    newContainer() {\r\n        return new Container();\r\n    }\r\n\r\n    newSprite(tex: Texture) {\r\n        return new SpineSprite(tex);\r\n    }\r\n\r\n    newGraphics() {\r\n        return new Graphics();\r\n    }\r\n\r\n    newMesh(texture: Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\r\n        return new SpineMesh(texture, vertices, uvs, indices, drawMode);\r\n    }\r\n\r\n    transformHack() {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Hack for pixi-display and pixi-lights. Every attachment name ending with a suffix will be added to different layer\r\n     * @param nameSuffix\r\n     * @param group\r\n     * @param outGroup\r\n     */\r\n    hackAttachmentGroups(nameSuffix: string, group: any, outGroup: any) {\r\n        if (!nameSuffix) {\r\n            return undefined;\r\n        }\r\n        const list_d = [], list_n = [];\r\n        for (let i = 0, len = this.skeleton.slots.length; i < len; i++) {\r\n            const slot = this.skeleton.slots[i];\r\n            const name = slot.currentSpriteName || slot.currentMeshName || \"\";\r\n            const target = slot.currentSprite || slot.currentMesh;\r\n            if (name.endsWith(nameSuffix)) {\r\n                target.parentGroup = group;\r\n                list_n.push(target);\r\n            } else if (outGroup && target) {\r\n                target.parentGroup = outGroup;\r\n                list_d.push(target);\r\n            }\r\n        }\r\n        return [list_d, list_n];\r\n    };\r\n\r\n    destroy(options?: any): void {\r\n        for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\r\n            let slot = this.skeleton.slots[i];\r\n            for (let name in slot.meshes) {\r\n                slot.meshes[name].destroy(options);\r\n            }\r\n            slot.meshes = null;\r\n\r\n            for (let name in slot.sprites) {\r\n                slot.sprites[name].destroy(options);\r\n            }\r\n            slot.sprites = null;\r\n        }\r\n\r\n        for (let i = 0, n = this.slotContainers.length; i < n; i++) {\r\n            this.slotContainers[i].destroy(options);\r\n        }\r\n        this.spineData = null;\r\n        this.skeleton = null;\r\n        this.slotContainers = null;\r\n        this.stateData = null;\r\n        this.state = null;\r\n        this.tempClipContainers = null;\r\n\r\n        super.destroy(options);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * The visibility of the spine object. If false the object will not be drawn,\r\n * the updateTransform function will not be called, and the spine will not be automatically updated.\r\n *\r\n * @member {boolean}\r\n * @memberof spine.Spine#\r\n * @default true\r\n */\r\nObject.defineProperty(SpineBase.prototype, 'visible', {\r\n    get: function () {\r\n        return this._visible;\r\n    },\r\n    set: function (value: boolean) {\r\n        if (value !== this._visible) {\r\n            this._visible = value;\r\n            if (value) {\r\n                this.lastTime = 0;\r\n            }\r\n        }\r\n    }\r\n})\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AACA;;ACNA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1FA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AClWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1eA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uIACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;"}